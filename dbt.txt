
								DBMS(DAY 2)
								
GOOD MORNING 

	DAY 2:-
		1) DATA
		2) HISTORY OF RDBMS
		3) DATA + DBMS = DATABASE
		
		CODD'S RULE : 12 RULES 
		
		ACID : 
			
		DATABASE > SCHEMAS > TABLES > ROWS AND COLUMN > CELLS(DATA)
		
		1) INSTALLED MYSQL (START RUNNING IN OUR WINDOWS SERVICE)
			WINDOWS > RUN  > SERVICES.MSC 
			MYSQL80 - 
			3306 PORT
			
		2) HOW TO CONNECT WITH THE SERVER 
			ITS COMES WITH TWO INTERFACES 
			
				1) MYSQL COMMAND LINE
				2) MYSQL WORKBENCH : UI FRAMEWORK WHICH ALLOWS ME TO VIEW 
						ALL DATABASES,TABLES
						PROVIDE ME A PLACE WHERE I CAN RUN THE QUERIES 
						PROVIDE THE OUTPUT 
						PROVIDE THE LOGS 
						SUGGEESTION
				3) COMMAND LINE OF WINDOWS 
					FOR JAVA - JAVAC , JAVA 
							IT ALWAYS THROWS ERROR 
								NOT RECOGNISED THE COMMANDS 
					FOR MYSQL.EXE 
							IT THROWS ERROR - NOT RECOGNIZED THE COMMAND 
							
					ADDED THE PATH TILL BIN IN THE ENVIORNMENT VARIABLE 
				
					C:\Program Files\MySQL\MySQL Server 8.0\bin

					mysql.exe -u root -p
						* 
							-u username
							-p password

------------------------------------------------------------------------

			HOW TO WORK WITH THE MYSQL PROMPT 
			
				1) VIEW ALL THE DATABASES EXIST IN THE SYSTEM 
						
						SHOW DATABASES;
						
				2) ACCESS THE DATABASE AND NEED TO KNOW ABOUT THE DATABASE 
					WHAT IT CONTAINS 
					
					USE DATABASENAME;
					
				3) IN WHICH DATABASE ARE YOU IN 
					
					SELECT DATABASE();
					
				4) ; IS A TERMINATOR OPERTORS FROM THE COMMAND LINE 

				5) VIEW ALL THE TABLES 
					
					SHOW TABLES;
					
				6) VIEW THE STRUCTURE 
					STRUCTURE : 
							VIRTUAL WAY OF REPRESENTING THE TABLES 
								MEANS ALL THE COLUMNS WITH THEIR DATATYPE AND SOME OTHER INFORMATION
					TABLES : 
						1) ROWS AND COLUMNS 
						2) WITHOUT THIS STRUCTURE, WE ARE NOT ALLOWED TO INSERT ANY DATA IN THE DATABASE 
						3) STRUCTURE : DEFINATION OF THE TABLE 
						
					DESCRIBE / DESC 
					
					DESC TABLENAME;
					DESCRIBE TABLENAME;
					
				7) DATA DICTONARY 
					
						MYSQL - information_schema
							IS TREATED AS DATA DICTONARY 
							
					WHAT EVER YOU DO IN YOUR SCHEMA - EVERY REFERENCE STORE IN THE INFORMATION_SCHEMA 
					
					INFORMATION_SCHAME - READ ACCESS 
					
				8) DATABASE - REFENRECE 
					HRSCHEMA
					SOURCE C:\RAHUL\hrschema.sql

========================================================================

STARTS WITH THE DBMS :-

		DATABASE PROVIDED A LINEAR SYNTAX FOR INTERATING WITH THE DATABASE 
		
		FOR BASIC FUNCTIONS NEED TO BE PEFORMED IN THE DATABASE 
			
				ARE COMES FROM 9 DIFFERENT COMMANDS 
				
		INTRACT 
				THEY TOOK AROUND 2 YEARS TO GENERATE THESE COMMANDS
				TOOK 2 YEARS TO MAKE USERS FEEL FREIENDLY WHILE WORKING WITH THE DATABASES
				
		SQL : STRUCTURED QUERY LANGUAGE 
				THIS LANGUAGE IS COMMAN TO ALL THE RDBMS 
				
			SELECT 
			CREATE 
			ALTER
			DROP
			INSERT
			UPDATE 
			DELETE
			COMMIT 
			ROLLBACK
			
			THEY DIVIDED THESE COMMANDS BASED ON THERE NATURE INTO VARIOUS CATEGORIES
			
			
	FOUR DIFFERENT CATEGORIES :-

		1) DQL : DATA QUERY LANGUAGE 
		
			SELECT 
			
			WHICH IS A VERY POWERFULL COMMAND ONLY AND ONLY 
				USED TO FETCH DATA FROM THE DATABASE 
			IT WON'T EFFECT ANYTHING IN THE DATABASE 
			IT WON'T CHANGE ANYTHING IN THE DATABASE 
				LIKE YOUR DATA , STRUCTURE .....
				
		2) DML : DATA MANIPULATION LANGUAGE 
			
				MANIPULATION : NEED TO TO CHNAGE 
				
				INTERACT WITH THE DATABASE FOR 
				PROVIDING DATA
				MODIFYING THE DATA 
				REMOVING THE DATA 
				
				NEVER EVER TOUCH THE STRUCTURE OF THE TABLE 
				
				IT ALWAYS WORKS WITH THE DATA 
				
				EMPID    EMPNAME  EMPADDRESS EMPMOBILENO 
				102		RAHUL		B1 106		7620987578
				
				* INSERT  - USED TO INSERT NEW RECORD IN THE TABLE
				* UPDATE  - USED TO UPDATE THE EXISTING VALUES 
							LIKE EMPLOYEE E101, SALARY 6000 
							UPDATE SALARY FROM 6000 TO 10000 
				* DELETE  - USED TO REMOVE THE COMPLETE RECORD FROM THE TABLES 
					
		3) DDL : DATA DEFINATION LANGUAGE 
			
					DEFINATION :
						STRUCTURE 
					
					MANIPULATION IN THE STRUTURE OR CREATION OF THE STRUCTRE 
						WILL BE DONE OR EXECUTED BY DDL COMMANDS 
						
				CREATE : 
					USED TO CREATE NEW TABLE IN THE DATABASE 
					
				ALTER : 
					USED TO MODIFY THE EXISTING STRUCTURE 
				
				DROP  : 
					USED TO DROP THE EXISTING STRUCTURE OR TABLES
					
					- DROP : REMOVE THE COMPLETE STRUTURE WITH THE DATA 
						FROM THE DATABASE
					
					
					
		4) DTL :
				DATA TRANSACTIONAL LANGUAGE 
					
					COMMIT 
					
					ROLLBACK 
					
					
		5) DCL : 
				DATA CONTROL LANGUAGE 
					ON SECURITY OF THE DATA 
					
				GRANT : PROVIDE PERMISSION
				
				REVOKE : REMOVE THE PERMISSION
					
==================================================================		
DATABASE : 
		
		CREATE DATABASE DATABASENAME;
		
		CREATE DATABASE DACSTUDENTS;
		
		* ALL SYNTAX ARE CASE INSENSTIVE IN MYSQL 
		

DDL : 
		DATA DEFINATION LANGUAGE 
		
		CREATE : 
		
				ALLOWS ME TO CREATE NEW STRUCTURE 
				
		SYNTAX: 
			
				CREATE TABLE TABLENAME 
				(
				COLUMNNAME DATATYPE,
				COLUMNNAME2 DATATYPE,
				COLUMNNAME3 DATATYPE,
				COLUMNNAME4 DATATYEP
				);
			
	DATATYPE :- 
		
			ARE DEFINING THE COLUMNS WHICH TYPE OF DATA GOING TO INSERT IN THAT PERTICULAR COLUMN 
			
			INT A,B,C;
			STRING VAR1,
			
			SET VAR1 = "RAHUL"
			SET A  = 234
			
		THREE CATEGORIES :- 
			
			1) NUMERIC DATATYPE :-
					USED TO STORE THE NUMBERS 

					TINYINT  : 
							RANGE -128 TO 127 
					ID TINYINT;
	
						IT WONT CONTAINS VALUES OTHER THEN THE REFERENCE RANGE 
							
					SMALLINT : 
							-32768 TILL 32767
					INT : 
						-214748648 TILL 214748647
					BIGINT
						-9223372036854775808 TILL 9223372036854775807
					FLOAT
						FLOAT(4,2) : 
								4 DIGITS OUT OF 4 , 2 ARE PRECISION 
								
							45.34
							344.4
						DOUBLE(5,2)
						
					CREATE TABLE NUMERICDATATYPE
					(
					IT TINYINT,
					ISI SMALLINT,
					II INT,
					IBI BIGINT,
					IFD FLOAT(4,2)
					);
					
					INT(3) - ONLY 3 DIGIT 
					INT(5) - 5 DIGIT 
							
		--- 
			INSERT INTO TABLE VALUES(ALL VALUES SEPERATED WITH COMMA);
			
			INSERT INTO NUMERICDATATYPE VALUES(125,2345,3434434,454545,34.34);
							
			INSERT INTO NUMERICDATATYPE VALUES(456,2345,3434434,454545,34.34);				
							
							
		-- VIEW DATA INSERTED IN THE TABKE 

			SELECT 
				WHICH ALLOWS ME TO VIEW THE DATA FROM THE TABLE 
				
			SELECT * FROM TABLENAME;
			
			SELECT  - KEYWORD
			*  - ALL THE COLUMNS 
			FROM - KEYWORD 
			TABLENAME - TABLE FROM WHICH WE NEED TO FETCH DATA 
			
			------
			
				SHOW WARNINGS;
				
				
		2) STRING DATATYPE 
				WHICH STORES THE STRING VALUES 
				
					* CHAR 1 TO 255 CHARACTERS
						IS A DATATYPE COMES WITH THE SIZE 
						CHAR(5) - ONLY ACCEPT 5 CHARATERS STRING  
						CHAR(2) - ONLY ACCEPT 2 CHARATERS STRING 
						
					** COMES WITH FIXED LENGHT 
						NAME CHAR(20)
							
						NAME = RAHUL

						SYSTEM STORE FULL 20 CHARCTERS FOR RAHUL 
					** BENEFIT IN TERMS OF SEARCH 
						SEARCH ENGINE WORKS FASTER WITH THE SAME LENGHT 
						
				** VARCHAR 1 TO 255 CHARACTERS 
						OF LENGHT 
							255 CHARACTERS
							
					NAME VARCHAR,  - NOT ALLOWED 
					NAME VARCHAR(20) - ITS MEANS THIS COLUMN CAN ACCEPT 20 CHARACTER STRING 
					
					DIFFERENCE - VARCHAR COLUMNS ARE DYNAMIC IN THE SIZE BASED ON THE VALUE INSERTED 
					
					NAME = RAHUL ===== 5
					NAME = NIKHILSARASWAT ==== 14
					
				** TEXT 
					
				
				ENGINE :-
						1) LENGTH 
						2) VALUE 
						
						FIND RAHUL = 
						
						LENGTH = 5 
							
					CHAR : 
						SIZE FIXED 
							COMPARISON OF LENGTH 
								DOES NOT MAKE ANY SENCE 
						
							COLUMN LENGHT 
								START DOING COMPARISON 
							
							NAME@@@@@@@@@@@ 
							RAHUL@@@@@@@@@@ 
							RITESH@@@@@@@@@ 
							NIKHILSARASWAT@
							SONIA@@@@@@@@@@
							
							RAHUL@@@@@@@@@@
							
--------------------IN TERMS OF VARCHAR 
							NAME 
							RAHUL
							RITESH
							NIKHILSARASWAT
							SONIA

							RAHUL 
								PICK FIRST VALUE RAHUL
								CHECK THE LENGTH 5  ALSO 5 
								COMPARE 
								
							PICK SECOND VALUE RITESH 6 
								CONVERT THE COMPARISON STRING 
									RAHUL ---- RAHUL@
									
								COMPARISION WITH THE  
									
				* TEXT : MAXIMUM LENGTH 65535 CHARACTERS 
							SYSTEM DOESN'T ALLOW TO HAVE THESE COLUMNS 
								AS A PRIMARY KEY 
								
	------------------------------------------------------------------

			* DATE 
			
				** DATE : IT STORES DATE IN THE DEFAULT FORMAT OF 
					YYYY-MM-DD 
					
				** DATETIME : IT STORES DATE WITH TIME 
					DEFAULT FORMAT : 
						YYYY-MM-DD HH:MI:SS
						
					MYSQL DEFAULT DATETIME FORMAT 
						2021-07-01 12:23:23
						
					SYSTEM DATA STORAGE FORMAT CAN NOT BE CHANGES 
						WE CAN NOT CHNAGE THE DEFAULT STORAGE FORMAT OF THE DATABASE 
				** TIMESTAMP : 
						DATETIME WITH TIMESTAMP 
							USED WHEN MY SOFTWARE NEED TO ACCESSED AT DIFFERENT GIO GRAHICAL LOCATION WITH DIFFRENT TIME ZONE 
						
				
----------------------------------------------------------------------

DDL :-
		CREATE TABLE TABLENAME
		(
		COLUMNNAME1 DATATYPE,
		COLUMNNAME2 DATATYPE,
		COLUMNNAME3 DATATYPE		
		);
			
		NEW TABLE CONTAINS VARIOUS COLUMNS 
			LIKE EMPID OF INT, EMPNAME STRING, EMPDOB DATETIME, 
			EMPMOBILENO OF INTEGER TYPE 
			
			CREATE TABLE EMPLOYEE 
			(
			EMPID INT,
			EMPNAME VARCHAR(50),
			EMPDOB DATETIME,
			EMPMOBINO BIGINT
			);
			
		INSERT VALUES TO THIS TABLE 
		
		*
		**** STRING AND DATE VALUES MUST COME OR PROVIDE WITH SINGLE QUOTE 
		
		STRINGS AND DATE : ''
		
		INSERT INTO 
		EMPLOYEE 
		VALUES(102,'RITESH','2021-07-01 06:23:23',7620987578);
		
----------------------------------------------------------------------

* CREATE TABLES 
			AT THE TIME OF CREATION 
				1) WE NEED TO DECIDE WHICH COLUMN CONTAINS WHICH VALUE(DATATYPE)
				2) DECIDE WHICH COLUMNS NEED TO BEHAVE WITH RESTRICTION 
					
				REQUIRED CERTAIN COLUMNS WITH CONDITION
				
				RESTRICT END USER TO ENTER VALUES WHICH IS NOT RELEVANT BASED ON YOUR DEFINATION
				
				
		RESTRICTION ON COLUMNS  - TERMS OF DATABASE 
								THESE CALLED AS CONSTRAINTS 
							
	CONSTRAINTS : 
				ARE NOTHING ELSE THE RESCTRICTION 
					
			CREATE TABLE TABLENAME 
				(
				COLUMN1 DATATYPE CONTRAINSTS,
				COLUMN2 DATATYPE CONSTRAINTS
				);
				
CONSTRINTS :- 

		1) PRIMARY KEY :- 
					COMES WITH A DEFINATION / RULES 
					
					* WON'T ALLOW COLUMN MENTIONED AS PRIMARY KEY 
						TO HAVE NULL VALUES 
					
						NO NULL VALUES 
					
					* IT'S VALUES ARE UNIQUE 
					USER NOT ALLOWED TO INSERT DUPLICATE VALUES IN THIS COLUMN 
					
					* EACH TABLE WILL ONLY HAVE ONE PRIMARY KEY 
					
					* SYSTEM AUTOMATICALLY CREATES INDEXES FOR THIS COLUMN 
					
					
			SYNTAX :-

				CREATE TABLE PRIMARYKEYEXAMPLE
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20)
				);
				
				INSERT INTO PRIMARYKEYEXAMPLE VALUES(101,'RAHUL');
				INSERT INTO PRIMARYKEYEXAMPLE VALUES(101,'RITESH');
				
				
				
				CREATE TABLE PRIMARYKEYEXAMPLE1
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20) PRIMARY KEY
				);
				
				
		* NO NULL VALUES
		* NO DUPLICATE VALUES 
		* SINGLE PRIMARY KEY PER TABLE 
		
				
				
		INSERT INTO PRIMARYKEYEXAMPLE VALUES(NULL,'RAHUL');		
					
		ANOTHER SYNTAX OF INSERT 

		INSERT INTO TABLEBAME(COLUMNNAME SEPERATED WITH COMMA) VALUES(SAME SEQUEANCE DEFINE VALUES SEPERATED WITH COMMA);
		
		INSERT INTO PRIMARYKEYEXAMPLE(EMPNAME) VALUES ('RAHUL')
					
		INSERT INTO PRIMARYKEYEXAMPLE(EMPID) VALUES (103);

		INSERT INTO PRIMARYKEYEXAMPLE(EMPID,EMPNAME) VALUES (103);
		
		2) ENHANCEMENT OF PRIMARY KEY RULE 
				SINGLE PRIMARY KEY IN THE TABLE 
				
		THERE MAY A SCENARIO WHHERE WE HAVE A TABLE WITHOUT ANY SIGNLE COLUMN BEHAVE LIKE A PRIMARY 
			
			
			
			EMPNAME EMPFATHERNAME EMPDOB EMPSALARY EMPADD 
			
		
		SYSTEMS ALLOWS ME TO HAVE A CONSOLIDATE PRIMARY KEY 
		
		CONSOLIDATE PRIMARY KEY :
						CREATE PRIMARY KEY WITH MULTIPLE COLUMNS 
						
			SYNTAX FOR CONSOLIDATE PRIMARY KEY 
			
				CREATE TABLE CONSOLIDATEPRIMARYKEY 
				(
				EMPNAME VARCHAR(20),
				EMPFATHERNAME VARCHAR(20),
				EMPDOB DATETIME,
				EMPSAL INT,
				EMPADD VARCHAR(200),
				PRIMARY KEY (EMPNAME,EMPFATHERNAME,EMPDOB)
				);
				
			INSERT INTO 
			CONSOLIDATEPRIMARYKEY 
			VALUES('RAHUL','SUBHASH','1987-02-02 12:12:12',23434,'VIMAN NAGAR');
			
			INSERT INTO 
			CONSOLIDATEPRIMARYKEY 
			VALUES('RAHUL','SUBHASH','1989-02-02 12:12:12',23434,'VIMAN NAGAR');
			
			INSERT INTO 
			CONSOLIDATEPRIMARYKEY 
			VALUES('RAHUL','NIKHIL','1987-02-02 12:12:12',23434,'VIMAN NAGAR');
			
	-----------------------------------------------------------------

	2) UNIQUE 
			: 
				* NO DUPLICATE VALUE 
				* HAVE MULTIPLE UNIQUE CONSTRAINT 
				* UNIQUE COLUMN ACCEPT NULL VALUE 
				
			**** NULL , NULL , NULL 
			MULTIPLE NULL IN THE COLUMN IS ALLOWED 
				BECAUSE OF THE CODD'S RULE TO BAHAVE SEPERATLY FOR NULL 
				
				NULL - DATA MISSING, DATA NOT KNOWN , DATA IS NULL 
				
				NULL IT SELF CONTAINS A UNIQUE VALUE 
				MEANS EVERY NULL IS DIFFERENT THEN THE OTHER NULL 
				
				NULL = NULL CAN NOT COMPARE , IT ALWAYS RETRUN FALSE 
				
				CREATE TABLE UNIQUEEXAMPLE
				(
				ID INT PRIMARY KEY, 
				NAME VARCHAR(20),
				MOBNO BIGINT UNIQUE,
				EMPREF VARCHAR(20) UNIQUE 
				);
			
			
			INSERT INTO UNIQUEEXAMPLE VALUES(102,'RAHUL',7620987534,'NIKHIL');
				
			INSERT INTO UNIQUEEXAMPLE(ID,MOBNO,NAME) VALUE(103,9879879898,'RITESH')	

------------------------------------------------------------------------

3) NOT NULL : 

			* COLUMN DOESN'T ALLOW NULL VALUE 
			
			CREATE TABLE NULLEXAMPLE
			(
			ID INT,
			NAME VARCHAR(20) NOT NULL 
			);

			INSERT INTO NULLEXAMPLE(ID) VALUES(101)

4) NOW - IF YOU NEED TO SAY, YOU NEED TO ACHIVE A MULTIPLE PRIMARY KEY 
		FOR YOUR TABLE 
			
				BASED ON THE DEFINATION 
					PRIMARY : 
							UNIQUE 
							NOT NULL 
							
			** 
				CREATE TABLE MULTIPLEKEYEXAMPLE
				(
				ID INT PRIMARY KEY,
				NAME VARCHAR(20),
				MOBILENUMBER BIGINT UNIQUE NOT NULL
				);
							
 ==============================TODAY===================================

				
							DAY 3 
							
REVISION : 
		
			DDL : DATA DEFINATION LANGUAGE 
					STRUCTURE 
					
					CREATE / ALTER / DROP 
					WHICH ONLY WORKS ON TABLE STRUCTURES
			
			CREATE : 
				HOW TO CREATE DATABASE
				HOW TO CREATE TABLES 
				HOW TO DEFINE THE TABLES 
					WITH COLUMNS AND COLUMN DATATYPE 
				WHAT ARE ALL DATATYPE 
					NUMERIC
					STRING
					DATE 
				TABLES WITH THE COMBINATION OF ALL ABOVE 
				PROVIDING RESTRICTION TO THE END USER FOR ENTERING DATA IN THE TABLE 
				
				CONSTRAINTS : 
						PRIMARY KEY 
						UNIQUE
						NOT NULL 
						
------------------------------------------------------------------------

4) FOREIGN KEY :-

			1) TWO TABLES NEED TO BE IN A RELATIONSHIP 
			2) THESE TABLES MUST BE TREATED AS PARENT AND CHILD 
			
			CONSIDERING THERE ARE TWO TABLES 
				EMPLOYEES :
					ALL DATA RELATED TO EMPLOYEES 
				
						DEPARTMENT
							ALL DATA RELATED TO DEPARTMENT 
						
				EMPLOYEE 
					EMPID , EMPNAME, EMPSAL, EMPDOB, DEPTID
					
					
				DEPARTMENT 
					DEPTID, DEPTNAME
						
						
				-- EMPLOYEE TABLE IS DEPENDENT ON DEPARTMENT TABLE ---

				-- EMPLOYEE : CHILD
				
				-- DEPARTMENT : PARENT 
						
			3) ** WE NEED TO HAVE PARENT TABLE FIRST 
				 ** THEN WE CREATE CHILD TABLE 
				 
			
			RULES : 
				1) TWO TABLE ARE IN PARENT CHILD RELATIONSHIP 
				2) COLUMN WHICH REFERED IN THE PARENT TABLE MUST BE A PRIMARY KEY 
				3) FOREIGN CONSTRAINT WILL BE APPLIED TO THE CHILD TABLE 
				 
				 
				 
			PAREANT TABLE :-

				CREATE TABLE DEPARTMENTS
				(
				DEPTID INT PRIMARY KEY,
				DEPTNAME VARCHAR(20)
				);
				
				INSERT INTO DEPARTMENTS VALUES(10,'HR');
				INSERT INTO DEPARTMENTS VALUES(20,'MARKETING');
				INSERT INTO DEPARTMENTS VALUES(30,'FINANCE');
				INSERT INTO DEPARTMENTS VALUES(40,'PRODUCT');
				SYNTAX :
					
	FOREIGN KEY(COLUMN NAME OF CHILD TABLE) 
						REFERENCES PARENTTABLENAME(PARENT TABLE COLUMN NAME);
						
				CREATE TABLE EMPLOYEES
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20),
				EMPSAL INT,
				DEPTID INT,
				FOREIGN KEY(DEPTID) REFERENCES DEPARTMENTS(DEPTID)
				);
				
		INSERT INTO EMPLOYEES VALUES(101,'RAHUL',8979,10);	
		INSERT INTO EMPLOYEES VALUES(102,'SUNITA',8979,NULL);	
			** USAGE - RESTRICTION 
			
			SYSTEM WILL NOT ALLOW END USER TO INSERT ANY VALUE IN THE COLUMN OF CHILD TABLE WHICH DOESN'T EXIT IN THE PARENT TABLE 
			
			* EVERY EMPLOYEE HAVE DEPAARTMENT ID WHICH MUST PRESENT IN THE DEPARTMENT TABLE 
			* NULL IN THE FOREIGN COLUM IS ALLOWED
			
	****************************************************************		
		NAME TO THE CONSTRAINT :-

			CREATE TABLE EMPLOYEES
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20),
				EMPSAL INT,
				DEPTID INT,
				CONTRAINT EMPLOYEE_FK FOREIGN KEY(DEPTID) REFERENCES DEPARTMENTS(DEPTID)
				);
			
-----------------------------------------------------------------------

SIMILAR TERM : 
		COMPOSITE PRIMARY 
		ALSO DEFINE COMPOSITE FOREIGN KEY 
		
		* PARENT AND CHILD TABLES
		* NUMBER OF COLUMNS INVOLVED IN THE FOREIGN KEY 
		MUST PRESENT IN THE BOTH THE TABLE 
		* PARENT TABLE MUST HAVE A COMPOSITE PRIMARY KEY 
		* CHILD TABLE REFER TO THE PARENT TABLE COLUMNS
		
		
		CREATE TABLE DEPARTMENTC
		(
		DEPTNAME VARCHAR(20),
		DEPARTMENTL VARCHAR(20),
		DEPARTMENTCITY VARCHAR(20),
		PRIMARY KEY(DEPTNAME,DEPARTMENTL)
		);
		
		INSERT INTO DEPARTMENTC VALUES('HR','VIMANNAGAR','PUNE');
		INSERT INTO DEPARTMENTC VALUES('HR','WAKAD','PUNE');
		INSERT INTO DEPARTMENTC VALUES('MARKETING','WAKAD','PUNE');
		
		CREATE TABLE EMPLOYEEC
		(
		EMPID INT PRIMARY KEY,
		EMPNAME VARCHAR(20),
		DEPTN VARCHAR(20),
		DEPTL VARCHAR(20),
		CONSTRAINT EMPLOYEEC_FK FOREIGN KEY(DEPTN,DEPTL) 
				REFERENCES DEPARTMENTC(DEPTNAME,DEPARTMENTL)
		);
		
		INSERT INTO EMPLOYEEC VALUES(101,'RAHUL','HR','MEERUT');

----------------------------------------------------------------------

FOREIGN KEY CONSTRAINTS 

	RULES 
			PARENT AND CHILD TABLE 
			PARENT TABLE MUST HAVE PRIMARY KEY 
			CHILD TABLE REFERS PARENT TABLE 
			CONPOSITE FOREIGN KEY , WE MUST HAVE COMPOSITE PRIMARY KEY 
			
	**
		WHAT WILL HAPPEN WHEN YOU REMOVE THE DATA FROM CHILD AND PARENT TABLE 

		* END USER CAN DELETE DATA FROM CHILD TABLE AS THIS TABLE DOESN'T HAVE ANY DEPENDENCY 
		*END USER CAN NOT DELETE DATA FROM PARENT IF THE REFERENCES EXIST IN THE CHILD TABLE 
		
		TO DELETE A PERTICULAR RECORDS 
		
			SYNTAX : 
				DELETE FROM TABLENAME WHERE CONDITION;
				
				DELETE FROM 
				
====================================================================

MAY BE A SCENARIO - THAT WE HAVE MULIPLE RECORDS EXIST IN THE CHILD TABLE 	

		100 EMPLOYEES BELONGS TO DEPARTMENT 10 
		
			* TWO WAYS TO DELETE DEPARTMENT 10 
				1) UPDATE EMPLOYEES WORKING IN DEPARTMENT 10 WITH NULL VALUE 
				2) DELETE ALL THE EMPLOYEES WHICH BELONGS TO DEPARTMENT 10 
				
-------- REQUIRED THIS TO BE MANAGE MY THE SYSTEM AUTOMATICALLY 

** CASCADING 

			* ON DELETE SET NULL 
				WHEN YOU ARE DELETING DATA FROM PARENT TABLE 
					UPDATE THE CHILD REFERENCES WITH NULL VALUE 

EMP 						DEPT (DELETE)

101 RAHUL 10(NULL)			10   HR  --- DELTING THIS RECORD 
101 RAHUL 20				20   MARKETING
			

			* ON DELETE CASCADE 
				WHEN YOU ARE DELETING DATA FROM PARENT TABLE 	
					DELETE THE COMPLETE REFERENCES FROM THE CHILD TABLE 
					
EMP 						DEPT (DELETE)

							10   HR  --- DELTING THIS RECORD 
101 RAHUL 20				20   MARKETING	
	
			* ON UPDATE CASCADE 
				WHEN YOU UPDATE DATA IN THE PARENT TABLE 
					JUST UPDATE THE CHILD TABLE WITH THE SAME VALUE 
					
EMP 						DEPT (DELETE)

101 RAHUL 10(30)			10(30)   HR  --- UPDATING THIS RECORD 
101 RAHUL 20				20   MARKETING			

SYNTAX : 

	FOREIGN KEY(CHILD COLUMN NAME) REFERENCES PARENT TABLE(PARENT TABLE COLUMN NAME) ON DELETE CASCADE 
	
	
	
EXAMPLE OF ON DELTE SET NULL 

				CREATE TABLE DEPARTMENTSETNULL
				(
				DEPTID INT PRIMARY KEY,
				DEPTNAME VARCHAR(20)
				);
				
				INSERT INTO DEPARTMENTSETNULL VALUES(10,'HR');
				INSERT INTO DEPARTMENTSETNULL VALUES(20,'MARKETING');
				INSERT INTO DEPARTMENTSETNULL VALUES(30,'FINANCE');
				INSERT INTO DEPARTMENTSETNULL VALUES(40,'PRODUCT');
	
						
				CREATE TABLE EMPLOYEESSETNULL
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20),
				EMPSAL INT,
				DEPTID INT,
				FOREIGN KEY(DEPTID) REFERENCES DEPARTMENTSETNULL(DEPTID)
				ON DELETE SET NULL
				);
				
		INSERT INTO EMPLOYEESSETNULL VALUES(101,'RAHUL',8979,10);	
		INSERT INTO EMPLOYEESSETNULL VALUES(102,'SUNITA',8979,20);	
		INSERT INTO EMPLOYEESSETNULL VALUES(103,'NIKITA',890000,10);
	

EXAMPLE FOR ON DELETE CASCADE 

				CREATE TABLE DEPARTMENTCASCADE
				(
				DEPTID INT PRIMARY KEY,
				DEPTNAME VARCHAR(20)
				);
				
				INSERT INTO DEPARTMENTCASCADE VALUES(10,'HR');
				INSERT INTO DEPARTMENTCASCADE VALUES(20,'MARKETING');
				INSERT INTO DEPARTMENTCASCADE VALUES(30,'FINANCE');
				INSERT INTO DEPARTMENTCASCADE VALUES(40,'PRODUCT');
	
						
				CREATE TABLE EMPLOYEESCASCADE
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20),
				EMPSAL INT,
				DEPTID INT,
				FOREIGN KEY(DEPTID) REFERENCES DEPARTMENTCASCADE(DEPTID)
				ON DELETE CASCADE
				);
				
		INSERT INTO EMPLOYEESCASCADE VALUES(101,'RAHUL',8979,10);	
		INSERT INTO EMPLOYEESCASCADE VALUES(102,'SUNITA',8979,20);	
		INSERT INTO EMPLOYEESCASCADE VALUES(103,'NIKITA',890000,10);


EXAMPLE FOR ON UPDATE CASCADE 

				CREATE TABLE DEPARTMENTUCASCADE
				(
				DEPTID INT PRIMARY KEY,
				DEPTNAME VARCHAR(20)
				);
				
				INSERT INTO DEPARTMENTUCASCADE VALUES(10,'HR');
				INSERT INTO DEPARTMENTUCASCADE VALUES(20,'MARKETING');
				INSERT INTO DEPARTMENTUCASCADE VALUES(30,'FINANCE');
				INSERT INTO DEPARTMENTUCASCADE VALUES(40,'PRODUCT');
	
						
				CREATE TABLE EMPLOYEESUCASCADE
				(
				EMPID INT PRIMARY KEY,
				EMPNAME VARCHAR(20),
				EMPSAL INT,
				DEPTID INT,
				FOREIGN KEY(DEPTID) REFERENCES DEPARTMENTUCASCADE(DEPTID)
				ON UPDATE CASCADE
				);
				
		INSERT INTO EMPLOYEESUCASCADE VALUES(101,'RAHUL',8979,10);	
		INSERT INTO EMPLOYEESUCASCADE VALUES(102,'SUNITA',8979,20);	
		INSERT INTO EMPLOYEESUCASCADE VALUES(103,'NIKITA',890000,10);

==================================================================

5) DEFAULT 

			WHICH ALLOWS TO INSERT DEFAULT VALUE TO THE PERTICULAR COLUMN WHEN THE VALUE IS NOT PROVIDED
			
			CREATE TABLE EMP 
			(
			EMPID INT PRIMARY KEY,
			EMPNAME VARCHAR(200),
			DEPTID INT DEFAULT 10
			);
			
			** NOT PROVIDED - ASSIGN DEFAULT VALUE 
		
			MULTIPLE 
				TABLE 
					ADDEDBY
					ADDEDDATETIME
					UPDATEDBY
					UPDATEDDATETIME 
					
			CREATE TABLE EMP1 
			(
			EMPID INT PRIMARY KEY,
			EMPNAME VARCHAR(200),
			DEPTID INT DEFAULT 10,
			ADDEDDATETIME DATETIME DEFAULT NOW()
			);		
					

6) CHECK 
			THIS CONSTRAINT RESTRICT USER TO INSERT OR UPDATE VALUES BASED ON THE CONDITION PROVIDED 
			 
			 CHECK ALWAYS COMES WITH CONDITION
			 
			 EXAMPLE 
				DO NOT WANT ANYBODY INSERT EMPLOYEE SALARY > 70000
				
			SALARY INT CHECK SALARY < 70000
			
			IF SALARY < 70000
			THEN 
			 ALLOWS INSERT OT UPDATING 
			 ELSE 
			 THROWS ERROR (BREAKING CONSTRINT)
			 END 
			 
			 CREATE TABLE EMPCHECK
			 (
			 EMPID INT,
			 EMPNAME VARCHAR(20),
			 EMPSAL INT CHECK(EMPSAL < 70000)
			 );
			 
-------------------------------------------------------------------

7) AUTO_INCREMENT 
			
				ITS BEHAVES LIKE A SEQUENE 
					WHOSE VALUE START FROM 
						1 AND INCREMENTED BY ONE
						
					--- IS USED ON CERTAIN COLUMN WHERE I WANT VALUE TO BE AUTOMATICALLY INSERT WITHOUT MISSING ANY VALUE 
					
					HOW THIS WORKS 
					
					* INSERT A RECORD 
					* IT PICS THE MAXIMUM VALUE OF THAT COLUMN 
					* MAXIMUM VALUE + 1
					* INSERT THAT RECORD WITH THAT VALUE 
					
					EMPLOYEE ID = 106
					INSERT NEW RECORD 
							IT AUTOMATICALLY ENTER 107 
							 WHEN THE VALUE NOT PROVIDED 
					
					* COLUMN WHICH WE ARE MENTIONING AS AUTO_INCREMENT 
							NEED TO BE A PRIMARY KEY 
					
					
					CREATE TABLE EMPAUTOINREMENT
					(
					EMPID INT PRIMARY KEY AUTO_INCREMENT,
					EMPNAME VARCHAR(20)
					);
					
					
		----- TWO WAYS TO INITIALIZE THE VALUES OF THE TABLE 

				* INSERT ONE RECORD BY YOUR SELF WITH THAT PERTICULAR VALUE 
				* ASSIGN THE VALUE TO AUTO_INCREMENT 
				
				ALTER TABLE EMPAUTOINREMENT AUTO_INCREMENT = 1000;
				
---------------------------------------------------------------------

		RESTRICTION WILL BE PROVIDED TO THE COLUMNS 
		
					PRIMARY KEY 
					UNIQUE 
					NOT NULL 
					FOREIGN KEY 
					DEFAULT 
					CHECK 
					AUTO_INCREMENT 
					
		ENUM CONSTRAINT 
				ENUM : SET OF VALUES 
					
					
			CREATE TABLE EMPENUM
			(
			ID INT,
			NAME VARCHAR(20),
			GENDER ENUM('M','F','O')
			);
			 
-----------------VARIOUS TYPE OF CONSTAINTS CAN BE APPLIED ON THE TABLE FOR STOPING END USER TO PERFORM CERTAIN ACTION BASED ON THE VALUES -----------------------------------------------------------------------

			 CREATE TABLE TABLENAME 
			 (
			 COLUMNNAME DATATYPE CONSTRAINTS,
			 COLUMN2 DATATYPE CONSTRAINTS
			 ...
			 ..
			 ..
			 
			 );
			 
-------------------------------------------------------------------------

SECOND COMMAND IN THE DDL IS ALTER 

		** WE ARE INTERATING WITH THE STRUCTURE NOT WITH THE DATA 
		
		LETS FEW THINGS THAT WE EXPECT FROM ALTER 
		
				** MODIFY THE EXISTING STRUCTURE OF THE TABLE 
				
				1) NEW COLUMNS 
				2) DROP EXISTING COLUMN 
				3) CHANGE THE DATATYPE OF THE COLUMN 
				4) CHANGE THE SIZE OF THE DATATYPE 
				5) NEED TO CHANGE THE NAME OF THE COLUMN 
				6) NEED ADD CONSTRAINTS TO THE EXISTING COLUMN 
				7) NEED TO RENAME THE TABLE NAME 
				
				
		* NEW COLUMN 
		
		SYNTAX : 
			ALTER TABLE TABLENAME ADD COLUMNNAME DATATYPE;
			
			ALTER TABLE EMPENUM ADD SALARY INT;
			* CREATES NEW COLUMN IN THE TABLE EMPENUM
			* INSERT NULL AS AN VALUE 
			
		* REMOVE COLUMN FROM THE TABLE 
			
			SYNTAX : 
			ALTER TABLE TABLENAME DROP COLUMNNAME;
			
			ALTER TABLE EMPENUM DROP SALARY;

		* CHANGE THE EXISTING DATATYPE OR SIZING 

			SYNTAX : 
			
			ALTER TABLE TABLENAME MODIFY COLUMN DATATYPE;
			
			ALTER TABLE EMPENUM MODIFY NAME VARCHAR(30);
		
				
		* DATATYPE CHANGE ONLY ALLOWED 
			EITHER THERE IS NO VALUE IN THAT COLUMN 
			OR BASED ON THE DATATYPE IT FIT WITH THE REQUIRENMENT 
				STRING CAN NOT BE CHANGE TO INT 
				INT CAN BE CHANGE TO STRING 
				DATE CAN NOT BE CHANGE TO INT 
				INT CAN BE CHANGE TO FLOAT 
				INT CAN BE CHANGE TO DOUBLE 
				
		* CHANGE THE NAME OF THE COLUMN 

			SYNTAX : 
				ALTER TABLE TABLENAME CHANGE OLDNAME NEWNAME DATATYPE;
				
			ALTER TABLE EMPENUM CHANGE ID EMPID INT;	

		* NEED TO ADD ANY CONSTRAINTS 
			PRIMARY KEY ON EMPID COLUMN 
			
			SYNTAX : 
				ALTER TABLE TABLENAME ADD PRIMARY KEY(COLUMNNAME);
				
			ALTER TABLE EMPENUM ADD PRIMARY KEY(EMPID);	

				CAN NOT ALTER ANY COLUMN WITH CONSTRAINTS 
					IF THE COLUMN VALUE NOT SATISFYING THE RULES OF THE CONSTRAINTS 
					
			ALTER TABLE EMPENUM MODIFY GENDER CHAR(1) NOT NULL;	

			ALTER TABLE TABLENAME ADD FOREIGN KEY(COLUMNNAME) REFERECES PARENTTABLENAME(PARENTCOLUMNNAME);
			
			
			REMOVE NOT NULL CONSTRAINT :-
			
				ALTER TABLE EMPENUM MODIFY GENDER CHAR(1);
				
			ALTER TABLE EMPENUM DROP PRIMARY KEY;
			
			ALTER TABLE EMPENUM DROP CONSTRAINT CONSTRAINT_NAME;
			
			
	******* RENAME THE TABLENAME 
		
				ALTER TABLE EMPENUM RENAME TO EMPNEWNAME;
			

-------------------------------------------------------------------------

3) DROP :
		* DROP COMMAND IS USED TO DROP THE COMPLETE TABLE FROM THE DATABASE WITH DATA 
		* RESTRICTION : TABLE WHICH WE ARE DROPING IS ALREADY HAVING RELATION SHIP OR DEPENCY ON THE OTHER TABLE 
			THEY SYSTEM WILL NOT ALLOW TO DROP THAT PERTICULAR TABLE 
			
			
		DROP TABLE TABLENAME ;

		DROP DATABASE DATABASENAME;
		
		DROP TABLE EMPNEWNAME;
			
			
			
***************
************
*******
			DDL COMMANDS ARE AUTOCOMMIT IN NATURE ****************
													************
														**********
		
			
		CLIENT MACHINE 
				STANDARD QUERY LANGUAGE 
					SERVER 
						QUERY PROCESSING 
						
	QUERY PROCESSING :
			
				DATABASE FOR EVERY USER 
					CREATE ON SESSION 
							SESSIONID 
				ALONG WITH SESSIONID 
					ALSO CREATED ONE TEMPRORAY MEMORY 
					
				QUERY PROCESSING HAPPEING - IT HAPPENING IN TEMP MEMORY 
					THEN IT THOWS EITHER ON THE CLIENT MACHINE 
					OR TOWARDS THE DATABASE
					
					
		DDL COMMANDS - HITS YOUR DATABASE DIRECLTY 
						THESE COMMANDS NEVER PROCESSED IN THE TEMP MEMORY 
						
		IT DIRECTLY HAMPERING YOUR PHYSICAL LOCATION OF THE DATABASE 
		
		*** YOU CAN NOT REVERT THE CHANGES PERFORMED BY THE DDL COMMANDS
		
		
-------------------------------------------

DML COMMANDS : 
			
				ARE NOT AUTOCOMMIT IN NATURE 
					
					
					

** COMMIT 
		USED TO PUSH THE DATA FROM TEMP MEORY TO THE PHYSICAL LOCATION OF THE DATABASE 
		
** ROLLBACK : 
		USED TO REOLLBACK THE CHANGE NOT MOVED TO THE DATABASE 
			DATA IS IN TEMP MEMORY CAN BE ROLLEDBACK
			
					
----------------------------------------------------------------------

DML : 

	INSERT 
		USED TO HAVE A NEW RECORD IN THE TABLE 
		
		
	UPDATE 
		USED TO UPDATE THE EXISTING VALUE OF THE ROW
	
	DELETE 
		DELETE THE ROWS FROM THE TABLE 
		

DQL : SELECT 
			



							DAY 4
							
							
TOPICS COVERED :
		DDL 
			ALTER 
			DROP
			CREATE
		CONTRAINTS 
			PRIMARY KEY 
			FOREIGN KEY 
			DEFAULT 
			NOT NULL 
			UNIQUE 
			ENUM
			CHECK
			AUTO_INCREMENT
			
			
			** DDL ARE AUTOCOMMIT IN NATURE 
			
				** DML COMMANDS REQUIRED COMMIT TO PUSH THE DATA FROM TEMP TO PHYSICAL LOCATION
				
				COMMIT / ROLLBACK 
				
				COMMIT : PUSH THE DATA 
				ROLLBACK : REVERT THE DATA FROM TEMP MEMORY TILL LAST COMMIT OR DDL STATEMENTS
				
				
			
------------------------------------------------------------------------

DML : DATA MANIPULATION LANGUAGE 

	DIRECTLY IMPACT ONLY ON THE DATA 
	
	INSERT / UPDATE / DELETE 
	
	INSERT : 
			 * USED TO INSERT THE NEW RECORDS IN THE TABLE 
			 * INSERT COMMAND ALWAYS INSERT ALL THE VALUES OF THE COLUMNS EXIST IN THE TABLE 
			 
	SYNTAX : 
		
			INSERT INTO TABLENAME VALUES(VALUES WITH COMMA SEPERATED);
			
			RULES : 
				* NON OF THE COLUMNS IN THE ABOVE SYNTAX SHOULD MISSED TO ENTER 
				* SEQUENCE OF MENTIONING THE COLUMN VALUE MUST BE THE SAME AS THE TABLE STRUCTURE 
				
			CREATE TABLE EMPINSERT
			(
			ID INT,
			NAME VARCHAR(20),
			DOB DATETIME,
			SALARY INT
			)
				
			INSERT INTO EMP VALUES(INT,VARCHAR(20),DATETIME,INT);

			CAN NOT INSERT FOR ABOVE TABLE 
				LIKE 
			INSERT INTO EMP VALUES('RAHUL',101,'2021-02-02',34334);
				
			
** CORRECT INSERT INTO EMP VALUES(101,'RAHUL','2021-02-02',433434);

	==============================================================

SCENARIO : TABLE HAVE 50 COLUMNS AND I ONLY HAVE 5 VALUE TO INSERTED AND THERE ARE NO OTHER VALUES WHICH ARE MANDATORY 


	SYNTAX : 
	
		INSERT INTO TABLENAME(COLUMNS SEPERATED WITH COMMA) VALUES(VALUES IN THE SAME STRUCTURE YOU MENTIONED AFTER THE TABLE NAME SEPERATED WITH COMMA);
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUE(101,'RITESH',80000);
		
		** VALUES MENTIONED IN THE INSERT PUSHED TO THE DATABASE IN THE RESPECTIVE COLUMNS
		** REST ALL THE COLUMN WILL HAVE NULL VALUES 
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUE(80000,'NIKHIL',102);
		
	----------------------------------------------------------------

HOW DO WE INSERT MULTIPLE RECORDS IN THE TABLE :-

		OPEN SOURCE DATABASES PROVIDE THE PROVISION TO INSERT MULTIPLE RECORDS WITH INSERT COMMAND 
		
		INSERT INTO TABLENAME VALUES(VALUES SEPERATED WITH COMMA),(VALUES SEPERATED WITH COMMA);
		
		
		INSERT INTO EMPINSERT(ID,NAME,SALARY) VALUES(104,'SUNITA',9000),
		(105,'SHIPA',50000),(106,'KRISHAN',8444);
		
------------------------------------------------------------------------

2) UPDATE 
			: COMMAND IS USED TO UPDATE THE EXISTING DATA OF THE TABLE 
			
			** POWERFULL COMMAND 
			
			SYNTAX :: 
					UPDATE TABLENAME SET KEY COLUMN = VALUE ;
					
					OR 
					
					UPDATE TABLENAME SET KEYCOLUMN1 = VALUE,KEYCOLUMN2 = VALUE;
					
			* POWERFULL COMMAND 
				IF YOU EXECUTE THE UPDATE COMMAND WITHOUT THE CONDITION 
					IT WILL UPDATE THE COMPLETE COLUMN WITH THE SAME VALUE MENTIONED AT THE TIME UPDATE EXECUTION
					
			UPDATE EMPINSERT SET DOB = '1987-02-02';
			
			WHENEVER YOU EXECUTE UPDATE DO MENTION CONDITION
			
			UPDATE THE SALARY OF EMPLOYEE 101 
			
			SYNTAX  : 
				UPDATE TABLENAME SET COLUMN = VALUE WHERE CONDITION;
				
				UPDATE EMPINSERT SET SALARY = 5000 WHERE ID = 101;
				
					EXECUTION 
					* EMPINSERT AND FOUND THE RCORDS MACHES THE CONDITION 
						ID = 101 
					* PULL ALL THOSE RECORDS IN THE TEMP MEMORY 
					* UPDATE THE SALARY = 5000
					* PUSH THE DATA TO THE DATABASE 
					
	---------------------------------------------------------

		UPDATE EMPINSERT SET SALARY = 4000,DOB = '1987-03-03' WHERE ID = 104;
					
			*
				UPDATE COMMAND WTH MULTIPLE COLUMN ALWAYS UPDATE SINGLE RECORD 
				CONDITION RETURN MORE THEN ONE RECORD - ALL THE RETUNED RECORDS WILL BE UPDATED BY THE VALUES 
				
--------------------------------------------------------------------------

3) DELETE 
		:	 DELETE COMMAND IS USED TO DELETE THE COMPLETE RECORD FROM THE TABLE 
			* POWERFULL COMMAND AND NEED LITLE PRECAUTION TO EXECUTE 
			
				* DELETE COMMAND WITHOUT CONDITION DELETE COMPLETE TABLE 
					ONLY LEFT STRUCTURE 
					
		SYNTAX : 
			
				DELETE FROM TABLENAME WHERE CONDITION ;
				
				DELETE FROM EMPINSERT;

			* FEW THINGS ATTACH TO DELETE 
				* REMOVES THE COMPLETE RECORD FROM THE TABLE 
				* REMOVE THE RECORD - IT WONT REMOVE THE SPACE ALLOCATED TO IT 
				
		** TRUNCATE : 
				TRUNCATE ALSO REMOVES DATA FROM  THE TABLE 
					
	DELETE 									TRUNCATE 

DELETE COMMAND REMOVES RECORDS			TRUNCATE COMMAND REMOVES RECORDS
DELETE COMMAND COMES WITH 				TRUNCATE - NO CONDITION
CONDITION 	 					
										TRUNCATE USED TO REMOVE ALL THE RECORDS OF THE TABLE 
DELETE NEVER RELEASE THE SPACE 			TRUNCATE REMOVE DATA AND RELEASE 
ALLOCATED TO THE ROWS					THE SPACE AS WELL	
					
					
	SYNTAX : 

			TRUNCATE TABLE EMPINSERT; 
					
----------------------------------------------------------------------


	DML WORKS : 
			ON THE DATA 
			THESE ARE NOT AUTOCOMMIT IN NATURE 
			SYSTEM REQUIRED EXPLICITLY COMMIT TO PUSH THE DATA FROM TEMP TO MAIN TABLES
			
			INSERT 
			
			UPDATE 
			
			DELETE 
			
================================================================

DQL : 
		SELECT 
			WHICH IS VER POWERFULL COMMAND 
				AND MOSTLY USED COMMAND 
				90% OF INDUSTRY PEOPLE ONLY USE THIS COMMAND 
				
			* FETCH DATA FROM THE DATABASE 
			* SELECT COMMAND NERVER EVER TOUCH THE DATA DATA (MODIFY THE DATA OR STRUCTURE)
			* GET THE DATA 
			
			IMPACT ANYTHING IN DATABASE
			
			
	SYNTAX : 
			SELECT * FROM TABLENAME; 
			
			
				SELECT  : COMMAND (MILLIONS OF LINES OF CODE,C,C++)
				*  		: ALL THE COLUMNS OF THE TABLE 
				FROM 	: KEYWORDS INDICATES ABOUT THE TABLENAME 
				TABLENAME :	TABLE FROM WHERE WE NEED TO FETCH THE DATA 
				
			
			SELECT * FROM EMPINSERT;
			
				* RETURNS ALL THE ROWS AND COLUMNS IN THE OUTPUT 
				
	** 
		RESTRICT TO BRING CERTAINT COLUMNS FROM THE TABLE IN THE OUTPUT 
		
			SELECT COLUMNNAME SEPERATED WITH COMMA FROM TABLENAME;
			
			** SELECT  -----------------------------MANDATORY 
					EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY 
						FROM  ----------------------MANDATORY 
							EMPLOYEES;
			
			** SELECT 
				LAST_NAME,FIRST_NAME,SALARY, HIRE_DATE 
					FROM 
						EMPLOYEES;
			
			* THIS DOESN'T MEANS THAT IT DOING ANY CHANGES IN THE TABLE 
			NO NO NO 
				JUST FOR MY OUTPUT 
					ITS BRINGING THE DATA AND PUBLISHING ON MY SCREEN
					
--------** 
			IF NEED TO RESCTRICT THE ROWS FROM THE TABLE 
			
				INTRODUCE A WHERE CLAUSE 
				
			WHERE CLAUSE : 
					IS A PART OF THE SELECT STATEMENT
					IS THE FIRST CLAUSE EXECUTED IN THE COMPLETE SELECT STATEMENT 
					DO DIRECT FILTER FROM THE DATABASE 

					
					
	CLIENT  >>>   SERVER  >>> TEMP MEM (PROCESSING)
				
					
			SELECT 
				COLUMN NAME SEPERATED WITH COMMA 
					FROM 
						TABLENAME 
							WHERE 
								CONDITION 
								
								
CONDITION : 
		OPERATORS :
				KEY AND VALUE ATTACH TO IT 
				
					WHERE ID = 101
					ID : KEY 
					101 : VALUE 
					= : OPERATOR 
					
		RATIONAL OPERATORS : 
			
					=, <, > , <=, >= , <> , != 
					
	
	YOU NEED TO FIND THE EMPLOYEES BELONGS TO DEPARTMENT 20 
	
		* ALL THE EMPLOYEES COLUMNS 
		* REQUIRED ONLY THOSE ROWS WHERE DEPARTMENT_ID = 20 
		
		SELECT 
			* 
			FROM EMPLOYEES 
				WHERE 
					DEPARTMENT_ID = 20 ;
					
	EXECUTION :
			* FILTER THE DATA FROM THE DATABASE BASD ON THE CONDITION 
				DEPARTMENT_ID = 20
			* WHICH EVER THE ROWS MATCHES - RETURNED TO THE TEMP MEMORY 
			* THERE IT CREATE A TEMP TABLE WITH ALL THE DATA 
			* THROWS THE OUTPUT TO THE SCREEN 
			
			
		SELECT 
			FIRST_NAME,LAST_NAME, SALARY 
			FROM EMPLOYEES 
				WHERE 
					DEPARTMENT_ID = 20 ;
			
			
************************

	WHERE MULTIPLE CONDITION TAKE PLACE 
		
		NEED TO FIND THE EMPLOYEES BELONGS TO DEPARTMENT 80 
			ALONG WITH THAT NEED TO FILTER DATA BASED ON THE SALARY 
				SALARY MUST BE GREATER THE 6000 
				
			* REQUIRED ALL THE COLUMNS OF EMPLOYEE TABLE 
			* TWO CONDITION	
				DEPARTMENT_ID = 80 
				SALARY > 6000
				
MULTIPLE CONDITION : 

	INTRODUCE LOGICAL OPERATORS : 
	
		LOGICAL OPERATOR : 
					
						AND  : ALL THE CONDITION MUST BE TRUE 
					CONDITION1 AND CONDITION2 
						IT WILL ONLY RETURN RECORD WHEREN CONDITION1 AND CONDITION2 SATISFIED
						
						OR  : ANY ONE OF THE CONDITION IS TRUE 
						NOT : NEGATION OF THE CONDITION 
						
	
	QUERY : 

		SELECT 
			DEPARTMENT_ID,SALARY,EMPLOYEE_ID 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							AND 
						SALARY > 6000; 
						
		EXECUTE : 
			* WHERE IS FIRST CLAUSE NEED TO BE EXECUTED 
			* PICK UP FIRST RECORD OF THE TABLE AND CHECK 
				
				FOR(I=0,I++,I=ROWCOUNT)
				{
				IF(DEPARTMENT_ID = 80)
					{
					IF(SALARY > 6000)
						{
							RETUNS TRUE;
						}
					RETRUN FALSE;
					}
				}	
				
				
				
	*****************

		PEOPLE REQIRED ALL EMPLOYEES WITH DEPARTMENT_ID = 20 AND 30 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 20 AND  DEPARTMENT_ID = 30;
						
			** NO RECORD WILL BE FETCHED 

			
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 20 AND  DEPARTMENT_ID = 30;		
				
			RETUNS ALL THE EMPLOYEES BELONGS TO 20 AND 30 

-------------------------------------------------------------------
	
** NULL - NEED TO TREATED DIFFERNTLY IN THE DATABASE 
	
		NULL - ALWAYS UNIQUE VALUE 
			 - AIRTHMETIC OPERATION WITH ALWAYS RETURN NULL 
			 
			
		LIKE 
			
				2000 + NULL = NULL 
				3000 * NULL = NULL 
				
		DATABASE 
			SELECT 2000 + NULL; 
			
		
		ORACLE : 
				DUAL : ONE ROW ONE COLUMN
				
				SAYS WHEN EVER YOU WANT TO GET CERTAIN DATA WHICH IS NOT RELATED TO TABLE 
					THEN USE DUAL 
					
	HANDLE NULL : 
			INTRODUCE VARIOUS CONCEPT 
				TO SEARCH IN THE TABLLE 

	* FIND THOSE EMPLOYEE GETTING NO COMMISSION 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						COMMISSION_PCT = NULL;

		COMPARISON WITH NULL - DATABASE INTORDUCE A OPERATOR OR KEYWORD 
							
									IS 
									
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						COMMISSION_PCT IS NULL;


				80000 + (25/100 * 80000)	
					
** 
		RATIONAL OPERATORS 
		LOGICAL OPERATORS 
		AIRTHMETIC OPERATORS 
				:
					(),*,+,-,/
			
			
		EXAMPLE 
			25 HIKE OF THE EMPLOYEE GETTING 80000 SALARY 
			
				
				SELECT	80000 * 1.25 
				
				SELECT ALWAYS EXCUTED ON THE TABLE 
					
					SELECTION IS NOT DEPENDENT ON THE TABLE 
						INTRODUCE 
							DUMMY TABLE 
								DUAL 
								ONE ROW ONE COLUMN 
							
							
				SELECT 80000 * 1.25 FROM DUAL;
				
				SELECT 80000 * 1.25;
				
-------- IN OUR SCENARIO, WE NEED TO FETCH THE DATA FROM THE EXISTING TABLES 

			SYSTEM ALLOWS TO EXECUTE AIRTHMETIC OPERATION ON THE COLUMNS AS WELL 
			
		LIKE :
				
				NEED TO CHECK THE SALARY AND HIKE SALARY BY 25% TO ALL EMPLOYEES.
				
				
			SELECT 
				COLUMN (PERFORM AIRTHMETIC OPERATION) 
					FROM TABLE;
					
			** DATA COMES IN THE TEMP MEMORY
			** PERFORM THE AIRTHMETIC OPERATION 
			** WHAT EVER THE OUTPUT THROWS ON THE CLIENT MACHINE 
			** TEMP MEM RELEASE 
			
			***** WE ARE NOT UPDATING ANYTHING IN THE EXISTING TABLES 
				
		SELECT 
			EMPLOYEE_ID,FIRST_NAME, LAST_NAME,SALARY,
				SALARY * 1.25 
				FROM 
					EMPLOYEES;
					
		** 
			* COLUMNS EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY 
			COMES IN THE TEMP MEMORY 
			* NOW IT CREATES TEMP TABLE BASED ON THE COLUMNS REQUIRED IN THE OUTPUT 
			
		EMPLOYEE_ID FIRST_NAME LAST_NAME SALARY SALARY * 1.25
		102			RAHUL		BANSAL		8000	10000
		
		** NEWLY ITRODUCE COLUMN ONLY FOR MY OUTPUT 
			NOT FOR THE TABLE 
				
				THESE COLUMNS WHICH ARE NEWLY INTRODUCE AND NOT THE PART OF THE TABLE 
					ARE CALLED PSUEDO COLUMNS 
					
------------ 
		FOR MODIFYING THE NAME OF THE COLUMNS BASED ON THE OUTPUT REQUIRED 
			SYSTEM PROVIDED A CONCEPT OF 
				ALIAS
				
				ALIAS : ANOTHER NAME OF THE COLUMNS
				
		SELECT 
			EMPLOYEE_ID EMPNO,FIRST_NAME FIRSTNAME, LAST_NAME LASTNAME,SALARY EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
-----------------
		STANDARDS 
			AS A KEY WORD TO DEFINE ALIAS
			
			SELECT 
			EMPLOYEE_ID AS EMPNO,FIRST_NAME AS FIRSTNAME, LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
---------------- YOU NEED TO HAVE MORE THEN ONE WORD 

		SELECT 
			EMPLOYEE_ID AS "EMP NO",FIRST_NAME AS "FIRST NAME", LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
				SALARY * 1.25 HIKESAALRY 
				FROM 
					EMPLOYEES;
				
-----------------------------------------------------------------

	NEED TO FIND ALL EMPLOYEES 
		WITH SALARY + COMMISION FROM THE ORGANIZATION 

		SELECT 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
				SALARY AS OLDSALARY,COMMISSION_PCT AS COMM, 
					SALARY + COMMISSION_PCT AS SALCOM
						FROM EMPLOYEES 
							WHERE DEPARTMENT_ID = 20;
			
			
		** HANDLE NULL 
				INTRODUCE THE FUNCTION 
				IFNULL(FIRST PARAMETER, SECOND PARAMETER) 
				
				1ST PARAMETER : COLUMN NAME 
					IF 1ST PARAMETER IS NULL 
						RETURN 2ND PARAMETER VALUE 
					ELSE 
						RETURN 1ST PARAMETER 
					END IF 
					
				IFNULL(COMMISSION_PCT,0);

						COMMISSION_PCT IS NULL 
							RETURN 0 
						ELSE 
							RETUEN COMMISSION_PCT
							
					
		NOW 

			SELECT 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
				SALARY AS OLDSALARY,COMMISSION_PCT AS COMM, 
					SALARY + IFNULL(COMMISSION_PCT,0) AS SALCOM
						FROM EMPLOYEES 
							WHERE DEPARTMENT_ID = 20;
			
			** 
				COLUMNS 
			EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY,COMMISSION_PCT
					COMES IN THE TEMP MEMORY 
					
			2) CREATE NEW TABLE 
		EMPLOYEE_ID, FIRST_NAME,LAST_NAME,SALARY,COMM,SALCOM
			102			RAHUL;	BANSAL		8000 NULL	8000


---------------------------------------------------------

		TREATMENT TO NULL 
			
				* OPERATOR IS 
				* FUNCTION IFNULL 
				
		FIND ALL THE EMPLOYEES WHOSE COMISSION_PCT IS NOT NULL 
		
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE COMMISSION_PCT IS NULL ;
					
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE COMMISSION_PCT IS NOT NULL ;
		
		
		IS NOT : NEGATE THE FETURE OF IS 
		
=============================================================

OPERTORS :- 

			MANY OPERATORS ON THE TOP 
				OF RATIONAL, LOGICAL AND AIRTHMETIC 
				
		
		NEED TO COMPARE WITH MULTIPLE VALUES WITH THE SAME COLUMN  
		
			** NEED ALL EMPLOYEES BELONGS TO 
				DEPARTMENT 20 AND 30 
				
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							DEPARTMENT_ID = 20 
								OR 
									DEPARTMENT_ID = 30;
									
			MULTIPLE VALUE COMPARISON WITH COLUMN 
				THEY INTRODUCE ONE OPERATOR CALLED AS 
						IN
						
			IN :: 
				WHICH COMPARE A SET OF VALUES WITH THE SINGLE COLUMN 
					MAINTANING OR OPERATOR DURING COMPARISON
					
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							DEPARTMENT_ID IN (20,30);
							
			
			** NEED ALL THE EMPLOYEES WHOSE FIRST_NAME 
				IS PAT 
					OR JOHN
					
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							FIRST_NAME IN ('PAT','JOHN');
							
		*****
			MYSQL IS CASE INCENSTIVE 
				MEANS 
					KEYWORDS AND DATA ALSO DURING COMPARION 
						IS CASE INCENSTIVE
							
							
		*****
			PARALLY 
				IN ORACLE 
					KEY WORDS ARE CASE INCENSTIVE 
					DATA IS CASE SENSTIVE
							
		ORACLE QUERY 
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							FIRST_NAME IN ('PAT','JOHN');
							
				Pat , John 
			* empty set 	
							
		** make sure 
			while comparision with string value 
				always remove the case senstivity from the left side and right side of the operator 
			
				PAT = pat
					pat = pat
					PAT  = PAT 
					
			introduce function 
				upper  : used to convert the string in upper case 
				lower  : used to convert the string in lower case 
				
				Select upper('Rahul');
							
		SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							UPPER(FIRST_NAME) in ('PAT','JOHN');					
							
		ALL THE EMPLOYEES 
			WHOSE NAME IS NOT PAT OR JOHN 
			
			
		IN , NOT IN 
			NEGATION OF IN 
			
			
		IS, IS NOT	
							
		SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							UPPER(FIRST_NAME) NOT IN ('PAT','JOHN');					
					
----------------------------------------------------------------------

** 
	COMPARE A COLUMN WITH A VALUE WHICH IS PARTIALLY KNOW 
		
			ONLY AWARE THAT A PARTIAL STRING 
			
		LIKE 
			NEED TO FIND ALL THE EMPLOYEES STARTING WITH A LETTER 
			NEED TO FIND ALL THE EMPLOYEES CONTAINS AS IN THE FIRST NAME 
			NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME ENDING WITH L 
			
			INTRODUCE 
				
					OPERATOR 
						LIKE : SIMILAR TO 
						
						LIKE COMES WITH TWO WILDCARDS 
						
							%  : N NUMBER OF CHARACTERS AND NO CHARACTER
							_  : 1 CHARATERS
							
	** 
		NEED TO FIND ALL THE EMPLOYEES STARTING WITH A LETTER
		
		
		SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE 'A%';
					
					
	** 
		NEED TO FIND ALL THE EMPLOYEES CONTAINS AS IN THE FIRST NAME 
					
			SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE '%AS%'		
					
	**
		NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME ENDING WITH L 
		
		SELECT 
			*
			FROM 
				EMPLOYEES 
					WHERE FIRST_NAME LIKE '%L'
					
	** 
		NEED TO FIND ALL THE EMPLOYEES WHOSE FIRST NAME CONTAIND G AT 3 POSITION 
		
		SELECT 
			* 
			 FROM 
				EMPLOYEES 
					WHERE 
						FIRST_NAME LIKE '__G%';
			
									
	** 
		NEED TO FIND ALL THE EMPLOYEES 
			WHOSE FIRST NAME EITHER START FROM A OR J 
			
			BUT CASE IS 
				* PARTIAL VALUES TO SEARCH 
				* MULTIPLE VALUES WITH SAME COLUMN 
				
				LIKE AND IN OPERATOR 
				SYSTEM DOESN'T ALLOW TO HAVE TWO OPERATOR TOGEATHER 
				
		SELECT 
			* 
			 FROM 
				EMPLOYEES 
					WHERE 
						FIRST_NAME LIKE 'A%' 
							OR 
						FIRST_NAME LIKE 'J%'; 
				
-----------------------------------------------------------------				
CHECK CONSTRAINT 
					PUT A RESTRICTION 
						DATE COLUMN SHOULD NOT CONTAIN 
							VALUE 
								(__/__/__)
					
CHECK(HIREDATE LIKE (__/__/__));

--------------------------------------------------------------------------

** 
	DQL 
		SELECT ----------MANDATORY 
			* 
			FROM ----------MANDATORY 
				TABLENAME 
					WHERE ----------NOT MANDAOTRY					
						CONDITION 
							;

-----WHEN WE TALK ABOUT THE STORAGE OF THE DATA IN THE DATABASE 
						IS IN DISTRIBUTED WAY
			SORTING OPERATION ON THE OUTPUT 
			
			
	NEED ALL THE EMPLOYEES SALARY BELONGS TO DEPARTMENT 80 
		AND SORT SALARY IN ASSENDING ORDER 
			ASSENDING 
			 > SMALL TO BIG 
	
	CLAUSE 
		ORDER BY : 
			TWO KEY WORDS 
				ASC  : ASCENDING ORDER
				DESC : DESENDING ORDER
		* BY DEFAULT 
				ITS NATURE IS ASC ORDER 
			
		
		* ALL EMPLOYEES WITH ALL COLUMNS 
		* BELONGS TO DEPARTMENT 80
		* ORDER BY SALARY 
		ASC 
		
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							ORDER BY SALARY;
							
		* ORDER BY 
			ORDER BY MUST BE LAST CLAUSE OF THE SELECT QUERY 
			ORDER BY ALLOWS TO USE ALIAS FOR SORTING 
			
		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						DEPARTMENT_ID = 80 
							ORDER BY SALARY DESC;
							
---------------------------------------------
THERE MAY BE A CASE WHERE I WANT SORTING ON MULTIPLE COLUMN 
								
				* LOGICALLY SORTING ON MULTIPLE COLUMN IN THE SAME OUTPUT IS NOT POSSIBLE 
				
SYSTEM ALLOWS ME TO PUT TWO COLUMN SEPERATED WITH COMMA IN THE ORDER BY CLAUSE 

		SELECT 
			* FROM 
				EMPLOYEES 
					ORDER BY DEPARTMENT_ID,SALARY;
					
		SELECT 
			* FROM 
				EMPLOYEES 
					ORDER BY DEPARTMENT_ID ASC,SALARY DESC;			
					
		SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40) ORDER BY DEPARTMENT_ID DESC,SALARY DESC;			
					
----------------------------------------------------------------------

	(1) SELECT ------MANDATORY 
		* 
		(2) FROM  ------MANDATORY 
			TABLENAME
				(3) WHERE  ------ NOT MANDATORY 
					CONDITION 
						(4) ORDER BY ------ NOT MANDATORY 
							COLUMNS
					
	---------------------------------------------------------------

	FEW ADDITIONAL CONCEPT INTRODUCED 
		* SUPRESS DUPLICATE 
			
			WANT ALL THE DEPARTMENT WHERE EMPLOYEES WORKING 
				FIND ALL THE DEPARTMENT MINIMUM HAS ONE EMPLOYEE 
				
		SELECT DEPARTMENT_ID FROM EMPLOYEES;

			SUPRESS THE DUPLICATE 
					DISTINCT 
		SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;			

	** 
		SELECT DISTINCT DEPARTMENT_ID, SALARY FROM EMPLOYEES;
		
			* DISTINCT ALWAYS COMES AFTER SELECT AND BEFORE COLUMN NAME 
			* SUPRESS DATA BASED ON THE COLUMN PROVIDED AFTER DISTINCT 
			* COMBINATION OF THE COLUMN BE SUPRESSED 
			
	SIMILARLY 
			LIMIT 
				: A KEYWORD USED TO LIMIT THE OUTPUT 
			
			LIMIT : LIMIT 1 
				MEANS RETURN ONLY SINGLE RECORD
				
				LIMIT 20 
				
			ORACLE HAS SIMILAR FETAURE 
				ROWNUM 
	
EXAMPLE 
		MYSQL 
			
			SELECT * FROM EMPLOYEES LIMIT 10;
				
		ORACLE 
		
			SELECT * FROM EMPLOYEES WHERE ROWNUM < 10;
					OR
			SELECT * FROM EMPLOYEES WHERE ROWNUM = 1;

		MULTI PARAMTER LIMIT 
				
				LIMIT 2,3
					FIRST PARAMETER  : STARTS FROM WHICH ROW 
					SECOND PARAMETER  : COUNT 

					
				SELECT * FROM EMPLOYEES LIMIT 4,4;

---------------------------------------------------------------------------

mysql> SELECT * FROM EMPINSERT;
+------+---------+------+--------+
| ID   | NAME    | DOB  | SALARY |
+------+---------+------+--------+
|  104 | SUNITA  | NULL |   9000 |
|  105 | SHIPA   | NULL |  50000 |
|  106 | KRISHAN | NULL |   8444 |
+------+---------+------+--------+
3 rows in set (0.00 sec)

mysql> DELETE FROM EMPINSERT;
Query OK, 3 rows affected (0.00 sec)

mysql> SELECT * FROM EMPISERT;
ERROR 1146 (42S02): Table 'dacstudent.empisert' doesn't exist
mysql> SELECT * FROM EMPINSERT;
Empty set (0.00 sec)

mysql> ROLLBACK;
Query OK, 0 rows affected (0.01 sec)

mysql> SELECT * FROM EMPINSERT;
+------+---------+------+--------+
| ID   | NAME    | DOB  | SALARY |
+------+---------+------+--------+
|  104 | SUNITA  | NULL |   9000 |
|  105 | SHIPA   | NULL |  50000 |
|  106 | KRISHAN | NULL |   8444 |
+------+---------+------+--------+
3 rows in set (0.00 sec)

mysql> UPDATE EMPINSERT SET SALARY = NULL WHERE SALARY = 9000;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM EMPINSERT;
+------+---------+------+--------+
| ID   | NAME    | DOB  | SALARY |
+------+---------+------+--------+
|  104 | SUNITA  | NULL |   NULL |
|  105 | SHIPA   | NULL |  50000 |
|  106 | KRISHAN | NULL |   8444 |
+------+---------+------+--------+
3 rows in set (0.00 sec)

mysql> TRUNCATE TABLE EMPINSERT;
Query OK, 0 rows affected (0.14 sec)

mysql> SELECT * FROM EMPINSERT;
Empty set (0.01 sec)

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| dacaug             |
| dacstudent         |
| hrdatabase         |
| hrschema           |
| humandatabase      |
| humanresource12    |
| information_schema |
| mysql              |
| newdatabase        |
| performance_schema |
| rahultest          |
| students           |
| sys                |
+--------------------+
13 rows in set (0.04 sec)

mysql> USE humanresource12;
Database changed
mysql> SHOW TABLESL
    -> ;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'TABLESL' at line 1
mysql> SHOW TABLES;
+---------------------------+
| Tables_in_humanresource12 |
+---------------------------+
| countries                 |
| departments               |
| emp_details_view          |
| employees                 |
| job_history               |
| jobs                      |
| locations                 |
| regions                   |
+---------------------------+
8 rows in set (0.02 sec)

mysql> SEELCT * FROM employees;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'SEELCT * FROM employees' at line 1
mysql> SELECT * FROM employees;
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name   | email    | phone_number       | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
|         100 | Steven      | King        | SKING    | 515.123.4567       | 1987-06-17 | AD_PRES    | 24000.00 |           NULL |       NULL |            90 |
|         101 | Neena       | Kochhar     | NKOCHHAR | 515.123.4568       | 1989-09-21 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         102 | Lex         | De Haan     | LDEHAAN  | 515.123.4569       | 1993-01-13 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         103 | Alexander   | Hunold      | AHUNOLD  | 590.423.4567       | 1990-01-03 | IT_PROG    |  9000.00 |           NULL |        102 |            60 |
|         104 | Bruce       | Ernst       | BERNST   | 590.423.4568       | 1991-05-21 | IT_PROG    |  6000.00 |           NULL |        103 |            60 |
|         105 | David       | Austin      | DAUSTIN  | 590.423.4569       | 1997-06-25 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         106 | Valli       | Pataballa   | VPATABAL | 590.423.4560       | 1998-02-05 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         107 | Diana       | Lorentz     | DLORENTZ | 590.423.5567       | 1999-02-07 | IT_PROG    |  4200.00 |           NULL |        103 |            60 |
|         108 | Nancy       | Greenberg   | NGREENBE | 515.124.4569       | 1994-08-17 | FI_MGR     | 12000.00 |           NULL |        101 |           100 |
|         109 | Daniel      | Faviet      | DFAVIET  | 515.124.4169       | 1994-08-16 | FI_ACCOUNT |  9000.00 |           NULL |        108 |           100 |
|         110 | John        | Chen        | JCHEN    | 515.124.4269       | 1997-09-28 | FI_ACCOUNT |  8200.00 |           NULL |        108 |           100 |
|         111 | Ismael      | Sciarra     | ISCIARRA | 515.124.4369       | 1997-09-30 | FI_ACCOUNT |  7700.00 |           NULL |        108 |           100 |
|         112 | Jose Manuel | Urman       | JMURMAN  | 515.124.4469       | 1998-03-07 | FI_ACCOUNT |  7800.00 |           NULL |        108 |           100 |
|         113 | Luis        | Popp        | LPOPP    | 515.124.4567       | 1999-12-07 | FI_ACCOUNT |  6900.00 |           NULL |        108 |           100 |
|         114 | Den         | Raphaely    | DRAPHEAL | 515.127.4561       | 1994-12-07 | PU_MAN     | 11000.00 |           NULL |        100 |            30 |
|         115 | Alexander   | Khoo        | AKHOO    | 515.127.4562       | 1995-05-18 | PU_CLERK   |  3100.00 |           NULL |        114 |            30 |
|         116 | Shelli      | Baida       | SBAIDA   | 515.127.4563       | 1997-12-24 | PU_CLERK   |  2900.00 |           NULL |        114 |            30 |
|         117 | Sigal       | Tobias      | STOBIAS  | 515.127.4564       | 1997-07-24 | PU_CLERK   |  2800.00 |           NULL |        114 |            30 |
|         118 | Guy         | Himuro      | GHIMURO  | 515.127.4565       | 1998-11-15 | PU_CLERK   |  2600.00 |           NULL |        114 |            30 |
|         119 | Karen       | Colmenares  | KCOLMENA | 515.127.4566       | 1999-08-10 | PU_CLERK   |  2500.00 |           NULL |        114 |            30 |
|         120 | Matthew     | Weiss       | MWEISS   | 650.123.1234       | 1996-07-18 | ST_MAN     |  8000.00 |           NULL |        100 |            50 |
|         121 | Adam        | Fripp       | AFRIPP   | 650.123.2234       | 1997-04-10 | ST_MAN     |  8200.00 |           NULL |        100 |            50 |
|         122 | Payam       | Kaufling    | PKAUFLIN | 650.123.3234       | 1995-05-01 | ST_MAN     |  7900.00 |           NULL |        100 |            50 |
|         123 | Shanta      | Vollman     | SVOLLMAN | 650.123.4234       | 1997-10-10 | ST_MAN     |  6500.00 |           NULL |        100 |            50 |
|         124 | Kevin       | Mourgos     | KMOURGOS | 650.123.5234       | 1999-11-16 | ST_MAN     |  5800.00 |           NULL |        100 |            50 |
|         125 | Julia       | Nayer       | JNAYER   | 650.124.1214       | 1997-07-16 | ST_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         126 | Irene       | Mikkilineni | IMIKKILI | 650.124.1224       | 1998-09-28 | ST_CLERK   |  2700.00 |           NULL |        120 |            50 |
|         127 | James       | Landry      | JLANDRY  | 650.124.1334       | 1999-01-14 | ST_CLERK   |  2400.00 |           NULL |        120 |            50 |
|         128 | Steven      | Markle      | SMARKLE  | 650.124.1434       | 2000-03-08 | ST_CLERK   |  2200.00 |           NULL |        120 |            50 |
|         129 | Laura       | Bissot      | LBISSOT  | 650.124.5234       | 1997-08-20 | ST_CLERK   |  3300.00 |           NULL |        121 |            50 |
|         130 | Mozhe       | Atkinson    | MATKINSO | 650.124.6234       | 1997-10-30 | ST_CLERK   |  2800.00 |           NULL |        121 |            50 |
|         131 | James       | Marlow      | JAMRLOW  | 650.124.7234       | 1997-02-16 | ST_CLERK   |  2500.00 |           NULL |        121 |            50 |
|         132 | TJ          | Olson       | TJOLSON  | 650.124.8234       | 1999-04-10 | ST_CLERK   |  2100.00 |           NULL |        121 |            50 |
|         133 | Jason       | Mallin      | JMALLIN  | 650.127.1934       | 1996-06-14 | ST_CLERK   |  3300.00 |           NULL |        122 |            50 |
|         134 | Michael     | Rogers      | MROGERS  | 650.127.1834       | 1998-08-26 | ST_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         135 | Ki          | Gee         | KGEE     | 650.127.1734       | 1999-12-12 | ST_CLERK   |  2400.00 |           NULL |        122 |            50 |
|         136 | Hazel       | Philtanker  | HPHILTAN | 650.127.1634       | 2000-02-06 | ST_CLERK   |  2200.00 |           NULL |        122 |            50 |
|         137 | Renske      | Ladwig      | RLADWIG  | 650.121.1234       | 1995-07-14 | ST_CLERK   |  3600.00 |           NULL |        123 |            50 |
|         138 | Stephen     | Stiles      | SSTILES  | 650.121.2034       | 1997-10-26 | ST_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         139 | John        | Seo         | JSEO     | 650.121.2019       | 1998-02-12 | ST_CLERK   |  2700.00 |           NULL |        123 |            50 |
|         140 | Joshua      | Patel       | JPATEL   | 650.121.1834       | 1998-04-06 | ST_CLERK   |  2500.00 |           NULL |        123 |            50 |
|         141 | Trenna      | Rajs        | TRAJS    | 650.121.8009       | 1995-10-17 | ST_CLERK   |  3500.00 |           NULL |        124 |            50 |
|         142 | Curtis      | Davies      | CDAVIES  | 650.121.2994       | 1997-01-29 | ST_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         143 | Randall     | Matos       | RMATOS   | 650.121.2874       | 1998-03-15 | ST_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         144 | Peter       | Vargas      | PVARGAS  | 650.121.2004       | 1998-07-09 | ST_CLERK   |  2500.00 |           NULL |        124 |            50 |
|         145 | John        | Russell     | JRUSSEL  | 011.44.1344.429268 | 1996-10-01 | SA_MAN     | 14000.00 |           0.40 |        100 |            80 |
|         146 | Karen       | Partners    | KPARTNER | 011.44.1344.467268 | 1997-01-05 | SA_MAN     | 13500.00 |           0.30 |        100 |            80 |
|         147 | Alberto     | Errazuriz   | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN     | 12000.00 |           0.30 |        100 |            80 |
|         148 | Gerald      | Cambrault   | GCAMBRAU | 011.44.1344.619268 | 1999-10-15 | SA_MAN     | 11000.00 |           0.30 |        100 |            80 |
|         149 | Eleni       | Zlotkey     | EZLOTKEY | 011.44.1344.429018 | 2000-01-29 | SA_MAN     | 10500.00 |           0.20 |        100 |            80 |
|         150 | Peter       | Tucker      | PTUCKER  | 011.44.1344.129268 | 1997-01-30 | SA_REP     | 10000.00 |           0.30 |        145 |            80 |
|         151 | David       | Bernstein   | DBERNSTE | 011.44.1344.345268 | 1997-03-24 | SA_REP     |  9500.00 |           0.25 |        145 |            80 |
|         152 | Peter       | Hall        | PHALL    | 011.44.1344.478968 | 1997-08-20 | SA_REP     |  9000.00 |           0.25 |        145 |            80 |
|         153 | Christopher | Olsen       | COLSEN   | 011.44.1344.498718 | 1998-03-30 | SA_REP     |  8000.00 |           0.20 |        145 |            80 |
|         154 | Nanette     | Cambrault   | NCAMBRAU | 011.44.1344.987668 | 1998-12-09 | SA_REP     |  7500.00 |           0.20 |        145 |            80 |
|         155 | Oliver      | Tuvault     | OTUVAULT | 011.44.1344.486508 | 1999-11-23 | SA_REP     |  7000.00 |           0.15 |        145 |            80 |
|         156 | Janette     | King        | JKING    | 011.44.1345.429268 | 1996-01-30 | SA_REP     | 10000.00 |           0.35 |        146 |            80 |
|         157 | Patrick     | Sully       | PSULLY   | 011.44.1345.929268 | 1996-03-04 | SA_REP     |  9500.00 |           0.35 |        146 |            80 |
|         158 | Allan       | McEwen      | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP     |  9000.00 |           0.35 |        146 |            80 |
|         159 | Lindsey     | Smith       | LSMITH   | 011.44.1345.729268 | 1997-03-10 | SA_REP     |  8000.00 |           0.30 |        146 |            80 |
|         160 | Louise      | Doran       | LDORAN   | 011.44.1345.629268 | 1997-12-15 | SA_REP     |  7500.00 |           0.30 |        146 |            80 |
|         161 | Sarath      | Sewall      | SSEWALL  | 011.44.1345.529268 | 1998-11-03 | SA_REP     |  7000.00 |           0.25 |        146 |            80 |
|         162 | Clara       | Vishney     | CVISHNEY | 011.44.1346.129268 | 1997-11-11 | SA_REP     | 10500.00 |           0.25 |        147 |            80 |
|         163 | Danielle    | Greene      | DGREENE  | 011.44.1346.229268 | 1999-03-19 | SA_REP     |  9500.00 |           0.15 |        147 |            80 |
|         164 | Mattea      | Marvins     | MMARVINS | 011.44.1346.329268 | 2000-01-24 | SA_REP     |  7200.00 |           0.10 |        147 |            80 |
|         165 | David       | Lee         | DLEE     | 011.44.1346.529268 | 2000-02-23 | SA_REP     |  6800.00 |           0.10 |        147 |            80 |
|         166 | Sundar      | Ande        | SANDE    | 011.44.1346.629268 | 2000-03-24 | SA_REP     |  6400.00 |           0.10 |        147 |            80 |
|         167 | Amit        | Banda       | ABANDA   | 011.44.1346.729268 | 2000-04-21 | SA_REP     |  6200.00 |           0.10 |        147 |            80 |
|         168 | Lisa        | Ozer        | LOZER    | 011.44.1343.929268 | 1997-03-11 | SA_REP     | 11500.00 |           0.25 |        148 |            80 |
|         169 | Harrison    | Bloom       | HBLOOM   | 011.44.1343.829268 | 1998-03-23 | SA_REP     | 10000.00 |           0.20 |        148 |            80 |
|         170 | Tayler      | Fox         | TFOX     | 011.44.1343.729268 | 1998-01-24 | SA_REP     |  9600.00 |           0.20 |        148 |            80 |
|         171 | William     | Smith       | WSMITH   | 011.44.1343.629268 | 1999-02-23 | SA_REP     |  7400.00 |           0.15 |        148 |            80 |
|         172 | Elizabeth   | Bates       | EBATES   | 011.44.1343.529268 | 1999-03-24 | SA_REP     |  7300.00 |           0.15 |        148 |            80 |
|         173 | Sundita     | Kumar       | SKUMAR   | 011.44.1343.329268 | 2000-04-21 | SA_REP     |  6100.00 |           0.10 |        148 |            80 |
|         174 | Ellen       | Abel        | EABEL    | 011.44.1644.429267 | 1996-05-11 | SA_REP     | 11000.00 |           0.30 |        149 |            80 |
|         175 | Alyssa      | Hutton      | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP     |  8800.00 |           0.25 |        149 |            80 |
|         176 | Jonathon    | Taylor      | JTAYLOR  | 011.44.1644.429265 | 1998-03-24 | SA_REP     |  8600.00 |           0.20 |        149 |            80 |
|         177 | Jack        | Livingston  | JLIVINGS | 011.44.1644.429264 | 1998-04-23 | SA_REP     |  8400.00 |           0.20 |        149 |            80 |
|         178 | Kimberely   | Grant       | KGRANT   | 011.44.1644.429263 | 1999-05-24 | SA_REP     |  7000.00 |           0.15 |        149 |          NULL |
|         179 | Charles     | Johnson     | CJOHNSON | 011.44.1644.429262 | 2000-01-04 | SA_REP     |  6200.00 |           0.10 |        149 |            80 |
|         180 | Winston     | Taylor      | WTAYLOR  | 650.507.9876       | 1998-01-24 | SH_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         181 | Jean        | Fleaur      | JFLEAUR  | 650.507.9877       | 1998-02-23 | SH_CLERK   |  3100.00 |           NULL |        120 |            50 |
|         182 | Martha      | Sullivan    | MSULLIVA | 650.507.9878       | 1999-06-21 | SH_CLERK   |  2500.00 |           NULL |        120 |            50 |
|         183 | Girard      | Geoni       | GGEONI   | 650.507.9879       | 2000-02-03 | SH_CLERK   |  2800.00 |           NULL |        120 |            50 |
|         184 | Nandita     | Sarchand    | NSARCHAN | 650.509.1876       | 1996-01-27 | SH_CLERK   |  4200.00 |           NULL |        121 |            50 |
|         185 | Alexis      | Bull        | ABULL    | 650.509.2876       | 1997-02-20 | SH_CLERK   |  4100.00 |           NULL |        121 |            50 |
|         186 | Julia       | Dellinger   | JDELLING | 650.509.3876       | 1998-06-24 | SH_CLERK   |  3400.00 |           NULL |        121 |            50 |
|         187 | Anthony     | Cabrio      | ACABRIO  | 650.509.4876       | 1999-02-07 | SH_CLERK   |  3000.00 |           NULL |        121 |            50 |
|         188 | Kelly       | Chung       | KCHUNG   | 650.505.1876       | 1997-06-14 | SH_CLERK   |  3800.00 |           NULL |        122 |            50 |
|         189 | Jennifer    | Dilly       | JDILLY   | 650.505.2876       | 1997-08-13 | SH_CLERK   |  3600.00 |           NULL |        122 |            50 |
|         190 | Timothy     | Gates       | TGATES   | 650.505.3876       | 1998-07-11 | SH_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         191 | Randall     | Perkins     | RPERKINS | 650.505.4876       | 1999-12-19 | SH_CLERK   |  2500.00 |           NULL |        122 |            50 |
|         192 | Sarah       | Bell        | SBELL    | 650.501.1876       | 1996-02-04 | SH_CLERK   |  4000.00 |           NULL |        123 |            50 |
|         193 | Britney     | Everett     | BEVERETT | 650.501.2876       | 1997-03-03 | SH_CLERK   |  3900.00 |           NULL |        123 |            50 |
|         194 | Samuel      | McCain      | SMCCAIN  | 650.501.3876       | 1998-07-01 | SH_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         195 | Vance       | Jones       | VJONES   | 650.501.4876       | 1999-03-17 | SH_CLERK   |  2800.00 |           NULL |        123 |            50 |
|         196 | Alana       | Walsh       | AWALSH   | 650.507.9811       | 1998-04-24 | SH_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         197 | Kevin       | Feeney      | KFEENEY  | 650.507.9822       | 1998-05-23 | SH_CLERK   |  3000.00 |           NULL |        124 |            50 |
|         198 | Donald      | OConnell    | DOCONNEL | 650.507.9833       | 1999-06-21 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         199 | Douglas     | Grant       | DGRANT   | 650.507.9844       | 2000-01-13 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         200 | Jennifer    | Whalen      | JWHALEN  | 515.123.4444       | 1987-09-17 | AD_ASST    |  4400.00 |           NULL |        101 |            10 |
|         201 | Michael     | Hartstein   | MHARTSTE | 515.123.5555       | 1996-02-17 | MK_MAN     | 13000.00 |           NULL |        100 |            20 |
|         202 | Pat         | Fay         | PFAY     | 603.123.6666       | 1997-08-17 | MK_REP     |  6000.00 |           NULL |        201 |            20 |
|         203 | Susan       | Mavris      | SMAVRIS  | 515.123.7777       | 1994-06-07 | HR_REP     |  6500.00 |           NULL |        101 |            40 |
|         204 | Hermann     | Baer        | HBAER    | 515.123.8888       | 1994-06-07 | PR_REP     | 10000.00 |           NULL |        101 |            70 |
|         205 | Shelley     | Higgins     | SHIGGINS | 515.123.8080       | 1994-06-07 | AC_MGR     | 12000.00 |           NULL |        101 |           110 |
|         206 | William     | Gietz       | WGIETZ   | 51hr5.123.8181     | 1994-06-07 | AC_ACCOUNT |  8300.00 |           NULL |        205 |           110 |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
107 rows in set (0.07 sec)

mysql> SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY
    -> FROM EMPLOYEES;
+-------------+-------------+-------------+----------+
| EMPLOYEE_ID | FIRST_NAME  | LAST_NAME   | SALARY   |
+-------------+-------------+-------------+----------+
|         100 | Steven      | King        | 24000.00 |
|         101 | Neena       | Kochhar     | 17000.00 |
|         102 | Lex         | De Haan     | 17000.00 |
|         103 | Alexander   | Hunold      |  9000.00 |
|         104 | Bruce       | Ernst       |  6000.00 |
|         105 | David       | Austin      |  4800.00 |
|         106 | Valli       | Pataballa   |  4800.00 |
|         107 | Diana       | Lorentz     |  4200.00 |
|         108 | Nancy       | Greenberg   | 12000.00 |
|         109 | Daniel      | Faviet      |  9000.00 |
|         110 | John        | Chen        |  8200.00 |
|         111 | Ismael      | Sciarra     |  7700.00 |
|         112 | Jose Manuel | Urman       |  7800.00 |
|         113 | Luis        | Popp        |  6900.00 |
|         114 | Den         | Raphaely    | 11000.00 |
|         115 | Alexander   | Khoo        |  3100.00 |
|         116 | Shelli      | Baida       |  2900.00 |
|         117 | Sigal       | Tobias      |  2800.00 |
|         118 | Guy         | Himuro      |  2600.00 |
|         119 | Karen       | Colmenares  |  2500.00 |
|         120 | Matthew     | Weiss       |  8000.00 |
|         121 | Adam        | Fripp       |  8200.00 |
|         122 | Payam       | Kaufling    |  7900.00 |
|         123 | Shanta      | Vollman     |  6500.00 |
|         124 | Kevin       | Mourgos     |  5800.00 |
|         125 | Julia       | Nayer       |  3200.00 |
|         126 | Irene       | Mikkilineni |  2700.00 |
|         127 | James       | Landry      |  2400.00 |
|         128 | Steven      | Markle      |  2200.00 |
|         129 | Laura       | Bissot      |  3300.00 |
|         130 | Mozhe       | Atkinson    |  2800.00 |
|         131 | James       | Marlow      |  2500.00 |
|         132 | TJ          | Olson       |  2100.00 |
|         133 | Jason       | Mallin      |  3300.00 |
|         134 | Michael     | Rogers      |  2900.00 |
|         135 | Ki          | Gee         |  2400.00 |
|         136 | Hazel       | Philtanker  |  2200.00 |
|         137 | Renske      | Ladwig      |  3600.00 |
|         138 | Stephen     | Stiles      |  3200.00 |
|         139 | John        | Seo         |  2700.00 |
|         140 | Joshua      | Patel       |  2500.00 |
|         141 | Trenna      | Rajs        |  3500.00 |
|         142 | Curtis      | Davies      |  3100.00 |
|         143 | Randall     | Matos       |  2600.00 |
|         144 | Peter       | Vargas      |  2500.00 |
|         145 | John        | Russell     | 14000.00 |
|         146 | Karen       | Partners    | 13500.00 |
|         147 | Alberto     | Errazuriz   | 12000.00 |
|         148 | Gerald      | Cambrault   | 11000.00 |
|         149 | Eleni       | Zlotkey     | 10500.00 |
|         150 | Peter       | Tucker      | 10000.00 |
|         151 | David       | Bernstein   |  9500.00 |
|         152 | Peter       | Hall        |  9000.00 |
|         153 | Christopher | Olsen       |  8000.00 |
|         154 | Nanette     | Cambrault   |  7500.00 |
|         155 | Oliver      | Tuvault     |  7000.00 |
|         156 | Janette     | King        | 10000.00 |
|         157 | Patrick     | Sully       |  9500.00 |
|         158 | Allan       | McEwen      |  9000.00 |
|         159 | Lindsey     | Smith       |  8000.00 |
|         160 | Louise      | Doran       |  7500.00 |
|         161 | Sarath      | Sewall      |  7000.00 |
|         162 | Clara       | Vishney     | 10500.00 |
|         163 | Danielle    | Greene      |  9500.00 |
|         164 | Mattea      | Marvins     |  7200.00 |
|         165 | David       | Lee         |  6800.00 |
|         166 | Sundar      | Ande        |  6400.00 |
|         167 | Amit        | Banda       |  6200.00 |
|         168 | Lisa        | Ozer        | 11500.00 |
|         169 | Harrison    | Bloom       | 10000.00 |
|         170 | Tayler      | Fox         |  9600.00 |
|         171 | William     | Smith       |  7400.00 |
|         172 | Elizabeth   | Bates       |  7300.00 |
|         173 | Sundita     | Kumar       |  6100.00 |
|         174 | Ellen       | Abel        | 11000.00 |
|         175 | Alyssa      | Hutton      |  8800.00 |
|         176 | Jonathon    | Taylor      |  8600.00 |
|         177 | Jack        | Livingston  |  8400.00 |
|         178 | Kimberely   | Grant       |  7000.00 |
|         179 | Charles     | Johnson     |  6200.00 |
|         180 | Winston     | Taylor      |  3200.00 |
|         181 | Jean        | Fleaur      |  3100.00 |
|         182 | Martha      | Sullivan    |  2500.00 |
|         183 | Girard      | Geoni       |  2800.00 |
|         184 | Nandita     | Sarchand    |  4200.00 |
|         185 | Alexis      | Bull        |  4100.00 |
|         186 | Julia       | Dellinger   |  3400.00 |
|         187 | Anthony     | Cabrio      |  3000.00 |
|         188 | Kelly       | Chung       |  3800.00 |
|         189 | Jennifer    | Dilly       |  3600.00 |
|         190 | Timothy     | Gates       |  2900.00 |
|         191 | Randall     | Perkins     |  2500.00 |
|         192 | Sarah       | Bell        |  4000.00 |
|         193 | Britney     | Everett     |  3900.00 |
|         194 | Samuel      | McCain      |  3200.00 |
|         195 | Vance       | Jones       |  2800.00 |
|         196 | Alana       | Walsh       |  3100.00 |
|         197 | Kevin       | Feeney      |  3000.00 |
|         198 | Donald      | OConnell    |  2600.00 |
|         199 | Douglas     | Grant       |  2600.00 |
|         200 | Jennifer    | Whalen      |  4400.00 |
|         201 | Michael     | Hartstein   | 13000.00 |
|         202 | Pat         | Fay         |  6000.00 |
|         203 | Susan       | Mavris      |  6500.00 |
|         204 | Hermann     | Baer        | 10000.00 |
|         205 | Shelley     | Higgins     | 12000.00 |
|         206 | William     | Gietz       |  8300.00 |
+-------------+-------------+-------------+----------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> FIRST_NAME,LAST_NAME,SALARY, HIRE_DATE
    -> FROM
    -> EMPLOYEES;SELECT
+-------------+-------------+----------+------------+
| FIRST_NAME  | LAST_NAME   | SALARY   | HIRE_DATE  |
+-------------+-------------+----------+------------+
| Steven      | King        | 24000.00 | 1987-06-17 |
| Neena       | Kochhar     | 17000.00 | 1989-09-21 |
| Lex         | De Haan     | 17000.00 | 1993-01-13 |
| Alexander   | Hunold      |  9000.00 | 1990-01-03 |
| Bruce       | Ernst       |  6000.00 | 1991-05-21 |
| David       | Austin      |  4800.00 | 1997-06-25 |
| Valli       | Pataballa   |  4800.00 | 1998-02-05 |
| Diana       | Lorentz     |  4200.00 | 1999-02-07 |
| Nancy       | Greenberg   | 12000.00 | 1994-08-17 |
| Daniel      | Faviet      |  9000.00 | 1994-08-16 |
| John        | Chen        |  8200.00 | 1997-09-28 |
| Ismael      | Sciarra     |  7700.00 | 1997-09-30 |
| Jose Manuel | Urman       |  7800.00 | 1998-03-07 |
| Luis        | Popp        |  6900.00 | 1999-12-07 |
| Den         | Raphaely    | 11000.00 | 1994-12-07 |
| Alexander   | Khoo        |  3100.00 | 1995-05-18 |
| Shelli      | Baida       |  2900.00 | 1997-12-24 |
| Sigal       | Tobias      |  2800.00 | 1997-07-24 |
| Guy         | Himuro      |  2600.00 | 1998-11-15 |
| Karen       | Colmenares  |  2500.00 | 1999-08-10 |
| Matthew     | Weiss       |  8000.00 | 1996-07-18 |
| Adam        | Fripp       |  8200.00 | 1997-04-10 |
| Payam       | Kaufling    |  7900.00 | 1995-05-01 |
| Shanta      | Vollman     |  6500.00 | 1997-10-10 |
| Kevin       | Mourgos     |  5800.00 | 1999-11-16 |
| Julia       | Nayer       |  3200.00 | 1997-07-16 |
| Irene       | Mikkilineni |  2700.00 | 1998-09-28 |
| James       | Landry      |  2400.00 | 1999-01-14 |
| Steven      | Markle      |  2200.00 | 2000-03-08 |
| Laura       | Bissot      |  3300.00 | 1997-08-20 |
| Mozhe       | Atkinson    |  2800.00 | 1997-10-30 |
| James       | Marlow      |  2500.00 | 1997-02-16 |
| TJ          | Olson       |  2100.00 | 1999-04-10 |
| Jason       | Mallin      |  3300.00 | 1996-06-14 |
| Michael     | Rogers      |  2900.00 | 1998-08-26 |
| Ki          | Gee         |  2400.00 | 1999-12-12 |
| Hazel       | Philtanker  |  2200.00 | 2000-02-06 |
| Renske      | Ladwig      |  3600.00 | 1995-07-14 |
| Stephen     | Stiles      |  3200.00 | 1997-10-26 |
| John        | Seo         |  2700.00 | 1998-02-12 |
| Joshua      | Patel       |  2500.00 | 1998-04-06 |
| Trenna      | Rajs        |  3500.00 | 1995-10-17 |
| Curtis      | Davies      |  3100.00 | 1997-01-29 |
| Randall     | Matos       |  2600.00 | 1998-03-15 |
| Peter       | Vargas      |  2500.00 | 1998-07-09 |
| John        | Russell     | 14000.00 | 1996-10-01 |
| Karen       | Partners    | 13500.00 | 1997-01-05 |
| Alberto     | Errazuriz   | 12000.00 | 1997-03-10 |
| Gerald      | Cambrault   | 11000.00 | 1999-10-15 |
| Eleni       | Zlotkey     | 10500.00 | 2000-01-29 |
| Peter       | Tucker      | 10000.00 | 1997-01-30 |
| David       | Bernstein   |  9500.00 | 1997-03-24 |
| Peter       | Hall        |  9000.00 | 1997-08-20 |
| Christopher | Olsen       |  8000.00 | 1998-03-30 |
| Nanette     | Cambrault   |  7500.00 | 1998-12-09 |
| Oliver      | Tuvault     |  7000.00 | 1999-11-23 |
| Janette     | King        | 10000.00 | 1996-01-30 |
| Patrick     | Sully       |  9500.00 | 1996-03-04 |
| Allan       | McEwen      |  9000.00 | 1996-08-01 |
| Lindsey     | Smith       |  8000.00 | 1997-03-10 |
| Louise      | Doran       |  7500.00 | 1997-12-15 |
| Sarath      | Sewall      |  7000.00 | 1998-11-03 |
| Clara       | Vishney     | 10500.00 | 1997-11-11 |
| Danielle    | Greene      |  9500.00 | 1999-03-19 |
| Mattea      | Marvins     |  7200.00 | 2000-01-24 |
| David       | Lee         |  6800.00 | 2000-02-23 |
| Sundar      | Ande        |  6400.00 | 2000-03-24 |
| Amit        | Banda       |  6200.00 | 2000-04-21 |
| Lisa        | Ozer        | 11500.00 | 1997-03-11 |
| Harrison    | Bloom       | 10000.00 | 1998-03-23 |
| Tayler      | Fox         |  9600.00 | 1998-01-24 |
| William     | Smith       |  7400.00 | 1999-02-23 |
| Elizabeth   | Bates       |  7300.00 | 1999-03-24 |
| Sundita     | Kumar       |  6100.00 | 2000-04-21 |
| Ellen       | Abel        | 11000.00 | 1996-05-11 |
| Alyssa      | Hutton      |  8800.00 | 1997-03-19 |
| Jonathon    | Taylor      |  8600.00 | 1998-03-24 |
| Jack        | Livingston  |  8400.00 | 1998-04-23 |
| Kimberely   | Grant       |  7000.00 | 1999-05-24 |
| Charles     | Johnson     |  6200.00 | 2000-01-04 |
| Winston     | Taylor      |  3200.00 | 1998-01-24 |
| Jean        | Fleaur      |  3100.00 | 1998-02-23 |
| Martha      | Sullivan    |  2500.00 | 1999-06-21 |
| Girard      | Geoni       |  2800.00 | 2000-02-03 |
| Nandita     | Sarchand    |  4200.00 | 1996-01-27 |
| Alexis      | Bull        |  4100.00 | 1997-02-20 |
| Julia       | Dellinger   |  3400.00 | 1998-06-24 |
| Anthony     | Cabrio      |  3000.00 | 1999-02-07 |
| Kelly       | Chung       |  3800.00 | 1997-06-14 |
| Jennifer    | Dilly       |  3600.00 | 1997-08-13 |
| Timothy     | Gates       |  2900.00 | 1998-07-11 |
| Randall     | Perkins     |  2500.00 | 1999-12-19 |
| Sarah       | Bell        |  4000.00 | 1996-02-04 |
| Britney     | Everett     |  3900.00 | 1997-03-03 |
| Samuel      | McCain      |  3200.00 | 1998-07-01 |
| Vance       | Jones       |  2800.00 | 1999-03-17 |
| Alana       | Walsh       |  3100.00 | 1998-04-24 |
| Kevin       | Feeney      |  3000.00 | 1998-05-23 |
| Donald      | OConnell    |  2600.00 | 1999-06-21 |
| Douglas     | Grant       |  2600.00 | 2000-01-13 |
| Jennifer    | Whalen      |  4400.00 | 1987-09-17 |
| Michael     | Hartstein   | 13000.00 | 1996-02-17 |
| Pat         | Fay         |  6000.00 | 1997-08-17 |
| Susan       | Mavris      |  6500.00 | 1994-06-07 |
| Hermann     | Baer        | 10000.00 | 1994-06-07 |
| Shelley     | Higgins     | 12000.00 | 1994-06-07 |
| William     | Gietz       |  8300.00 | 1994-06-07 |
+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

    -> FIRST_NAME,LAST_NAME,SALARY, HIRE_DATE
    -> FROM
    -> EMPLOYEES;
+-------------+-------------+----------+------------+
| FIRST_NAME  | LAST_NAME   | SALARY   | HIRE_DATE  |
+-------------+-------------+----------+------------+
| Steven      | King        | 24000.00 | 1987-06-17 |
| Neena       | Kochhar     | 17000.00 | 1989-09-21 |
| Lex         | De Haan     | 17000.00 | 1993-01-13 |
| Alexander   | Hunold      |  9000.00 | 1990-01-03 |
| Bruce       | Ernst       |  6000.00 | 1991-05-21 |
| David       | Austin      |  4800.00 | 1997-06-25 |
| Valli       | Pataballa   |  4800.00 | 1998-02-05 |
| Diana       | Lorentz     |  4200.00 | 1999-02-07 |
| Nancy       | Greenberg   | 12000.00 | 1994-08-17 |
| Daniel      | Faviet      |  9000.00 | 1994-08-16 |
| John        | Chen        |  8200.00 | 1997-09-28 |
| Ismael      | Sciarra     |  7700.00 | 1997-09-30 |
| Jose Manuel | Urman       |  7800.00 | 1998-03-07 |
| Luis        | Popp        |  6900.00 | 1999-12-07 |
| Den         | Raphaely    | 11000.00 | 1994-12-07 |
| Alexander   | Khoo        |  3100.00 | 1995-05-18 |
| Shelli      | Baida       |  2900.00 | 1997-12-24 |
| Sigal       | Tobias      |  2800.00 | 1997-07-24 |
| Guy         | Himuro      |  2600.00 | 1998-11-15 |
| Karen       | Colmenares  |  2500.00 | 1999-08-10 |
| Matthew     | Weiss       |  8000.00 | 1996-07-18 |
| Adam        | Fripp       |  8200.00 | 1997-04-10 |
| Payam       | Kaufling    |  7900.00 | 1995-05-01 |
| Shanta      | Vollman     |  6500.00 | 1997-10-10 |
| Kevin       | Mourgos     |  5800.00 | 1999-11-16 |
| Julia       | Nayer       |  3200.00 | 1997-07-16 |
| Irene       | Mikkilineni |  2700.00 | 1998-09-28 |
| James       | Landry      |  2400.00 | 1999-01-14 |
| Steven      | Markle      |  2200.00 | 2000-03-08 |
| Laura       | Bissot      |  3300.00 | 1997-08-20 |
| Mozhe       | Atkinson    |  2800.00 | 1997-10-30 |
| James       | Marlow      |  2500.00 | 1997-02-16 |
| TJ          | Olson       |  2100.00 | 1999-04-10 |
| Jason       | Mallin      |  3300.00 | 1996-06-14 |
| Michael     | Rogers      |  2900.00 | 1998-08-26 |
| Ki          | Gee         |  2400.00 | 1999-12-12 |
| Hazel       | Philtanker  |  2200.00 | 2000-02-06 |
| Renske      | Ladwig      |  3600.00 | 1995-07-14 |
| Stephen     | Stiles      |  3200.00 | 1997-10-26 |
| John        | Seo         |  2700.00 | 1998-02-12 |
| Joshua      | Patel       |  2500.00 | 1998-04-06 |
| Trenna      | Rajs        |  3500.00 | 1995-10-17 |
| Curtis      | Davies      |  3100.00 | 1997-01-29 |
| Randall     | Matos       |  2600.00 | 1998-03-15 |
| Peter       | Vargas      |  2500.00 | 1998-07-09 |
| John        | Russell     | 14000.00 | 1996-10-01 |
| Karen       | Partners    | 13500.00 | 1997-01-05 |
| Alberto     | Errazuriz   | 12000.00 | 1997-03-10 |
| Gerald      | Cambrault   | 11000.00 | 1999-10-15 |
| Eleni       | Zlotkey     | 10500.00 | 2000-01-29 |
| Peter       | Tucker      | 10000.00 | 1997-01-30 |
| David       | Bernstein   |  9500.00 | 1997-03-24 |
| Peter       | Hall        |  9000.00 | 1997-08-20 |
| Christopher | Olsen       |  8000.00 | 1998-03-30 |
| Nanette     | Cambrault   |  7500.00 | 1998-12-09 |
| Oliver      | Tuvault     |  7000.00 | 1999-11-23 |
| Janette     | King        | 10000.00 | 1996-01-30 |
| Patrick     | Sully       |  9500.00 | 1996-03-04 |
| Allan       | McEwen      |  9000.00 | 1996-08-01 |
| Lindsey     | Smith       |  8000.00 | 1997-03-10 |
| Louise      | Doran       |  7500.00 | 1997-12-15 |
| Sarath      | Sewall      |  7000.00 | 1998-11-03 |
| Clara       | Vishney     | 10500.00 | 1997-11-11 |
| Danielle    | Greene      |  9500.00 | 1999-03-19 |
| Mattea      | Marvins     |  7200.00 | 2000-01-24 |
| David       | Lee         |  6800.00 | 2000-02-23 |
| Sundar      | Ande        |  6400.00 | 2000-03-24 |
| Amit        | Banda       |  6200.00 | 2000-04-21 |
| Lisa        | Ozer        | 11500.00 | 1997-03-11 |
| Harrison    | Bloom       | 10000.00 | 1998-03-23 |
| Tayler      | Fox         |  9600.00 | 1998-01-24 |
| William     | Smith       |  7400.00 | 1999-02-23 |
| Elizabeth   | Bates       |  7300.00 | 1999-03-24 |
| Sundita     | Kumar       |  6100.00 | 2000-04-21 |
| Ellen       | Abel        | 11000.00 | 1996-05-11 |
| Alyssa      | Hutton      |  8800.00 | 1997-03-19 |
| Jonathon    | Taylor      |  8600.00 | 1998-03-24 |
| Jack        | Livingston  |  8400.00 | 1998-04-23 |
| Kimberely   | Grant       |  7000.00 | 1999-05-24 |
| Charles     | Johnson     |  6200.00 | 2000-01-04 |
| Winston     | Taylor      |  3200.00 | 1998-01-24 |
| Jean        | Fleaur      |  3100.00 | 1998-02-23 |
| Martha      | Sullivan    |  2500.00 | 1999-06-21 |
| Girard      | Geoni       |  2800.00 | 2000-02-03 |
| Nandita     | Sarchand    |  4200.00 | 1996-01-27 |
| Alexis      | Bull        |  4100.00 | 1997-02-20 |
| Julia       | Dellinger   |  3400.00 | 1998-06-24 |
| Anthony     | Cabrio      |  3000.00 | 1999-02-07 |
| Kelly       | Chung       |  3800.00 | 1997-06-14 |
| Jennifer    | Dilly       |  3600.00 | 1997-08-13 |
| Timothy     | Gates       |  2900.00 | 1998-07-11 |
| Randall     | Perkins     |  2500.00 | 1999-12-19 |
| Sarah       | Bell        |  4000.00 | 1996-02-04 |
| Britney     | Everett     |  3900.00 | 1997-03-03 |
| Samuel      | McCain      |  3200.00 | 1998-07-01 |
| Vance       | Jones       |  2800.00 | 1999-03-17 |
| Alana       | Walsh       |  3100.00 | 1998-04-24 |
| Kevin       | Feeney      |  3000.00 | 1998-05-23 |
| Donald      | OConnell    |  2600.00 | 1999-06-21 |
| Douglas     | Grant       |  2600.00 | 2000-01-13 |
| Jennifer    | Whalen      |  4400.00 | 1987-09-17 |
| Michael     | Hartstein   | 13000.00 | 1996-02-17 |
| Pat         | Fay         |  6000.00 | 1997-08-17 |
| Susan       | Mavris      |  6500.00 | 1994-06-07 |
| Hermann     | Baer        | 10000.00 | 1994-06-07 |
| Shelley     | Higgins     | 12000.00 | 1994-06-07 |
| William     | Gietz       |  8300.00 | 1994-06-07 |
+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> LAST_NAME,FIRST_NAME,SALARY, HIRE_DATE
    -> FROM
    -> EMPLOYEES;
+-------------+-------------+----------+------------+
| LAST_NAME   | FIRST_NAME  | SALARY   | HIRE_DATE  |
+-------------+-------------+----------+------------+
| King        | Steven      | 24000.00 | 1987-06-17 |
| Kochhar     | Neena       | 17000.00 | 1989-09-21 |
| De Haan     | Lex         | 17000.00 | 1993-01-13 |
| Hunold      | Alexander   |  9000.00 | 1990-01-03 |
| Ernst       | Bruce       |  6000.00 | 1991-05-21 |
| Austin      | David       |  4800.00 | 1997-06-25 |
| Pataballa   | Valli       |  4800.00 | 1998-02-05 |
| Lorentz     | Diana       |  4200.00 | 1999-02-07 |
| Greenberg   | Nancy       | 12000.00 | 1994-08-17 |
| Faviet      | Daniel      |  9000.00 | 1994-08-16 |
| Chen        | John        |  8200.00 | 1997-09-28 |
| Sciarra     | Ismael      |  7700.00 | 1997-09-30 |
| Urman       | Jose Manuel |  7800.00 | 1998-03-07 |
| Popp        | Luis        |  6900.00 | 1999-12-07 |
| Raphaely    | Den         | 11000.00 | 1994-12-07 |
| Khoo        | Alexander   |  3100.00 | 1995-05-18 |
| Baida       | Shelli      |  2900.00 | 1997-12-24 |
| Tobias      | Sigal       |  2800.00 | 1997-07-24 |
| Himuro      | Guy         |  2600.00 | 1998-11-15 |
| Colmenares  | Karen       |  2500.00 | 1999-08-10 |
| Weiss       | Matthew     |  8000.00 | 1996-07-18 |
| Fripp       | Adam        |  8200.00 | 1997-04-10 |
| Kaufling    | Payam       |  7900.00 | 1995-05-01 |
| Vollman     | Shanta      |  6500.00 | 1997-10-10 |
| Mourgos     | Kevin       |  5800.00 | 1999-11-16 |
| Nayer       | Julia       |  3200.00 | 1997-07-16 |
| MiC -- query aborted
ikkilineni | Irene       |  2700.00 | 1998-09-28 |
+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 20 ;
+-------------+------------+-----------+----------+--------------+------------+--------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email    | phone_number | hire_date  | job_id | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+----------+--------------+------------+--------+----------+----------------+------------+---------------+
|         201 | Michael    | Hartstein | MHARTSTE | 515.123.5555 | 1996-02-17 | MK_MAN | 13000.00 |           NULL |        100 |            20 |
|         202 | Pat        | Fay       | PFAY     | 603.123.6666 | 1997-08-17 | MK_REP |  6000.00 |           NULL |        201 |            20 |
+-------------+------------+-----------+----------+--------------+------------+--------+----------+----------------+------------+---------------+
2 rows in set (0.01 sec)

mysql> SELECT
    -> FIRST_NAME,LAST_NAME, SALARY
    -> FROM EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 20 ;
+------------+-----------+----------+
| FIRST_NAME | LAST_NAME | SALARY   |
+------------+-----------+----------+
| Michael    | Hartstein | 13000.00 |
| Pat        | Fay       |  6000.00 |
+------------+-----------+----------+
2 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 80
    -> AND
    -> SALARY > 6000;
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name  | email    | phone_number       | hire_date  | job_id | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
|         145 | John        | Russell    | JRUSSEL  | 011.44.1344.429268 | 1996-10-01 | SA_MAN | 14000.00 |           0.40 |        100 |            80 |
|         146 | Karen       | Partners   | KPARTNER | 011.44.1344.467268 | 1997-01-05 | SA_MAN | 13500.00 |           0.30 |        100 |            80 |
|         147 | Alberto     | Errazuriz  | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN | 12000.00 |           0.30 |        100 |            80 |
|         148 | Gerald      | Cambrault  | GCAMBRAU | 011.44.1344.619268 | 1999-10-15 | SA_MAN | 11000.00 |           0.30 |        100 |            80 |
|         149 | Eleni       | Zlotkey    | EZLOTKEY | 011.44.1344.429018 | 2000-01-29 | SA_MAN | 10500.00 |           0.20 |        100 |            80 |
|         150 | Peter       | Tucker     | PTUCKER  | 011.44.1344.129268 | 1997-01-30 | SA_REP | 10000.00 |           0.30 |        145 |            80 |
|         151 | David       | Bernstein  | DBERNSTE | 011.44.1344.345268 | 1997-03-24 | SA_REP |  9500.00 |           0.25 |        145 |            80 |
|         152 | Peter       | Hall       | PHALL    | 011.44.1344.478968 | 1997-08-20 | SA_REP |  9000.00 |           0.25 |        145 |            80 |
|         153 | Christopher | Olsen      | COLSEN   | 011.44.1344.498718 | 1998-03-30 | SA_REP |  8000.00 |           0.20 |        145 |            80 |
|         154 | Nanette     | Cambrault  | NCAMBRAU | 011.44.1344.987668 | 1998-12-09 | SA_REP |  7500.00 |           0.20 |        145 |            80 |
|         155 | Oliver      | Tuvault    | OTUVAULT | 011.44.1344.486508 | 1999-11-23 | SA_REP |  7000.00 |           0.15 |        145 |            80 |
|         156 | Janette     | King       | JKING    | 011.44.1345.429268 | 1996-01-30 | SA_REP | 10000.00 |           0.35 |        146 |            80 |
|         157 | Patrick     | Sully      | PSULLY   | 011.44.1345.929268 | 1996-03-04 | SA_REP |  9500.00 |           0.35 |        146 |            80 |
|         158 | Allan       | McEwen     | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP |  9000.00 |           0.35 |        146 |            80 |
|         159 | Lindsey     | Smith      | LSMITH   | 011.44.1345.729268 | 1997-03-10 | SA_REP |  8000.00 |           0.30 |        146 |            80 |
|         160 | Louise      | Doran      | LDORAN   | 011.44.1345.629268 | 1997-12-15 | SA_REP |  7500.00 |           0.30 |        146 |            80 |
|         161 | Sarath      | Sewall     | SSEWALL  | 011.44.1345.529268 | 1998-11-03 | SA_REP |  7000.00 |           0.25 |        146 |            80 |
|         162 | Clara       | Vishney    | CVISHNEY | 011.44.1346.129268 | 1997-11-11 | SA_REP | 10500.00 |           0.25 |        147 |            80 |
|         163 | Danielle    | Greene     | DGREENE  | 011.44.1346.229268 | 1999-03-19 | SA_REP |  9500.00 |           0.15 |        147 |            80 |
|         164 | Mattea      | Marvins    | MMARVINS | 011.44.1346.329268 | 2000-01-24 | SA_REP |  7200.00 |           0.10 |        147 |            80 |
|         165 | David       | Lee        | DLEE     | 011.44.1346.529268 | 2000-02-23 | SA_REP |  6800.00 |           0.10 |        147 |            80 |
|         166 | Sundar      | Ande       | SANDE    | 011.44.1346.629268 | 2000-03-24 | SA_REP |  6400.00 |           0.10 |        147 |            80 |
|         167 | Amit        | Banda      | ABANDA   | 011.44.1346.729268 | 2000-04-21 | SA_REP |  6200.00 |           0.10 |        147 |            80 |
|         168 | Lisa        | Ozer       | LOZER    | 011.44.1343.929268 | 1997-03-11 | SA_REP | 11500.00 |           0.25 |        148 |            80 |
|         169 | Harrison    | Bloom      | HBLOOM   | 011.44.1343.829268 | 1998-03-23 | SA_REP | 10000.00 |           0.20 |        148 |            80 |
|         170 | Tayler      | Fox        | TFOX     | 011.44.1343.729268 | 1998-01-24 | SA_REP |  9600.00 |           0.20 |        148 |            80 |
|         171 | William     | Smith      | WSMITH   | 011.44.1343.629268 | 1999-02-23 | SA_REP |  7400.00 |           0.15 |        148 |            80 |
|         172 | Elizabeth   | Bates      | EBATES   | 011.44.1343.529268 | 1999-03-24 | SA_REP |  7300.00 |           0.15 |        148 |            80 |
|         173 | Sundita     | Kumar      | SKUMAR   | 011.44.1343.329268 | 2000-04-21 | SA_REP |  6100.00 |           0.10 |        148 |            80 |
|         174 | Ellen       | Abel       | EABEL    | 011.44.1644.429267 | 1996-05-11 | SA_REP | 11000.00 |           0.30 |        149 |            80 |
|         175 | Alyssa      | Hutton     | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP |  8800.00 |           0.25 |        149 |            80 |
|         176 | Jonathon    | Taylor     | JTAYLOR  | 011.44.1644.429265 | 1998-03-24 | SA_REP |  8600.00 |           0.20 |        149 |            80 |
|         177 | Jack        | Livingston | JLIVINGS | 011.44.1644.429264 | 1998-04-23 | SA_REP |  8400.00 |           0.20 |        149 |            80 |
|         179 | Charles     | Johnson    | CJOHNSON | 011.44.1644.429262 | 2000-01-04 | SA_REP |  6200.00 |           0.10 |        149 |            80 |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
34 rows in set (0.01 sec)

mysql>
mysql> SELECT
    -> DEPARTMENT_ID,SALARY,EMPLOYEE_ID
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 80
    -> AND
    -> SALARY > 6000;
+---------------+----------+-------------+
| DEPARTMENT_ID | SALARY   | EMPLOYEE_ID |
+---------------+----------+-------------+
|            80 | 14000.00 |         145 |
|            80 | 13500.00 |         146 |
|            80 | 12000.00 |         147 |
|            80 | 11000.00 |         148 |
|            80 | 10500.00 |         149 |
|            80 | 10000.00 |         150 |
|            80 |  9500.00 |         151 |
|            80 |  9000.00 |         152 |
|            80 |  8000.00 |         153 |
|            80 |  7500.00 |         154 |
|            80 |  7000.00 |         155 |
|            80 | 10000.00 |         156 |
|            80 |  9500.00 |         157 |
|            80 |  9000.00 |         158 |
|            80 |  8000.00 |         159 |
|            80 |  7500.00 |         160 |
|            80 |  7000.00 |         161 |
|            80 | 10500.00 |         162 |
|            80 |  9500.00 |         163 |
|            80 |  7200.00 |         164 |
|            80 |  6800.00 |         165 |
|            80 |  6400.00 |         166 |
|            80 |  6200.00 |         167 |
|            80 | 11500.00 |         168 |
|            80 | 10000.00 |         169 |
|            80 |  9600.00 |         170 |
|            80 |  7400.00 |         171 |
|            80 |  7300.00 |         172 |
|            80 |  6100.00 |         173 |
|            80 | 11000.00 |         174 |
|            80 |  8800.00 |         175 |
|            80 |  8600.00 |         176 |
|            80 |  8400.00 |         177 |
|            80 |  6200.00 |         179 |
+---------------+----------+-------------+
34 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 20 AND DEPARTMENT_ID = 30;
Empty set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 20 OR DEPARTMENT_ID = 30;
+-------------+------------+------------+----------+--------------+------------+----------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name  | email    | phone_number | hire_date  | job_id   | salary   | commission_pct | manager_id | department_id |
+-------------+------------+------------+----------+--------------+------------+----------+----------+----------------+------------+---------------+
|         201 | Michael    | Hartstein  | MHARTSTE | 515.123.5555 | 1996-02-17 | MK_MAN   | 13000.00 |           NULL |        100 |            20 |
|         202 | Pat        | Fay        | PFAY     | 603.123.6666 | 1997-08-17 | MK_REP   |  6000.00 |           NULL |        201 |            20 |
|         114 | Den        | Raphaely   | DRAPHEAL | 515.127.4561 | 1994-12-07 | PU_MAN   | 11000.00 |           NULL |        100 |            30 |
|         115 | Alexander  | Khoo       | AKHOO    | 515.127.4562 | 1995-05-18 | PU_CLERK |  3100.00 |           NULL |        114 |            30 |
|         116 | Shelli     | Baida      | SBAIDA   | 515.127.4563 | 1997-12-24 | PU_CLERK |  2900.00 |           NULL |        114 |            30 |
|         117 | Sigal      | Tobias     | STOBIAS  | 515.127.4564 | 1997-07-24 | PU_CLERK |  2800.00 |           NULL |        114 |            30 |
|         118 | Guy        | Himuro     | GHIMURO  | 515.127.4565 | 1998-11-15 | PU_CLERK |  2600.00 |           NULL |        114 |            30 |
|         119 | Karen      | Colmenares | KCOLMENA | 515.127.4566 | 1999-08-10 | PU_CLERK |  2500.00 |           NULL |        114 |            30 |
+-------------+------------+------------+----------+--------------+------------+----------+----------+----------------+------------+---------------+
8 rows in set (0.00 sec)

mysql> SELECT 2000*3045+3434*34354 FROM EMPLOYEES;
+----------------------+
| 2000*3045+3434*34354 |
+----------------------+
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
|            124061636 |
+----------------------+
107 rows in set (0.01 sec)

mysql> SELECT 2000*3045+3434*34354 FROM DUAL;
+----------------------+
| 2000*3045+3434*34354 |
+----------------------+
|            124061636 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT 2000*3045+3434*34354;
+----------------------+
| 2000*3045+3434*34354 |
+----------------------+
|            124061636 |
+----------------------+
1 row in set (0.00 sec)

mysql> SELECT NOW();
+---------------------+
| NOW()               |
+---------------------+
| 2021-07-03 09:08:14 |
+---------------------+
1 row in set (0.01 sec)

mysql> SELECT SYSDATE() FROM DUAL;
+---------------------+
| SYSDATE()           |
+---------------------+
| 2021-07-03 09:08:27 |
+---------------------+
1 row in set (0.00 sec)

mysql> SELECT 3000 + NULL;
+-------------+
| 3000 + NULL |
+-------------+
|        NULL |
+-------------+
1 row in set (0.00 sec)

mysql> SELECT 3000 * NULL;
+-------------+
| 3000 * NULL |
+-------------+
|        NULL |
+-------------+
1 row in set (0.00 sec)

mysql> DESC EMPOYEES;
ERROR 1146 (42S02): Table 'humanresource12.empoyees' doesn't exist
mysql> DESC EMPLOYEES;
+----------------+--------------+------+-----+---------+-------+
| Field          | Type         | Null | Key | Default | Extra |
+----------------+--------------+------+-----+---------+-------+
| employee_id    | int unsigned | NO   | PRI | NULL    |       |
| first_name     | varchar(20)  | YES  |     | NULL    |       |
| last_name      | varchar(25)  | NO   |     | NULL    |       |
| email          | varchar(25)  | NO   |     | NULL    |       |
| phone_number   | varchar(20)  | YES  |     | NULL    |       |
| hire_date      | date         | NO   |     | NULL    |       |
| job_id         | varchar(10)  | NO   | MUL | NULL    |       |
| salary         | decimal(8,2) | NO   |     | NULL    |       |
| commission_pct | decimal(2,2) | YES  |     | NULL    |       |
| manager_id     | int unsigned | YES  | MUL | NULL    |       |
| department_id  | int unsigned | YES  | MUL | NULL    |       |
+----------------+--------------+------+-----+---------+-------+
11 rows in set (0.01 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> COMMISSION_PCT = NULL;
Empty set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> COMMISSION_PCT IS NULL;
+-------------+-------------+-------------+----------+----------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name   | email    | phone_number   | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+-------------+----------+----------------+------------+------------+----------+----------------+------------+---------------+
|         100 | Steven      | King        | SKING    | 515.123.4567   | 1987-06-17 | AD_PRES    | 24000.00 |           NULL |       NULL |            90 |
|         101 | Neena       | Kochhar     | NKOCHHAR | 515.123.4568   | 1989-09-21 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         102 | Lex         | De Haan     | LDEHAAN  | 515.123.4569   | 1993-01-13 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         103 | Alexander   | Hunold      | AHUNOLD  | 590.423.4567   | 1990-01-03 | IT_PROG    |  9000.00 |           NULL |        102 |            60 |
|         104 | Bruce       | Ernst       | BERNST   | 590.423.4568   | 1991-05-21 | IT_PROG    |  6000.00 |           NULL |        103 |            60 |
|         105 | David       | Austin      | DAUSTIN  | 590.423.4569   | 1997-06-25 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         106 | Valli       | Pataballa   | VPATABAL | 590.423.4560   | 1998-02-05 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         107 | Diana       | Lorentz     | DLORENTZ | 590.423.5567   | 1999-02-07 | IT_PROG    |  4200.00 |           NULL |        103 |            60 |
|         108 | Nancy       | Greenberg   | NGREENBE | 515.124.4569   | 1994-08-17 | FI_MGR     | 12000.00 |           NULL |        101 |           100 |
|         109 | Daniel      | Faviet      | DFAVIET  | 515.124.4169   | 1994-08-16 | FI_ACCOUNT |  9000.00 |           NULL |        108 |           100 |
|         110 | John        | Chen        | JCHEN    | 515.124.4269   | 1997-09-28 | FI_ACCOUNT |  8200.00 |           NULL |        108 |           100 |
|         111 | Ismael      | Sciarra     | ISCIARRA | 515.124.4369   | 1997-09-30 | FI_ACCOUNT |  7700.00 |           NULL |        108 |           100 |
|         112 | Jose Manuel | Urman       | JMURMAN  | 515.124.4469   | 1998-03-07 | FI_ACCOUNT |  7800.00 |           NULL |        108 |           100 |
|         113 | Luis        | Popp        | LPOPP    | 515.124.4567   | 1999-12-07 | FI_ACCOUNT |  6900.00 |           NULL |        108 |           100 |
|         114 | Den         | Raphaely    | DRAPHEAL | 515.127.4561   | 1994-12-07 | PU_MAN     | 11000.00 |           NULL |        100 |            30 |
|         115 | Alexander   | Khoo        | AKHOO    | 515.127.4562   | 1995-05-18 | PU_CLERK   |  3100.00 |           NULL |        114 |            30 |
|         116 | Shelli      | Baida       | SBAIDA   | 515.127.4563   | 1997-12-24 | PU_CLERK   |  2900.00 |           NULL |        114 |            30 |
|         117 | Sigal       | Tobias      | STOBIAS  | 515.127.4564   | 1997-07-24 | PU_CLERK   |  2800.00 |           NULL |        114 |            30 |
|         118 | Guy         | Himuro      | GHIMURO  | 515.127.4565   | 1998-11-15 | PU_CLERK   |  2600.00 |           NULL |        114 |            30 |
|         119 | Karen       | Colmenares  | KCOLMENA | 515.127.4566   | 1999-08-10 | PU_CLERK   |  2500.00 |           NULL |        114 |            30 |
|         120 | Matthew     | Weiss       | MWEISS   | 650.123.1234   | 1996-07-18 | ST_MAN     |  8000.00 |           NULL |        100 |            50 |
|         121 | Adam        | Fripp       | AFRIPP   | 650.123.2234   | 1997-04-10 | ST_MAN     |  8200.00 |           NULL |        100 |            50 |
|         122 | Payam       | Kaufling    | PKAUFLIN | 650.123.3234   | 1995-05-01 | ST_MAN     |  7900.00 |           NULL |        100 |            50 |
|         123 | Shanta      | Vollman     | SVOLLMAN | 650.123.4234   | 1997-10-10 | ST_MAN     |  6500.00 |           NULL |        100 |            50 |
|         124 | Kevin       | Mourgos     | KMOURGOS | 650.123.5234   | 1999-11-16 | ST_MAN     |  5800.00 |           NULL |        100 |            50 |
|         125 | Julia       | Nayer       | JNAYER   | 650.124.1214   | 1997-07-16 | ST_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         126 | Irene       | Mikkilineni | IMIKKILI | 650.124.1224   | 1998-09-28 | ST_CLERK   |  2700.00 |           NULL |        120 |            50 |
|         127 | James       | Landry      | JLANDRY  | 650.124.1334   | 1999-01-14 | ST_CLERK   |  2400.00 |           NULL |        120 |            50 |
|         128 | Steven      | Markle      | SMARKLE  | 650.124.1434   | 2000-03-08 | ST_CLERK   |  2200.00 |           NULL |        120 |            50 |
|         129 | Laura       | Bissot      | LBISSOT  | 650.124.5234   | 1997-08-20 | ST_CLERK   |  3300.00 |           NULL |        121 |            50 |
|         130 | Mozhe       | Atkinson    | MATKINSO | 650.124.6234   | 1997-10-30 | ST_CLERK   |  2800.00 |           NULL |        121 |            50 |
|         131 | James       | Marlow      | JAMRLOW  | 650.124.7234   | 1997-02-16 | ST_CLERK   |  2500.00 |           NULL |        121 |            50 |
|         132 | TJ          | Olson       | TJOLSON  | 650.124.8234   | 1999-04-10 | ST_CLERK   |  2100.00 |           NULL |        121 |            50 |
|         133 | Jason       | Mallin      | JMALLIN  | 650.127.1934   | 1996-06-14 | ST_CLERK   |  3300.00 |           NULL |        122 |            50 |
|         134 | Michael     | Rogers      | MROGERS  | 650.127.1834   | 1998-08-26 | ST_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         135 | Ki          | Gee         | KGEE     | 650.127.1734   | 1999-12-12 | ST_CLERK   |  2400.00 |           NULL |        122 |            50 |
|         136 | Hazel       | Philtanker  | HPHILTAN | 650.127.1634   | 2000-02-06 | ST_CLERK   |  2200.00 |           NULL |        122 |            50 |
|         137 | Renske      | Ladwig      | RLADWIG  | 650.121.1234   | 1995-07-14 | ST_CLERK   |  3600.00 |           NULL |        123 |            50 |
|         138 | Stephen     | Stiles      | SSTILES  | 650.121.2034   | 1997-10-26 | ST_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         139 | John        | Seo         | JSEO     | 650.121.2019   | 1998-02-12 | ST_CLERK   |  2700.00 |           NULL |        123 |            50 |
|         140 | Joshua      | Patel       | JPATEL   | 650.121.1834   | 1998-04-06 | ST_CLERK   |  2500.00 |           NULL |        123 |            50 |
|         141 | Trenna      | Rajs        | TRAJS    | 650.121.8009   | 1995-10-17 | ST_CLERK   |  3500.00 |           NULL |        124 |            50 |
|         142 | Curtis      | Davies      | CDAVIES  | 650.121.2994   | 1997-01-29 | ST_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         143 | Randall     | Matos       | RMATOS   | 650.121.2874   | 1998-03-15 | ST_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         144 | Peter       | Vargas      | PVARGAS  | 650.121.2004   | 1998-07-09 | ST_CLERK   |  2500.00 |           NULL |        124 |            50 |
|         180 | Winston     | Taylor      | WTAYLOR  | 650.507.9876   | 1998-01-24 | SH_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         181 | Jean        | Fleaur      | JFLEAUR  | 650.507.9877   | 1998-02-23 | SH_CLERK   |  3100.00 |           NULL |        120 |            50 |
|         182 | Martha      | Sullivan    | MSULLIVA | 650.507.9878   | 1999-06-21 | SH_CLERK   |  2500.00 |           NULL |        120 |            50 |
|         183 | Girard      | Geoni       | GGEONI   | 650.507.9879   | 2000-02-03 | SH_CLERK   |  2800.00 |           NULL |        120 |            50 |
|         184 | Nandita     | Sarchand    | NSARCHAN | 650.509.1876   | 1996-01-27 | SH_CLERK   |  4200.00 |           NULL |        121 |            50 |
|         185 | Alexis      | Bull        | ABULL    | 650.509.2876   | 1997-02-20 | SH_CLERK   |  4100.00 |           NULL |        121 |            50 |
|         186 | Julia       | Dellinger   | JDELLING | 650.509.3876   | 1998-06-24 | SH_CLERK   |  3400.00 |           NULL |        121 |            50 |
|         187 | Anthony     | Cabrio      | ACABRIO  | 650.509.4876   | 1999-02-07 | SH_CLERK   |  3000.00 |           NULL |        121 |            50 |
|         188 | Kelly       | Chung       | KCHUNG   | 650.505.1876   | 1997-06-14 | SH_CLERK   |  3800.00 |           NULL |        122 |            50 |
|         189 | Jennifer    | Dilly       | JDILLY   | 650.505.2876   | 1997-08-13 | SH_CLERK   |  3600.00 |           NULL |        122 |            50 |
|         190 | Timothy     | Gates       | TGATES   | 650.505.3876   | 1998-07-11 | SH_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         191 | Randall     | Perkins     | RPERKINS | 650.505.4876   | 1999-12-19 | SH_CLERK   |  2500.00 |           NULL |        122 |            50 |
|         192 | Sarah       | Bell        | SBELL    | 650.501.1876   | 1996-02-04 | SH_CLERK   |  4000.00 |           NULL |        123 |            50 |
|         193 | Britney     | Everett     | BEVERETT | 650.501.2876   | 1997-03-03 | SH_CLERK   |  3900.00 |           NULL |        123 |            50 |
|         194 | Samuel      | McCain      | SMCCAIN  | 650.501.3876   | 1998-07-01 | SH_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         195 | Vance       | Jones       | VJONES   | 650.501.4876   | 1999-03-17 | SH_CLERK   |  2800.00 |           NULL |        123 |            50 |
|         196 | Alana       | Walsh       | AWALSH   | 650.507.9811   | 1998-04-24 | SH_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         197 | Kevin       | Feeney      | KFEENEY  | 650.507.9822   | 1998-05-23 | SH_CLERK   |  3000.00 |           NULL |        124 |            50 |
|         198 | Donald      | OConnell    | DOCONNEL | 650.507.9833   | 1999-06-21 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         199 | Douglas     | Grant       | DGRANT   | 650.507.9844   | 2000-01-13 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         200 | Jennifer    | Whalen      | JWHALEN  | 515.123.4444   | 1987-09-17 | AD_ASST    |  4400.00 |           NULL |        101 |            10 |
|         201 | Michael     | Hartstein   | MHARTSTE | 515.123.5555   | 1996-02-17 | MK_MAN     | 13000.00 |           NULL |        100 |            20 |
|         202 | Pat         | Fay         | PFAY     | 603.123.6666   | 1997-08-17 | MK_REP     |  6000.00 |           NULL |        201 |            20 |
|         203 | Susan       | Mavris      | SMAVRIS  | 515.123.7777   | 1994-06-07 | HR_REP     |  6500.00 |           NULL |        101 |            40 |
|         204 | Hermann     | Baer        | HBAER    | 515.123.8888   | 1994-06-07 | PR_REP     | 10000.00 |           NULL |        101 |            70 |
|         205 | Shelley     | Higgins     | SHIGGINS | 515.123.8080   | 1994-06-07 | AC_MGR     | 12000.00 |           NULL |        101 |           110 |
|         206 | William     | Gietz       | WGIETZ   | 51hr5.123.8181 | 1994-06-07 | AC_ACCOUNT |  8300.00 |           NULL |        205 |           110 |
+-------------+-------------+-------------+----------+----------------+------------+------------+----------+----------------+------------+---------------+
72 rows in set (0.00 sec)

mysql> SELECT 80000 + (25/100 * 80000);
+--------------------------+
| 80000 + (25/100 * 80000) |
+--------------------------+
|              100000.0000 |
+--------------------------+
1 row in set (0.00 sec)

mysql> SELECT 80000 + (25/100 * 80000) FROM DEPARTMENT;
ERROR 1146 (42S02): Table 'humanresource12.department' doesn't exist
mysql> SELECT 80000 + (25/100 * 80000) FROM DEPARTMENTS;
+--------------------------+
| 80000 + (25/100 * 80000) |
+--------------------------+
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
|              100000.0000 |
+--------------------------+
27 rows in set (0.03 sec)

mysql> SELECT 80000 + (25/100 * 80000) FROM DUAL;
+--------------------------+
| 80000 + (25/100 * 80000) |
+--------------------------+
|              100000.0000 |
+--------------------------+
1 row in set (0.00 sec)

mysql> SELECT CURDATE() FROM DUAL;
+------------+
| CURDATE()  |
+------------+
| 2021-07-03 |
+------------+
1 row in set (0.00 sec)

mysql> SELECT 80000 * 1.25;
+--------------+
| 80000 * 1.25 |
+--------------+
|    100000.00 |
+--------------+
1 row in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID,FIRST_NAME, LAST_NAME,SALARY,
    -> SALARY * 1.25
    -> FROM
    -> EMPLOYEES;
+-------------+-------------+-------------+----------+---------------+
| EMPLOYEE_ID | FIRST_NAME  | LAST_NAME   | SALARY   | SALARY * 1.25 |
+-------------+-------------+-------------+----------+---------------+
|         100 | Steven      | King        | 24000.00 |    30000.0000 |
|         101 | Neena       | Kochhar     | 17000.00 |    21250.0000 |
|         102 | Lex         | De Haan     | 17000.00 |    21250.0000 |
|         103 | Alexander   | Hunold      |  9000.00 |    11250.0000 |
|         104 | Bruce       | Ernst       |  6000.00 |     7500.0000 |
|         105 | David       | Austin      |  4800.00 |     6000.0000 |
|         106 | Valli       | Pataballa   |  4800.00 |     6000.0000 |
|         107 | Diana       | Lorentz     |  4200.00 |     5250.0000 |
|         108 | Nancy       | Greenberg   | 12000.00 |    15000.0000 |
|         109 | Daniel      | Faviet      |  9000.00 |    11250.0000 |
|         110 | John        | Chen        |  8200.00 |    10250.0000 |
|         111 | Ismael      | Sciarra     |  7700.00 |     9625.0000 |
|         112 | Jose Manuel | Urman       |  7800.00 |     9750.0000 |
|         113 | Luis        | Popp        |  6900.00 |     8625.0000 |
|         114 | Den         | Raphaely    | 11000.00 |    13750.0000 |
|         115 | Alexander   | Khoo        |  3100.00 |     3875.0000 |
|         116 | Shelli      | Baida       |  2900.00 |     3625.0000 |
|         117 | Sigal       | Tobias      |  2800.00 |     3500.0000 |
|         118 | Guy         | Himuro      |  2600.00 |     3250.0000 |
|         119 | Karen       | Colmenares  |  2500.00 |     3125.0000 |
|         120 | Matthew     | Weiss       |  8000.00 |    10000.0000 |
|         121 | Adam        | Fripp       |  8200.00 |    10250.0000 |
|         122 | Payam       | Kaufling    |  7900.00 |     9875.0000 |
|         123 | Shanta      | Vollman     |  6500.00 |     8125.0000 |
|         124 | Kevin       | Mourgos     |  5800.00 |     7250.0000 |
|         125 | Julia       | Nayer       |  3200.00 |     4000.0000 |
|         126 | Irene       | Mikkilineni |  2700.00 |     3375.0000 |
|         127 | James       | Landry      |  2400.00 |     3000.0000 |
|         128 | Steven      | Markle      |  2200.00 |     2750.0000 |
|         129 | Laura       | Bissot      |  3300.00 |     4125.0000 |
|         130 | Mozhe       | Atkinson    |  2800.00 |     3500.0000 |
|         131 | James       | Marlow      |  2500.00 |     3125.0000 |
|         132 | TJ          | Olson       |  2100.00 |     2625.0000 |
|         133 | Jason       | Mallin      |  3300.00 |     4125.0000 |
|         134 | Michael     | Rogers      |  2900.00 |     3625.0000 |
|         135 | Ki          | Gee         |  2400.00 |     3000.0000 |
|         136 | Hazel       | Philtanker  |  2200.00 |     2750.0000 |
|         137 | Renske      | Ladwig      |  3600.00 |     4500.0000 |
|         138 | Stephen     | Stiles      |  3200.00 |     4000.0000 |
|         139 | John        | Seo         |  2700.00 |     3375.0000 |
|         140 | Joshua      | Patel       |  2500.00 |     3125.0000 |
|         141 | Trenna      | Rajs        |  3500.00 |     4375.0000 |
|         142 | Curtis      | Davies      |  3100.00 |     3875.0000 |
|         143 | Randall     | Matos       |  2600.00 |     3250.0000 |
|         144 | Peter       | Vargas      |  2500.00 |     3125.0000 |
|         145 | John        | Russell     | 14000.00 |    17500.0000 |
|         146 | Karen       | Partners    | 13500.00 |    16875.0000 |
|         147 | Alberto     | Errazuriz   | 12000.00 |    15000.0000 |
|         148 | Gerald      | Cambrault   | 11000.00 |    13750.0000 |
|         149 | Eleni       | Zlotkey     | 10500.00 |    13125.0000 |
|         150 | Peter       | Tucker      | 10000.00 |    12500.0000 |
|         151 | David       | Bernstein   |  9500.00 |    11875.0000 |
|         152 | Peter       | Hall        |  9000.00 |    11250.0000 |
|         153 | Christopher | Olsen       |  8000.00 |    10000.0000 |
|         154 | Nanette     | Cambrault   |  7500.00 |     9375.0000 |
|         155 | -- query aborted
 | Oliver      | Tuvault     |  7000.00 |     8750.0000 |
+-------------+-------------+-------------+----------+---------------+
107 rows in set (0.00 sec)

mysql> DESC EMPLOYEES;
+----------------+--------------+------+-----+---------+-------+
| Field          | Type         | Null | Key | Default | Extra |
+----------------+--------------+------+-----+---------+-------+
| employee_id    | int unsigned | NO   | PRI | NULL    |       |
| first_name     | varchar(20)  | YES  |     | NULL    |       |
| last_name      | varchar(25)  | NO   |     | NULL    |       |
| email          | varchar(25)  | NO   |     | NULL    |       |
| phone_number   | varchar(20)  | YES  |     | NULL    |       |
| hire_date      | date         | NO   |     | NULL    |       |
| job_id         | varchar(10)  | NO   | MUL | NULL    |       |
| salary         | decimal(8,2) | NO   |     | NULL    |       |
| commission_pct | decimal(2,2) | YES  |     | NULL    |       |
| manager_id     | int unsigned | YES  | MUL | NULL    |       |
| department_id  | int unsigned | YES  | MUL | NULL    |       |
+----------------+--------------+------+-----+---------+-------+
11 rows in set (0.01 sec)

mysql> COMMIT;
Query OK, 0 rows affected (0.01 sec)

mysql> DESC EMPLOYEES;
+----------------+--------------+------+-----+---------+-------+
| Field          | Type         | Null | Key | Default | Extra |
+----------------+--------------+------+-----+---------+-------+
| employee_id    | int unsigned | NO   | PRI | NULL    |       |
| first_name     | varchar(20)  | YES  |     | NULL    |       |
| last_name      | varchar(25)  | NO   |     | NULL    |       |
| email          | varchar(25)  | NO   |     | NULL    |       |
| phone_number   | varchar(20)  | YES  |     | NULL    |       |
| hire_date      | date         | NO   |     | NULL    |       |
| job_id         | varchar(10)  | NO   | MUL | NULL    |       |
| salary         | decimal(8,2) | NO   |     | NULL    |       |
| commission_pct | decimal(2,2) | YES  |     | NULL    |       |
| manager_id     | int unsigned | YES  | MUL | NULL    |       |
| department_id  | int unsigned | YES  | MUL | NULL    |       |
+----------------+--------------+------+-----+---------+-------+
11 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID,FIRST_NAME, LAST_NAME,SALARY,
    -> SALARY * 1.25 HIKESAALRY
    -> FROM
    -> EMPLOYEES;
+-------------+-------------+-------------+----------+------------+
| EMPLOYEE_ID | FIRST_NAME  | LAST_NAME   | SALARY   | HIKESAALRY |
+-------------+-------------+-------------+----------+------------+
|         100 | Steven      | King        | 24000.00 | 30000.0000 |
|         101 | Neena       | Kochhar     | 17000.00 | 21250.0000 |
|         102 | Lex         | De Haan     | 17000.00 | 21250.0000 |
|         103 | Alexander   | Hunold      |  9000.00 | 11250.0000 |
|         104 | Bruce       | Ernst       |  6000.00 |  7500.0000 |
|         105 | David       | Austin      |  4800.00 |  6000.0000 |
|         106 | Valli       | Pataballa   |  4800.00 |  6000.0000 |
|         107 | Diana       | Lorentz     |  4200.00 |  5250.0000 |
|         108 | Nancy       | Greenberg   | 12000.00 | 15000.0000 |
|         109 | Daniel      | Faviet      |  9000.00 | 11250.0000 |
|         110 | John        | Chen        |  8200.00 | 10250.0000 |
|         111 | Ismael      | Sciarra     |  7700.00 |  9625.0000 |
|         112 | Jose Manuel | Urman       |  7800.00 |  9750.0000 |
|         113 | Luis        | Popp        |  6900.00 |  8625.0000 |
|         114 | Den         | Raphaely    | 11000.00 | 13750.0000 |
|         115 | Alexander   | Khoo        |  3100.00 |  3875.0000 |
|         116 | Shelli      | Baida       |  2900.00 |  3625.0000 |
|         117 | Sigal       | Tobias      |  2800.00 |  3500.0000 |
|         118 | Guy         | Himuro      |  2600.00 |  3250.0000 |
|         119 | Karen       | Colmenares  |  2500.00 |  3125.0000 |
|         120 | Matthew     | Weiss       |  8000.00 | 10000.0000 |
|         121 | Adam        | Fripp       |  8200.00 | 10250.0000 |
|         122 | Payam       | Kaufling    |  7900.00 |  9875.0000 |
|         123 | Shanta      | Vollman     |  6500.00 |  8125.0000 |
|         124 | Kevin       | Mourgos     |  5800.00 |  7250.0000 |
|         125 | Julia       | Nayer       |  3200.00 |  4000.0000 |
|         126 | Irene       | Mikkilineni |  2700.00 |  3375.0000 |
|         127 | James       | Landry      |  2400.00 |  3000.0000 |
|         128 | Steven      | Markle      |  2200.00 |  2750.0000 |
|         129 | Laura       | Bissot      |  3300.00 |  4125.0000 |
|         130 | Mozhe       | Atkinson    |  2800.00 |  3500.0000 |
|         131 | James       | Marlow      |  2500.00 |  3125.0000 |
|         132 | TJ          | Olson       |  2100.00 |  2625.0000 |
|         133 | Jason       | Mallin      |  3300.00 |  4125.0000 |
|         134 | Michael     | Rogers      |  2900.00 |  3625.0000 |
|         135 | Ki          | Gee         |  2400.00 |  3000.0000 |
|  C -- query aborted
        136 | Hazel       | Philtanker  |  2200.00 |  2750.0000 |
+-------------+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID EMPNO,FIRST_NAME FIRSTNAME, LAST_NAME LASTNAME,SALARY EMPSAL,
    -> SALARY * 1.25 HIKESAALRY
    -> FROM
    -> EMPLOYEES;
+-------+-------------+-------------+----------+------------+
| EMPNO | FIRSTNAME   | LASTNAME    | EMPSAL   | HIKESAALRY |
+-------+-------------+-------------+----------+------------+
|   100 | Steven      | King        | 24000.00 | 30000.0000 |
|   101 | Neena       | Kochhar     | 17000.00 | 21250.0000 |
|   102 | Lex         | De Haan     | 17000.00 | 21250.0000 |
|   103 | Alexander   | Hunold      |  9000.00 | 11250.0000 |
|   104 | Bruce       | Ernst       |  6000.00 |  7500.0000 |
|   105 | David       | Austin      |  4800.00 |  6000.0000 |
|   106 | Valli       | Pataballa   |  4800.00 |  6000.0000 |
|   107 | Diana       | Lorentz     |  4200.00 |  5250.0000 |
|   108 | Nancy       | Greenberg   | 12000.00 | 15000.0000 |
|   109 | Daniel      | Faviet      |  9000.00 | 11250.0000 |
|   110 | John        | Chen        |  8200.00 | 10250.0000 |
|   111 | Ismael      | Sciarra     |  7700.00 |  9625.0000 |
|   112 | Jose Manuel | Urman       |  7800.00 |  9750.0000 |
|   113 | Luis        | Popp        |  6900.00 |  8625.0000 |
|   114 | Den         | Raphaely    | 11000.00 | 13750.0000 |
|   115 | Alexander   | Khoo        |  3100.00 |  3875.0000 |
|   116 | Shelli      | Baida       |  2900.00 |  3625.0000 |
|   117 | Sigal       | Tobias      |  2800.00 |  3500.0000 |
|   118 | Guy         | Himuro      |  2600.00 |  3250.0000 |
|   119 | Karen       | Colmenares  |  2500.00 |  3125.0000 |
|   120 | Matthew     | Weiss       |  8000.00 | 10000.0000 |
|   121 | Adam        | Fripp       |  8200.00 | 10250.0000 |
|   122 | Payam       | Kaufling    |  7900.00 |  9875.0000 |
|   123 | Shanta      | Vollman     |  6500.00 |  8125.0000 |
|   124 | Kevin       | Mourgos     |  5800.00 |  7250.0000 |
|   125 | Julia       | Nayer       |  3200.00 |  4000.0000 |
|   126 | Irene       | Mikkilineni |  2700.00 |  3375.0000 |
|   127 | James       | Landry      |  2400.00 |  3000.0000 |
|   128 | Steven      | Markle      |  2200.00 |  2750.0000 |
|   129 | Laura       | Bissot      |  3300.00 |  4125.0000 |
|   130 | Mozhe       | Atkinson    |  2800.00 |  3500.0000 |
|   131 | James       | Marlow      |  2500.00 |  3125.0000 |
|   132 | TJ          | Olson       |  2100.00 |  2625.0000 |
|   133 | Jason       | Mallin      |  3300.00 |  4125.0000 |
|   134 | Michael     | Rogers      |  2900.00 |  3625.0000 |
|   135 | Ki          | Gee         |  2400.00 |  3000.0000 |
|   136 | Hazel       | Philtanker  |  2200.00 |  2750.0000 |
|   137 | Renske      | Ladwig      |  3600.00 |  4500.0000 |
|   138 | Stephen     | Stiles      |  3200.00 |  4000.0000 |
|   139 | John        | Seo         |  2700.00 |  3375.0000 |
|   140 | Joshua      | Patel       |  2500.00 |  3125.0000 |
|   141 | Trenna      | Rajs        |  3500.00 |  4375.0000 |
|   142 | Curtis      | Davies      |  3100.00 |  3875.0000 |
|   143 | Randall     | Matos       |  2600.00 |  3250.0000 |
|   144 | Peter       | Vargas      |  2500.00 |  3125.0000 |
|   145 | John        | Russell     | 14000.00 | 17500.0000 |
|   146 | Karen       | Partners    | 13500.00 | 16875.0000 |
|   147 |^AC -- query aborted
Alberto     | Errazuriz   | 12000.00 | 15000.0000 |
+-------+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID AS EMPNO,FIRST_NAME AS FIRSTNAME, LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
    -> SALARY * 1.25 HIKESAALRY
    -> FROM
    -> EMPLOYEES;
+-------+-------------+-------------+----------+------------+
| EMPNO | FIRSTNAME   | LASTNAME    | EMPSAL   | HIKESAALRY |
+-------+-------------+-------------+----------+------------+
|   100 | Steven      | King        | 24000.00 | 30000.0000 |
|   101 | Neena       | Kochhar     | 17000.00 | 21250.0000 |
|   102 | Lex         | De Haan     | 17000.00 | 21250.0000 |
|   103 | Alexander   | Hunold      |  9000.00 | 11250.0000 |
|   104 | Bruce       | Ernst       |  6000.00 |  7500.0000 |
|   105 | David       | Austin      |  4800.00 |  6000.0000 |
|   106 | Valli       | Pataballa   |  4800.00 |  6000.0000 |
|   107 | Diana       | Lorentz     |  4200.00 |  5250.0000 |
|   108 | Nancy       | Greenberg   | 12000.00 | 15000.0000 |
|   109 | Daniel      | Faviet      |  9000.00 | 11250.0000 |
|   110 | John        | Chen        |  8200.00 | 10250.0000 |
|   111 | Ismael      | Sciarra     |  7700.00 |  9625.0000 |
|   112 | Jose Manuel | Urman       |  7800.00 |  9750.0000 |
|   113 | Luis        | Popp        |  6900.00 |  8625.0000 |
|   114 | Den         | Raphaely    | 11000.00 | 13750.0000 |
|   115 | Alexander   | Khoo        |  3100.00 |  3875.0000 |
|   116 | Shelli      | Baida       |  2900.00 |  3625.0000 |
|   117 | Sigal       | Tobias      |  2800.00 |  3500.0000 |
|   118 | Guy         | Himuro      |  2600.00 |  3250.0000 |
|   119 | Karen       | Colmenares  |  2500.00 |  3125.0000 |
|   120 | Matthew     | Weiss       |  8000.00 | 10000.0000 |
|   121 | Adam        | Fripp       |  8200.00 | 10250.0000 |
|   122 | Payam       | Kaufling    |  7900.00 |  9875.0000 |
|   123 | Shanta      | Vollman     |  6500.00 |  8125.0000 |
|   124 | Kevin       | Mourgos     |  5800.00 |  7250.0000 |
|   125 | Julia       | Nayer       |  3200.00 |  4000.0000 |
|   126 | Irene       | Mikkilineni |  2700.00 |  3375.0000 |
|   127 | James       | Landry      |  2400.00 |  3000.0000 |
|   128 | Steven      | Markle      |  2200.00 |  2750.0000 |
|   129 | Laura       | Bissot      |  3300.00 |  4125.0000 |
|   130 | Mozhe       | Atkinson    |  2800.00 |  3500.0000 |
|   131 | James       | Marlow      |  2500.00 |  3125.0000 |
|   132 | TJ          | Olson       |  2100.00 |  2625.0000 |
|   133 | Jason       | Mallin      |  3300.00 |  4125.0000 |
|   134 | Michael     | Rogers      |  2900.00 |  3625.0000 |
|   135 | Ki          | Gee         |  2400.00 |  3000.0000 |
|   136 | Hazel       | PhiC -- query aborted
iltanker  |  2200.00 |  2750.0000 |
+-------+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID AS "EMP NO",FIRST_NAME AS FIRSTNAME, LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
    -> SALARY * 1.25 HIKESAALRY
    -> FROM
    -> EMPLOYEES;
+--------+-------------+-------------+----------+------------+
| EMP NO | FIRSTNAME   | LASTNAME    | EMPSAL   | HIKESAALRY |
+--------+-------------+-------------+----------+------------+
|    100 | Steven      | King        | 24000.00 | 30000.0000 |
|    101 | Neena       | Kochhar     | 17000.00 | 21250.0000 |
|    102 | Lex         | De Haan     | 17000.00 | 21250.0000 |
|    103 | Alexander   | Hunold      |  9000.00 | 11250.0000 |
|    104 | Bruce       | Ernst       |  6000.00 |  7500.0000 |
|    105 | David       | Austin      |  4800.00 |  6000.0000 |
|    106 | Valli       | Pataballa   |  4800.00 |  6000.0000 |
|    107 | Diana       | Lorentz     |  4200.00 |  5250.0000 |
|    108 | Nancy       | Greenberg   | 12000.00 | 15000.0000 |
|    109 | Daniel      | Faviet      |  9000.00 | 11250.0000 |
|    110 | John        | Chen        |  8200.00 | 10250.0000 |
|    111 | Ismael      | Sciarra     |  7700.00 |  9625.0000 |
|    112 | Jose Manuel | Urman       |  7800.00 |  9750.0000 |
|    113 | Luis        | Popp        |  6900.00 |  8625.0000 |
|    114 | Den         | Raphaely    | 11000.00 | 13750.0000 |
|    115 | Alexander   | Khoo        |  3100.00 |  3875.0000 |
|    116 | Shelli      | Baida       |  2900.00 |  3625.0000 |
|    117 | Sigal       | Tobias      |  2800.00 |  3500.0000 |
|    118 | Guy         | Himuro      |  2600.00 |  3250.0000 |
|    119 | Karen       | Colmenares  |  2500.00 |  3125.0000 |
|    120 | Matthew     | Weiss       |  8000.00 | 10000.0000 |
|    121 | Adam        | Fripp       |  8200.00 | 10250.0000 |
|    122 | Payam       | Kaufling    |  7900.00 |  9875.0000 |
|    123 | Shanta      | Vollman     |  6500.00 |  8125.0000 |
|    124 | Kevin       | Mourgos     |  5800.00 |  7250.0000 |
|    125 | Julia       | Nayer       |  3200.00 |  4000.0000 |
|    126 | Irene       | Mikkilineni |  2700.00 |  3375.0000 |
|    127 | James       | Landry      |  2400.00 |  3000.0000 |
|    128 | Steven      | Markle      |  2200.00 |  2750.0000 |
|    129 | Laura       | Bissot      |  3300.00 |  4125.0000 |
|    130 | Mozhe       | Atkinson    |  2800.00 |  3500.0000 |
|    131 | James       | Marlow      |  2500.00 |  3125.0000 |
|    132 | TJ          | Olson       |  2100.00 |  2625.0000 |
|    133 | Jason       | Mallin      |  3300.00 |  4125.0000 |
|    134 | Michael     | Rogers      |  2900.00 |  3625.0000 |
|    135 | Ki          | Gee         |  2400.00 |  3000.0000 |
|    136 | Hazel       | Philtanker  |  2200.00 |  2750.0000 |
|    137 | Renske      | Ladwig      |  3600.00 |  4500.0000 |
|    138 | Stephen     | Stiles      |  3200.00 |  4000.0000 |
|    139 | John        | Seo         |  2700.00 |  3375.0000 |
|    140 | Joshua      | Patel       |  2500.00 |  3125.0000 |
|    141 | Trenna      | Rajs        |  3500.00 |  4375.0000 |
|    142 | Curtis      | Davies      |  3100.00 |  3875.0000 |
|    143 | Randall     | Matos       |  2600.00 |  3250.0000 |
|    144 | Peter       | Vargas      |  2500.00 |  3125.0000 |
|    145 | John        | Russell     | 14000.00 | 17500.0000 |
|    146 | Karen       | Partners    | 13500.00 | 16875.0000 |
|    147 | Alberto     | Errazuriz   | 12000.00 | 15000.0000 |
|    148 | Gerald      | Cambrault   | 11000.00 | 13750.0000 |
|    149 | Eleni       | Zlotkey     | 10500.00 | 13125.0000 |
|    150 | Peter       | Tucker      | 10000.00 | 12500.0000 |
|    151 | David       | Bernstein   |  9500.00 | 11875.0000 |
|    152 | Peter       | Hall        |  9000.00 | 11250.0000 |
| ^C -- query aborted
   153 | Christopher | Olsen       |  8000.00 | 10000.0000 |
+--------+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID AS "EMP NO",FIRST_NAME AS "FIRST NAME", LAST_NAME AS LASTNAME,SALARY AS EMPSAL,
    -> SALARY * 1.25 HIKESAALRY
    -> FROM
    -> EMPLOYEES;
+--------+-------------+-------------+----------+------------+
| EMP NO | FIRST NAME  | LASTNAME    | EMPSAL   | HIKESAALRY |
+--------+-------------+-------------+----------+------------+
|    100 | Steven      | King        | 24000.00 | 30000.0000 |
|    101 | Neena       | Kochhar     | 17000.00 | 21250.0000 |
|    102 | Lex         | De Haan     | 17000.00 | 21250.0000 |
|    103 | Alexander   | Hunold      |  9000.00 | 11250.0000 |
|    104 | Bruce       | Ernst       |  6000.00 |  7500.0000 |
|    105 | David       | Austin      |  4800.00 |  6000.0000 |
|    106 | Valli       | Pataballa   |  4800.00 |  6000.0000 |
|    107 | Diana       | Lorentz     |  4200.00 |  5250.0000 |
|    108 | Nancy       | Greenberg   | 12000.00 | 15000.0000 |
|    109 | Daniel      | Faviet      |  9000.00 | 11250.0000 |
|    110 | John        | Chen        |  8200.00 | 10250.0000 |
|    111 | Ismael      | Sciarra     |  7700.00 |  9625.0000 |
|    112 | Jose Man^elC -- query aborted
l | Urman       |  7800.00 |  9750.0000 |
+--------+-------------+-------------+----------+------------+
107 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,
    -> SALARY + COMISSION_PCT AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT = 20;
ERROR 1054 (42S22): Unknown column 'COMISSION_PCT' in 'field list'
mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,
    -> SALARY + COMISSTION_PCT AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT = 20;
ERROR 1054 (42S22): Unknown column 'COMISSTION_PCT' in 'field list'
mysql> DESC EMPLOYEES;
+----------------+--------------+------+-----+---------+-------+
| Field          | Type         | Null | Key | Default | Extra |
+----------------+--------------+------+-----+---------+-------+
| employee_id    | int unsigned | NO   | PRI | NULL    |       |
| first_name     | varchar(20)  | YES  |     | NULL    |       |
| last_name      | varchar(25)  | NO   |     | NULL    |       |
| email          | varchar(25)  | NO   |     | NULL    |       |
| phone_number   | varchar(20)  | YES  |     | NULL    |       |
| hire_date      | date         | NO   |     | NULL    |       |
| job_id         | varchar(10)  | NO   | MUL | NULL    |       |
| salary         | decimal(8,2) | NO   |     | NULL    |       |
| commission_pct | decimal(2,2) | YES  |     | NULL    |       |
| manager_id     | int unsigned | YES  | MUL | NULL    |       |
| department_id  | int unsigned | YES  | MUL | NULL    |       |
+----------------+--------------+------+-----+---------+-------+
11 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,
    -> SALARY + COMMISSION_PCT AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT = 20;
ERROR 1054 (42S22): Unknown column 'DEPARTMENT' in 'where clause'
mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,
    -> SALARY + COMMISSION_PCT AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT_ID = 20;
+-------------+------------+-----------+-----------+--------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | OLDSALARY | SALCOM |
+-------------+------------+-----------+-----------+--------+
|         201 | Michael    | Hartstein |  13000.00 |   NULL |
|         202 | Pat        | Fay       |   6000.00 |   NULL |
+-------------+------------+-----------+-----------+--------+
2 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,COMMISSION_PCT AS COMM,
    -> SALARY + COMMISSION_PCT AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT_ID = 20;
+-------------+------------+-----------+-----------+------+--------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | OLDSALARY | COMM | SALCOM |
+-------------+------------+-----------+-----------+------+--------+
|         201 | Michael    | Hartstein |  13000.00 | NULL |   NULL |
|         202 | Pat        | Fay       |   6000.00 | NULL |   NULL |
+-------------+------------+-----------+-----------+------+--------+
2 rows in set (0.00 sec)

mysql> SELECT
    -> EMPLOYEE_ID, FIRST_NAME,LAST_NAME,
    -> SALARY AS OLDSALARY,COMMISSION_PCT AS COMM,
    -> SALARY + IFNULL(COMMISSION_PCT,0) AS SALCOM
    -> FROM EMPLOYEES
    -> WHERE DEPARTMENT_ID = 20;
+-------------+------------+-----------+-----------+------+----------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | OLDSALARY | COMM | SALCOM   |
+-------------+------------+-----------+-----------+------+----------+
|         201 | Michael    | Hartstein |  13000.00 | NULL | 13000.00 |
|         202 | Pat        | Fay       |   6000.00 | NULL |  6000.00 |
+-------------+------------+-----------+-----------+------+----------+
2 rows in set (0.00 sec)

mysql> Select upper('rahul');
+----------------+
| upper('rahul') |
+----------------+
| RAHUL          |
+----------------+
1 row in set (0.01 sec)

mysql> Select upper('Rahul');
+----------------+
| upper('Rahul') |
+----------------+
| RAHUL          |
+----------------+
1 row in set (0.00 sec)

mysql> Select lower('Rahul');
+----------------+
| lower('Rahul') |
+----------------+
| rahul          |
+----------------+
1 row in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> UPPER(FIRST_NAME) in ('PAT','JOHN');
+-------------+------------+-----------+---------+--------------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email   | phone_number       | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+---------+--------------------+------------+------------+----------+----------------+------------+---------------+
|         110 | John       | Chen      | JCHEN   | 515.124.4269       | 1997-09-28 | FI_ACCOUNT |  8200.00 |           NULL |        108 |           100 |
|         139 | John       | Seo       | JSEO    | 650.121.2019       | 1998-02-12 | ST_CLERK   |  2700.00 |           NULL |        123 |            50 |
|         145 | John       | Russell   | JRUSSEL | 011.44.1344.429268 | 1996-10-01 | SA_MAN     | 14000.00 |           0.40 |        100 |            80 |
|         202 | Pat        | Fay       | PFAY    | 603.123.6666       | 1997-08-17 | MK_REP     |  6000.00 |           NULL |        201 |            20 |
+-------------+------------+-----------+---------+--------------------+------------+------------+----------+----------------+------------+---------------+
4 rows in set (0.01 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> UPPER(FIRST_NAME) NOT IN ('PAT','JOHN');
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name   | email    | phone_number       | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
|         100 | Steven      | King        | SKING    | 515.123.4567       | 1987-06-17 | AD_PRES    | 24000.00 |           NULL |       NULL |            90 |
|         101 | Neena       | Kochhar     | NKOCHHAR | 515.123.4568       | 1989-09-21 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         102 | Lex         | De Haan     | LDEHAAN  | 515.123.4569       | 1993-01-13 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         103 | Alexander   | Hunold      | AHUNOLD  | 590.423.4567       | 1990-01-03 | IT_PROG    |  9000.00 |           NULL |        102 |            60 |
|         104 | Bruce       | Ernst       | BERNST   | 590.423.4568       | 1991-05-21 | IT_PROG    |  6000.00 |           NULL |        103 |            60 |
|         105 | David       | Austin      | DAUSTIN  | 590.423.4569       | 1997-06-25 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         106 | Valli       | Pataballa   | VPATABAL | 590.423.4560       | 1998-02-05 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         107 | Diana       | Lorentz     | DLORENTZ | 590.423.5567       | 1999-02-07 | IT_PROG    |  4200.00 |           NULL |        103 |            60 |
|         108 | Nancy       | Greenberg   | NGREENBE | 515.124.4569       | 1994-08-17 | FI_MGR     | 12000.00 |           NULL |        101 |           100 |
|         109 | Daniel      | Faviet      | DFAVIET  | 515.124.4169       | 1994-08-16 | FI_ACCOUNT |  9000.00 |           NULL |        108 |           100 |
|         111 | Ismael      | Sciarra     | ISCIARRA | 515.124.4369       | 1997-09-30 | FI_ACCOUNT |  7700.00 |           NULL |        108 |           100 |
|         112 | Jose Manuel | Urman       | JMURMAN  | 515.124.4469       | 1998-03-07 | FI_ACCOUNT |  7800.00 |           NULL |        108 |           100 |
|         113 | Luis        | Popp        | LPOPP    | 515.124.4567       | 1999-12-07 | FI_ACCOUNT |  6900.00 |           NULL |        108 |           100 |
|         114 | Den         | Raphaely    | DRAPHEAL | 515.127.4561       | 1994-12-07 | PU_MAN     | 11000.00 |           NULL |        100 |            30 |
|         115 | Alexander   | Khoo        | AKHOO    | 515.127.4562       | 1995-05-18 | PU_CLERK   |  3100.00 |           NULL |        114 |            30 |
|         116 | Shelli      | Baida       | SBAIDA   | 515.127.4563       | 1997-12-24 | PU_CLERK   |  2900.00 |           NULL |        114 |            30 |
|         117 | Sigal       | Tobias      | STOBIAS  | 515.127.4564       | 1997-07-24 | PU_CLERK   |  2800.00 |           NULL |        114 |            30 |
|         118 | Guy         | Himuro      | GHIMURO  | 515.127.4565       | 1998-11-15 | PU_CLERK   |  2600.00 |           NULL |        114 |            30 |
|         119 | Karen       | Colmenares  | KCOLMENA | 515.127.4566       | 1999-08-10 | PU_CLERK   |  2500.00 |           NULL |        114 |            30 |
|         120 | Matthew     | Weiss       | MWEISS   | 650.123.1234       | 1996-07-18 | ST_MAN     |  8000.00 |           NULL |        100 |            50 |
|         121 | Adam        | Fripp       | AFRIPP   | 650.123.2234       | 1997-04-10 | ST_MAN     |  8200.00 |           NULL |        100 |            50 |
|         122 | Payam       | Kaufling    | PKAUFLIN | 650.123.3234       | 1995-05-01 | ST_MAN     |  7900.00 |           NULL |        100 |            50 |
|         123 | Shanta      | Vollman     | SVOLLMAN | 650.123.4234       | 1997-10-10 | ST_MAN     |  6500.00 |           NULL |        100 |            50 |
|         124 | Kevin       | Mourgos     | KMOURGOS | 650.123.5234       | 1999-11-16 | ST_MAN     |  5800.00 |           NULL |        100 |            50 |
|         125 | Julia       | Nayer       | JNAYER   | 650.124.1214       | 1997-07-16 | ST_CLERK   |  3200.00 |           NULL |        120 |            50 |
|  C -- query aborted
        126 | Irene       | Mikkilineni | IMIKKILI | 650.124.1224       | 1998-09-28 | ST_CLERK   |  2700.00 |           NULL |        120 |            50 |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
103 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE FIRST_NAME LIKE 'A%';
+-------------+------------+-----------+----------+--------------------+------------+----------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email    | phone_number       | hire_date  | job_id   | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+----------+--------------------+------------+----------+----------+----------------+------------+---------------+
|         103 | Alexander  | Hunold    | AHUNOLD  | 590.423.4567       | 1990-01-03 | IT_PROG  |  9000.00 |           NULL |        102 |            60 |
|         115 | Alexander  | Khoo      | AKHOO    | 515.127.4562       | 1995-05-18 | PU_CLERK |  3100.00 |           NULL |        114 |            30 |
|         121 | Adam       | Fripp     | AFRIPP   | 650.123.2234       | 1997-04-10 | ST_MAN   |  8200.00 |           NULL |        100 |            50 |
|         147 | Alberto    | Errazuriz | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN   | 12000.00 |           0.30 |        100 |            80 |
|         158 | Allan      | McEwen    | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP   |  9000.00 |           0.35 |        146 |            80 |
|         167 | Amit       | Banda     | ABANDA   | 011.44.1346.729268 | 2000-04-21 | SA_REP   |  6200.00 |           0.10 |        147 |            80 |
|         175 | Alyssa     | Hutton    | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP   |  8800.00 |           0.25 |        149 |            80 |
|         185 | Alexis     | Bull      | ABULL    | 650.509.2876       | 1997-02-20 | SH_CLERK |  4100.00 |           NULL |        121 |            50 |
|         187 | Anthony    | Cabrio    | ACABRIO  | 650.509.4876       | 1999-02-07 | SH_CLERK |  3000.00 |           NULL |        121 |            50 |
|         196 | Alana      | Walsh     | AWALSH   | 650.507.9811       | 1998-04-24 | SH_CLERK |  3100.00 |           NULL |        124 |            50 |
+-------------+------------+-----------+----------+--------------------+------------+----------+----------+----------------+------------+---------------+
10 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE FIRST_NAME LIKE '%AS%'
    -> ;
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
| employee_id | first_name | last_name | email   | phone_number | hire_date  | job_id   | salary  | commission_pct | manager_id | department_id |
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
|         133 | Jason      | Mallin    | JMALLIN | 650.127.1934 | 1996-06-14 | ST_CLERK | 3300.00 |           NULL |        122 |            50 |
|         199 | Douglas    | Grant     | DGRANT  | 650.507.9844 | 2000-01-13 | SH_CLERK | 2600.00 |           NULL |        124 |            50 |
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
2 rows in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE FIRST_NAME = '%AS%'
    -> ;
Empty set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE FIRST_NAME LIKE '%L'
    -> ;
+-------------+-------------+------------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name  | email    | phone_number | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+------------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
|         109 | Daniel      | Faviet     | DFAVIET  | 515.124.4169 | 1994-08-16 | FI_ACCOUNT |  9000.00 |           NULL |        108 |           100 |
|         111 | Ismael      | Sciarra    | ISCIARRA | 515.124.4369 | 1997-09-30 | FI_ACCOUNT |  7700.00 |           NULL |        108 |           100 |
|         112 | Jose Manuel | Urman      | JMURMAN  | 515.124.4469 | 1998-03-07 | FI_ACCOUNT |  7800.00 |           NULL |        108 |           100 |
|         117 | Sigal       | Tobias     | STOBIAS  | 515.127.4564 | 1997-07-24 | PU_CLERK   |  2800.00 |           NULL |        114 |            30 |
|         134 | Michael     | Rogers     | MROGERS  | 650.127.1834 | 1998-08-26 | ST_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         136 | Hazel       | Philtanker | HPHILTAN | 650.127.1634 | 2000-02-06 | ST_CLERK   |  2200.00 |           NULL |        122 |            50 |
|         143 | Randall     | Matos      | RMATOS   | 650.121.2874 | 1998-03-15 | ST_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         191 | Randall     | Perkins    | RPERKINS | 650.505.4876 | 1999-12-19 | SH_CLERK   |  2500.00 |           NULL |        122 |            50 |
|         194 | Samuel      | McCain     | SMCCAIN  | 650.501.3876 | 1998-07-01 | SH_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         201 | Michael     | Hartstein  | MHARTSTE | 515.123.5555 | 1996-02-17 | MK_MAN     | 13000.00 |           NULL |        100 |            20 |
+-------------+-------------+------------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
10 rows in set (0.00 sec)

mysql> SELECT
    -> *
    ->  FROM
    -> EMPLOYEES
    -> WHERE
    -> FIRST_NAME LIKE '__G%';
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
| employee_id | first_name | last_name | email   | phone_number | hire_date  | job_id   | salary  | commission_pct | manager_id | department_id |
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
|         117 | Sigal      | Tobias    | STOBIAS | 515.127.4564 | 1997-07-24 | PU_CLERK | 2800.00 |           NULL |        114 |            30 |
+-------------+------------+-----------+---------+--------------+------------+----------+---------+----------------+------------+---------------+
1 row in set (0.00 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 80
    -> ORDER BY SALARY;
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name  | email    | phone_number       | hire_date  | job_id | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
|         173 | Sundita     | Kumar      | SKUMAR   | 011.44.1343.329268 | 2000-04-21 | SA_REP |  6100.00 |           0.10 |        148 |            80 |
|         179 | Charles     | Johnson    | CJOHNSON | 011.44.1644.429262 | 2000-01-04 | SA_REP |  6200.00 |           0.10 |        149 |            80 |
|         167 | Amit        | Banda      | ABANDA   | 011.44.1346.729268 | 2000-04-21 | SA_REP |  6200.00 |           0.10 |        147 |            80 |
|         166 | Sundar      | Ande       | SANDE    | 011.44.1346.629268 | 2000-03-24 | SA_REP |  6400.00 |           0.10 |        147 |            80 |
|         165 | David       | Lee        | DLEE     | 011.44.1346.529268 | 2000-02-23 | SA_REP |  6800.00 |           0.10 |        147 |            80 |
|         161 | Sarath      | Sewall     | SSEWALL  | 011.44.1345.529268 | 1998-11-03 | SA_REP |  7000.00 |           0.25 |        146 |            80 |
|         155 | Oliver      | Tuvault    | OTUVAULT | 011.44.1344.486508 | 1999-11-23 | SA_REP |  7000.00 |           0.15 |        145 |            80 |
|         164 | Mattea      | Marvins    | MMARVINS | 011.44.1346.329268 | 2000-01-24 | SA_REP |  7200.00 |           0.10 |        147 |            80 |
|         172 | Elizabeth   | Bates      | EBATES   | 011.44.1343.529268 | 1999-03-24 | SA_REP |  7300.00 |           0.15 |        148 |            80 |
|         171 | William     | Smith      | WSMITH   | 011.44.1343.629268 | 1999-02-23 | SA_REP |  7400.00 |           0.15 |        148 |            80 |
|         154 | Nanette     | Cambrault  | NCAMBRAU | 011.44.1344.987668 | 1998-12-09 | SA_REP |  7500.00 |           0.20 |        145 |            80 |
|         160 | Louise      | Doran      | LDORAN   | 011.44.1345.629268 | 1997-12-15 | SA_REP |  7500.00 |           0.30 |        146 |            80 |
|         153 | Christopher | Olsen      | COLSEN   | 011.44.1344.498718 | 1998-03-30 | SA_REP |  8000.00 |           0.20 |        145 |            80 |
|         159 | Lindsey     | Smith      | LSMITH   | 011.44.1345.729268 | 1997-03-10 | SA_REP |  8000.00 |           0.30 |        146 |            80 |
|         177 | Jack        | Livingston | JLIVINGS | 011.44.1644.429264 | 1998-04-23 | SA_REP |  8400.00 |           0.20 |        149 |            80 |
|         176 | Jonathon    | Taylor     | JTAYLOR  | 011.44.1644.429265 | 1998-03-24 | SA_REP |  8600.00 |           0.20 |        149 |            80 |
|         175 | Alyssa      | Hutton     | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP |  8800.00 |           0.25 |        149 |            80 |
|         152 | Peter       | Hall       | PHALL    | 011.44.1344.478968 | 1997-08-20 | SA_REP |  9000.00 |           0.25 |        145 |            80 |
|         158 | Allan       | McEwen     | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP |  9000.00 |           0.35 |        146 |            80 |
|         163 | Danielle    | Greene     | DGREENE  | 011.44.1346.229268 | 1999-03-19 | SA_REP |  9500.00 |           0.15 |        147 |            80 |
|         151 | David       | Bernstein  | DBERNSTE | 011.44.1344.345268 | 1997-03-24 | SA_REP |  9500.00 |           0.25 |        145 |            80 |
|         157 | Patrick     | Sully      | PSULLY   | 011.44.1345.929268 | 1996-03-04 | SA_REP |  9500.00 |           0.35 |        146 |            80 |
|         170 | Tayler      | Fox        | TFOX     | 011.44.1343.729268 | 1998-01-24 | SA_REP |  9600.00 |           0.20 |        148 |            80 |
|         150 | Peter       | Tucker     | PTUCKER  | 011.44.1344.129268 | 1997-01-30 | SA_REP | 10000.00 |           0.30 |        145 |            80 |
|         156 | Janette     | King       | JKING    | 011.44.1345.429268 | 1996-01-30 | SA_REP | 10000.00 |           0.35 |        146 |            80 |
|         169 | Harrison    | Bloom      | HBLOOM   | 011.44.1343.829268 | 1998-03-23 | SA_REP | 10000.00 |           0.20 |        148 |            80 |
|         149 | Eleni       | Zlotkey    | EZLOTKEY | 011.44.1344.429018 | 2000-01-29 | SA_MAN | 10500.00 |           0.20 |        100 |            80 |
|         162 | Clara       | Vishney    | CVISHNEY | 011.44.1346.129268 | 1997-11-11 | SA_REP | 10500.00 |           0.25 |        147 |            80 |
|         174 | Ellen       | Abel       | EABEL    | 011.44.1644.429267 | 1996-05-11 | SA_REP | 11000.00 |           0.30 |        149 |            80 |
|         148 | Gerald      | Cambrault  | GCAMBRAU | 011.44.1344.619268 | 1999-10-15 | SA_MAN | 11000.00 |           0.30 |        100 |            80 |
|         168 | Lisa        | Ozer       | LOZER    | 011.44.1343.929268 | 1997-03-11 | SA_REP | 11500.00 |           0.25 |        148 |            80 |
|         147 | Alberto     | Errazuriz  | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN | 12000.00 |           0.30 |        100 |            80 |
|         146 | Karen       | Partners   | KPARTNER | 011.44.1344.467268 | 1997-01-05 | SA_MAN | 13500.00 |           0.30 |        100 |            80 |
|         145 | John        | Russell    | JRUSSEL  | 011.44.1344.429268 | 1996-10-01 | SA_MAN | 14000.00 |           0.40 |        100 |            80 |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
34 rows in set (0.01 sec)

mysql> SELECT
    -> *
    -> FROM
    -> EMPLOYEES
    -> WHERE
    -> DEPARTMENT_ID = 80
    -> ORDER BY SALARY DESC;
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name  | email    | phone_number       | hire_date  | job_id | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
|         145 | John        | Russell    | JRUSSEL  | 011.44.1344.429268 | 1996-10-01 | SA_MAN | 14000.00 |           0.40 |        100 |            80 |
|         146 | Karen       | Partners   | KPARTNER | 011.44.1344.467268 | 1997-01-05 | SA_MAN | 13500.00 |           0.30 |        100 |            80 |
|         147 | Alberto     | Errazuriz  | AERRAZUR | 011.44.1344.429278 | 1997-03-10 | SA_MAN | 12000.00 |           0.30 |        100 |            80 |
|         168 | Lisa        | Ozer       | LOZER    | 011.44.1343.929268 | 1997-03-11 | SA_REP | 11500.00 |           0.25 |        148 |            80 |
|         148 | Gerald      | Cambrault  | GCAMBRAU | 011.44.1344.619268 | 1999-10-15 | SA_MAN | 11000.00 |           0.30 |        100 |            80 |
|         174 | Ellen       | Abel       | EABEL    | 011.44.1644.429267 | 1996-05-11 | SA_REP | 11000.00 |           0.30 |        149 |            80 |
|         149 | Eleni       | Zlotkey    | EZLOTKEY | 011.44.1344.429018 | 2000-01-29 | SA_MAN | 10500.00 |           0.20 |        100 |            80 |
|         162 | Clara       | Vishney    | CVISHNEY | 011.44.1346.129268 | 1997-11-11 | SA_REP | 10500.00 |           0.25 |        147 |            80 |
|         150 | Peter       | Tucker     | PTUCKER  | 011.44.1344.129268 | 1997-01-30 | SA_REP | 10000.00 |           0.30 |        145 |            80 |
|         156 | Janette     | King       | JKING    | 011.44.1345.429268 | 1996-01-30 | SA_REP | 10000.00 |           0.35 |        146 |            80 |
|         169 | Harrison    | Bloom      | HBLOOM   | 011.44.1343.829268 | 1998-03-23 | SA_REP | 10000.00 |           0.20 |        148 |            80 |
|         170 | Tayler      | Fox        | TFOX     | 011.44.1343.729268 | 1998-01-24 | SA_REP |  9600.00 |           0.20 |        148 |            80 |
|         151 | David       | Bernstein  | DBERNSTE | 011.44.1344.345268 | 1997-03-24 | SA_REP |  9500.00 |           0.25 |        145 |            80 |
|         157 | Patrick     | Sully      | PSULLY   | 011.44.1345.929268 | 1996-03-04 | SA_REP |  9500.00 |           0.35 |        146 |            80 |
|         163 | Danielle    | Greene     | DGREENE  | 011.44.1346.229268 | 1999-03-19 | SA_REP |  9500.00 |           0.15 |        147 |            80 |
|         152 | Peter       | Hall       | PHALL    | 011.44.1344.478968 | 1997-08-20 | SA_REP |  9000.00 |           0.25 |        145 |            80 |
|         158 | Allan       | McEwen     | AMCEWEN  | 011.44.1345.829268 | 1996-08-01 | SA_REP |  9000.00 |           0.35 |        146 |            80 |
|         175 | Alyssa      | Hutton     | AHUTTON  | 011.44.1644.429266 | 1997-03-19 | SA_REP |  8800.00 |           0.25 |        149 |            80 |
|         176 | Jonathon    | Taylor     | JTAYLOR  | 011.44.1644.429265 | 1998-03-24 | SA_REP |  8600.00 |           0.20 |        149 |            80 |
|         177 | Jack        | Livingston | JLIVINGS | 011.44.1644.429264 | 1998-04-23 | SA_REP |  8400.00 |           0.20 |        149 |            80 |
|         153 | Christopher | Olsen      | COLSEN   | 011.44.1344.498718 | 1998-03-30 | SA_REP |  8000.00 |           0.20 |        145 |            80 |
|         159 | Lindsey     | Smith      | LSMITH   | 011.44.1345.729268 | 1997-03-10 | SA_REP |  8000.00 |           0.30 |        146 |            80 |
|         154 | Nanette     | Cambrault  | NCAMBRAU | 011.44.1344.987668 | 1998-12-09 | SA_REP |  7500.00 |           0.20 |        145 |            80 |
|         160 | Louise      | Doran      | LDORAN   | 011.44.1345.629268 | 1997-12-15 | SA_REP |  7500.00 |           0.30 |        146 |            80 |
|  C -- query aborted
        171 | William     | Smith      | WSMITH   | 011.44.1343.629268 | 1999-02-23 | SA_REP |  7400.00 |           0.15 |        148 |            80 |
+-------------+-------------+------------+----------+--------------------+------------+--------+----------+----------------+------------+---------------+
34 rows in set (0.00 sec)

mysql> SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40);
+---------------+----------+
| DEPARTMENT_ID | SALARY   |
+---------------+----------+
|            20 | 13000.00 |
|            20 |  6000.00 |
|            30 | 11000.00 |
|            30 |  3100.00 |
|            30 |  2900.00 |
|            30 |  2800.00 |
|            30 |  2600.00 |
|            30 |  2500.00 |
|            40 |  6500.00 |
+---------------+----------+
9 rows in set (0.00 sec)

mysql> SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40) ORDER BY DEPARTMENT_ID,SALARY;
+---------------+----------+
| DEPARTMENT_ID | SALARY   |
+---------------+----------+
|            20 |  6000.00 |
|            20 | 13000.00 |
|            30 |  2500.00 |
|            30 |  2600.00 |
|            30 |  2800.00 |
|            30 |  2900.00 |
|            30 |  3100.00 |
|            30 | 11000.00 |
|            40 |  6500.00 |
+---------------+----------+
9 rows in set (0.00 sec)

mysql> SELECT
    -> * FROM
    -> EMPLOYEES
    -> ORDER BY DEPARTMENT_ID ASC,SALARY DESC;
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name  | last_name   | email    | phone_number       | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
|         178 | Kimberely   | Grant       | KGRANT   | 011.44.1644.429263 | 1999-05-24 | SA_REP     |  7000.00 |           0.15 |        149 |          NULL |
|         200 | Jennifer    | Whalen      | JWHALEN  | 515.123.4444       | 1987-09-17 | AD_ASST    |  4400.00 |           NULL |        101 |            10 |
|         201 | Michael     | Hartstein   | MHARTSTE | 515.123.5555       | 1996-02-17 | MK_MAN     | 13000.00 |           NULL |        100 |            20 |
|         202 | Pat         | Fay         | PFAY     | 603.123.6666       | 1997-08-17 | MK_REP     |  6000.00 |           NULL |        201 |            20 |
|         114 | Den         | Raphaely    | DRAPHEAL | 515.127.4561       | 1994-12-07 | PU_MAN     | 11000.00 |           NULL |        100 |            30 |
|         115 | Alexander   | Khoo        | AKHOO    | 515.127.4562       | 1995-05-18 | PU_CLERK   |  3100.00 |           NULL |        114 |            30 |
|         116 | Shelli      | Baida       | SBAIDA   | 515.127.4563       | 1997-12-24 | PU_CLERK   |  2900.00 |           NULL |        114 |            30 |
|         117 | Sigal       | Tobias      | STOBIAS  | 515.127.4564       | 1997-07-24 | PU_CLERK   |  2800.00 |           NULL |        114 |            30 |
|         118 | Guy         | Himuro      | GHIMURO  | 515.127.4565       | 1998-11-15 | PU_CLERK   |  2600.00 |           NULL |        114 |            30 |
|         119 | Karen       | Colmenares  | KCOLMENA | 515.127.4566       | 1999-08-10 | PU_CLERK   |  2500.00 |           NULL |        114 |            30 |
|         203 | Susan       | Mavris      | SMAVRIS  | 515.123.7777       | 1994-06-07 | HR_REP     |  6500.00 |           NULL |        101 |            40 |
|         121 | Adam        | Fripp       | AFRIPP   | 650.123.2234       | 1997-04-10 | ST_MAN     |  8200.00 |           NULL |        100 |            50 |
|         120 | Matthew     | Weiss       | MWEISS   | 650.123.1234       | 1996-07-18 | ST_MAN     |  8000.00 |           NULL |        100 |            50 |
|         122 | Payam       | Kaufling    | PKAUFLIN | 650.123.3234       | 1995-05-01 | ST_MAN     |  7900.00 |           NULL |        100 |            50 |
|         123 | Shanta      | Vollman     | SVOLLMAN | 650.123.4234       | 1997-10-10 | ST_MAN     |  6500.00 |           NULL |        100 |            50 |
|         124 | Kevin       | Mourgos     | KMOURGOS | 650.123.5234       | 1999-11-16 | ST_MAN     |  5800.00 |           NULL |        100 |            50 |
|         184 | Nandita     | Sarchand    | NSARCHAN | 650.509.1876       | 1996-01-27 | SH_CLERK   |  4200.00 |           NULL |        121 |            50 |
|         185 | Alexis      | Bull        | ABULL    | 650.509.2876       | 1997-02-20 | SH_CLERK   |  4100.00 |           NULL |        121 |            50 |
|         192 | Sarah       | Bell        | SBELL    | 650.501.1876       | 1996-02-04 | SH_CLERK   |  4000.00 |           NULL |        123 |            50 |
|         193 | Britney     | Everett     | BEVERETT | 650.501.2876       | 1997-03-03 | SH_CLERK   |  3900.00 |           NULL |        123 |            50 |
|         188 | Kelly       | Chung       | KCHUNG   | 650.505.1876       | 1997-06-14 | SH_CLERK   |  3800.00 |           NULL |        122 |            50 |
|         137 | Renske      | Ladwig      | RLADWIG  | 650.121.1234       | 1995-07-14 | ST_CLERK   |  3600.00 |           NULL |        123 |            50 |
|         189 | Jennifer    | Dilly       | JDILLY   | 650.505.2876       | 1997-08-13 | SH_CLERK   |  3600.00 |           NULL |        122 |            50 |
|         141 | Trenna      | Rajs        | TRAJS    | 650.121.8009       | 1995-10-17 | ST_CLERK   |  3500.00 |           NULL |        124 |            50 |
|         186 | Julia       | Dellinger   | JDELLING | 650.509.3876       | 1998-06-24 | SH_CLERK   |  3400.00 |           NULL |        121 |            50 |
|         129 | Laura       | Bissot      | LBISSOT  | 650.124.5234       | 1997-08-20 | ST_CLERK   |  3300.00 |           NULL |        121 |            50 |
|         133 | Jason       | Mallin      | JMALLIN  | 650.127.1934       | 1996-06-14 | ST_CLERK   |  3300.00 |           NULL |        122 |            50 |
|         125 | Julia       | Nayer       | JNAYER   | 650.124.1214       | 1997-07-16 | ST_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         138 | Stephen     | Stiles      | SSTILES  | 650.121.2034       | 1997-10-26 | ST_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         180 | Winston     | Taylor      | WTAYLOR  | 650.507.9876       | 1998-01-24 | SH_CLERK   |  3200.00 |           NULL |        120 |            50 |
|         194 | Samuel      | McCain      | SMCCAIN  | 650.501.3876       | 1998-07-01 | SH_CLERK   |  3200.00 |           NULL |        123 |            50 |
|         142 | Curtis      | Davies      | CDAVIES  | 650.121.2994       | 1997-01-29 | ST_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         181 | Jean        | Fleaur      | JFLEAUR  | 650.507.9877       | 1998-02-23 | SH_CLERK   |  3100.00 |           NULL |        120 |            50 |
|         196 | Alana       | Walsh       | AWALSH   | 650.507.9811       | 1998-04-24 | SH_CLERK   |  3100.00 |           NULL |        124 |            50 |
|         187 | Anthony     | Cabrio      | ACABRIO  | 650.509.4876       | 1999-02-07 | SH_CLERK   |  3000.00 |           NULL |        121 |            50 |
|         197 | Kevin       | Feeney      | KFEENEY  | 650.507.9822       | 1998-05-23 | SH_CLERK   |  3000.00 |           NULL |        124 |            50 |
|         134 | Michael     | Rogers      | MROGERS  | 650.127.1834       | 1998-08-26 | ST_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         190 | Timothy     | Gates       | TGATES   | 650.505.3876       | 1998-07-11 | SH_CLERK   |  2900.00 |           NULL |        122 |            50 |
|         130 | Mozhe       | Atkinson    | MATKINSO | 650.124.6234       | 1997-10-30 | ST_CLERK   |  2800.00 |           NULL |        121 |            50 |
|         183 | Girard      | Geoni       | GGEONI   | 650.507.9879       | 2000-02-03 | SH_CLERK   |  2800.00 |           NULL |        120 |            50 |
|         195 | Vance       | Jones       | VJONES   | 650.501.4876       | 1999-03-17 | SH_CLERK   |  2800.00 |           NULL |        123 |            50 |
|         126 | Irene       | Mikkilineni | IMIKKILI | 650.124.1224       | 1998-09-28 | ST_CLERK   |  2700.00 |           NULL |        120 |            50 |
|         139 | John        | Seo         | JSEO     | 650.121.2019       | 1998-02-12 | ST_CLERK   |  2700.00 |           NULL |        123 |            50 |
|         143 | Randall     | Matos       | RMATOS   | 650.121.2874       | 1998-03-15 | ST_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         198 | Donald      | OConnell    | DOCONNEL | 650.507.9833       | 1999-06-21 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         199 | Douglas     | Grant       | DGRANT   | 650.507.9844       | 2000-01-13 | SH_CLERK   |  2600.00 |           NULL |        124 |            50 |
|         131 | James       | Marlow      | JAMRLOW  | 650.124.7234       | 1997-02-16 | ST_CLERK   |  2500.00 |           NULL |        121 |            50 |
|         140 | Joshua      | Patel       | JPATEL   | 650.121.1834       | 1998-04-06 | ST_CLERK   |  2500.00 |           NULL |        123 |            50 |
|         144 | Peter       | Vargas      | PVARGAS  | 650.121.2004       | 1998-07-09 | ST_CLERK   |  2500.00 |           NULL |        124 |            50 |
|         182 | Martha      | Sullivan    | MSULLIVA | 650.507.9878       | 1999-06-21 | SH_CLERK   |  2500.00 |           NULL |        120 |            50 |
|         191 | Randall     | Perkins     | RPERKINS | 650.505.4876       | 1999-12-19 | SH_CLERK   |  2500.00 |           NULL |        122 |            50 |
|         127 | James       | Landry      | JLANDRY  | 650.124.1334       | 1999-01-14 | ST_CLERK   |  2400.00 |           NULL |        120 |            50 |
|         135 | Ki          | Gee         | KGEE     | 650.127.1734       | 1999-12-12 | ST_CLERK   |  2400.00 |           NULL |        122 |            50 |
|         128 | Steven      | Markle      | SMARKLE  | 650.124.1434       | 2000-03-08 | ST_CLERK   |  2200.00 |           NULL |        120 |            50 |
|         136 | Hazel       | Philtanker  | HPHILTAN | 650.127.1634       | 2000-02-06 | ST_CLERK   |  2200.00 |           NULL |        122 |            50 |
|         132 | TJ          | Olson       | TJOLSON  | 650.124.8234       | 1999-04-10 | ST_CLERK   |  2100.00 |           NULL |        121 |            50 |
|         103 | Alexander   | Hunold      | AHUNOLD  | 590.423.4567       | 1990-01-03 | IT_P^OG   C -- query aborted
  |  9000.00 |           NULL |        102 |            60 |
+-------------+-------------+-------------+----------+--------------------+------------+------------+----------+----------------+------------+---------------+
107 rows in set (0.00 sec)

mysql> SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40) ORDER BY DEPARTMENT_ID,SALARY DESC;
+---------------+----------+
| DEPARTMENT_ID | SALARY   |
+---------------+----------+
|            20 | 13000.00 |
|            20 |  6000.00 |
|            30 | 11000.00 |
|            30 |  3100.00 |
|            30 |  2900.00 |
|            30 |  2800.00 |
|            30 |  2600.00 |
|            30 |  2500.00 |
|            40 |  6500.00 |
+---------------+----------+
9 rows in set (0.00 sec)

mysql> SELECT DEPARTMENT_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,30,40) ORDER BY DEPARTMENT_ID DESC,SALARY DESC
    -> ;
+---------------+----------+
| DEPARTMENT_ID | SALARY   |
+---------------+----------+
|            40 |  6500.00 |
|            30 | 11000.00 |
|            30 |  3100.00 |
|            30 |  2900.00 |
|            30 |  2800.00 |
|            30 |  2600.00 |
|            30 |  2500.00 |
|            20 | 13000.00 |
|            20 |  6000.00 |
+---------------+----------+
9 rows in set (0.00 sec)

mysql> SELECT DEPARTMENT_ID FROM EMPLOYEES;
+---------------+
| DEPARTMENT_ID |
+---------------+
|          NULL |
|            10 |
|            20 |
|            20 |
|            30 |
|            30 |
|            30 |
|            30 |
|            30 |
|            30 |
|            40 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            50 |
|            60 |
|            60 |
|            60 |
|            60 |
|            60 |
|            70 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            80 |
|            90 |
|            90 |
|            90 |
|           100 |
|           100 |
|           100 |
|           100 |
|           100 |
|           100 |
|           110 |
|           110 |
+---------------+
107 rows in set (0.00 sec)

mysql> SELECT DISTINCT DEPARTMENT_ID FROM EMPLOYEES;
+---------------+
| DEPARTMENT_ID |
+---------------+
|          NULL |
|            10 |
|            20 |
|            30 |
|            40 |
|            50 |
|            60 |
|            70 |
|            80 |
|            90 |
|           100 |
|           110 |
+---------------+
12 rows in set (0.00 sec)

mysql> SELECT DISTINCT DEPARTMENT_ID, SALARY FROM EMPLOYEES;
+---------------+----------+
| DEPARTMENT_ID | SALARY   |
+---------------+----------+
|            90 | 24000.00 |
|            90 | 17000.00 |
|            60 |  9000.00 |
|            60 |  6000.00 |
|            60 |  4800.00 |
|            60 |  4200.00 |
|           100 | 12000.00 |
|           100 |  9000.00 |
|           100 |  8200.00 |
|           100 |  7700.00 |
|           100 |  7800.00 |
|           100 |  6900.00 |
|            30 | 11000.00 |
|            30 |  3100.00 |
|            30 |  2900.00 |
|            30 |  2800.00 |
|            30 |  2600.00 |
|            30 |  2500.00 |
|            50 |  8000.00 |
|            50 |  8200.00 |
|            50 |  7900.00 |
|            50 |  6500.00 |
|            50 |  5800.00 |
|            50 |  3200.00 |
|            50 |  2700.00 |
|            50 |  2400.00 |
|            50 |  2200.00 |
|            50 |  3300.00 |
|            50 |  2800.00 |
|            50 |  2500.00 |
|            50 |  2100.00 |
|            50 |  2900.00 |
|            50 |  3600.00 |
|            50 |  3500.00 |
|            50 |  3100.00 |
|            50 |  2600.00 |
|            80 | 14000.00 |
|            80 | 13500.00 |
|            80 | 12000.00 |
|            80 | 11000.00 |
|            80 | 10500.00 |
|            80 | 10000.00 |
|            80 |  9500.00 |
|            80 |  9000.00 |
|            80 |  8000.00 |
|            80 |  7500.00 |
|            80 |  7000.00 |
|            80 |  7200.00 |
|            80 |  6800.00 |
|            80 |  6400.00 |
|            80 |  6200.00 |
|            80 | 11500.00 |
|            80 |  9600.00 |
|            80 |  7400.00 |
|            80 |  7300.00 |
|            80 |  6100.00 |
|            80 |  8800.00 |
|            80 |  8600.00 |
|            80 |  8400.00 |
|          NULL |  7000.00 |
|            50 |  4200.00 |
|            50 |  4100.00 |
|            50 |  3400.00 |
|            50 |  3000.00 |
|            50 |  3800.00 |
|            50 |  4000.00 |
|            50 |  3900.00 |
|            10 |  4400.00 |
|            20 | 13000.00 |
|            20 |  6000.00 |
|            40 |  6500.00 |
|            70 | 10000.00 |
|           110 | 12000.00 |
|           110 |  8300.00 |
+---------------+----------+
74 rows in set (0.00 sec)

mysql> SELECT * FROM EMPLOYEES LIMIT 1;
+-------------+------------+-----------+-------+--------------+------------+---------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email | phone_number | hire_date  | job_id  | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+-------+--------------+------------+---------+----------+----------------+------------+---------------+
|         100 | Steven     | King      | SKING | 515.123.4567 | 1987-06-17 | AD_PRES | 24000.00 |           NULL |       NULL |            90 |
+-------------+------------+-----------+-------+--------------+------------+---------+----------+----------------+------------+---------------+
1 row in set (0.00 sec)

mysql> SELECT * FROM EMPLOYEES LIMIT 10;
+-------------+------------+-----------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email    | phone_number | hire_date  | job_id     | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
|         100 | Steven     | King      | SKING    | 515.123.4567 | 1987-06-17 | AD_PRES    | 24000.00 |           NULL |       NULL |            90 |
|         101 | Neena      | Kochhar   | NKOCHHAR | 515.123.4568 | 1989-09-21 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         102 | Lex        | De Haan   | LDEHAAN  | 515.123.4569 | 1993-01-13 | AD_VP      | 17000.00 |           NULL |        100 |            90 |
|         103 | Alexander  | Hunold    | AHUNOLD  | 590.423.4567 | 1990-01-03 | IT_PROG    |  9000.00 |           NULL |        102 |            60 |
|         104 | Bruce      | Ernst     | BERNST   | 590.423.4568 | 1991-05-21 | IT_PROG    |  6000.00 |           NULL |        103 |            60 |
|         105 | David      | Austin    | DAUSTIN  | 590.423.4569 | 1997-06-25 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         106 | Valli      | Pataballa | VPATABAL | 590.423.4560 | 1998-02-05 | IT_PROG    |  4800.00 |           NULL |        103 |            60 |
|         107 | Diana      | Lorentz   | DLORENTZ | 590.423.5567 | 1999-02-07 | IT_PROG    |  4200.00 |           NULL |        103 |            60 |
|         108 | Nancy      | Greenberg | NGREENBE | 515.124.4569 | 1994-08-17 | FI_MGR     | 12000.00 |           NULL |        101 |           100 |
|         109 | Daniel     | Faviet    | DFAVIET  | 515.124.4169 | 1994-08-16 | FI_ACCOUNT |  9000.00 |           NULL |        108 |           100 |
+-------------+------------+-----------+----------+--------------+------------+------------+----------+----------------+------------+---------------+
10 rows in set (0.00 sec)

mysql> SELECT * FROM EMPLOYEES LIMIT 2,4;
+-------------+------------+-----------+---------+--------------+------------+---------+----------+----------------+------------+---------------+
| employee_id | first_name | last_name | email   | phone_number | hire_date  | job_id  | salary   | commission_pct | manager_id | department_id |
+-------------+------------+-----------+---------+--------------+------------+---------+----------+----------------+------------+---------------+
|         102 | Lex        | De Haan   | LDEHAAN | 515.123.4569 | 1993-01-13 | AD_VP   | 17000.00 |           NULL |        100 |            90 |
|         103 | Alexander  | Hunold    | AHUNOLD | 590.423.4567 | 1990-01-03 | IT_PROG |  9000.00 |           NULL |        102 |            60 |
|         104 | Bruce      | Ernst     | BERNST  | 590.423.4568 | 1991-05-21 | IT_PROG |  6000.00 |           NULL |        103 |            60 |
|         105 | David      | Austin    | DAUSTIN | 590.423.4569 | 1997-06-25 | IT_PROG |  4800.00 |           NULL |        103 |            60 |
+-------------+------------+-----------+---------+--------------+------------+---------+----------+----------------+------------+---------------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM EMPLOYEES LIMIT 4,4;
+-------------+------------+-----------+----------+--------------+------------+---------+---------+----------------+------------+---------------+
| employee_id | first_name | last_name | email    | phone_number | hire_date  | job_id  | salary  | commission_pct | manager_id | department_id |
+-------------+------------+-----------+----------+--------------+------------+---------+---------+----------------+------------+---------------+
|         104 | Bruce      | Ernst     | BERNST   | 590.423.4568 | 1991-05-21 | IT_PROG | 6000.00 |           NULL |        103 |            60 |
|         105 | David      | Austin    | DAUSTIN  | 590.423.4569 | 1997-06-25 | IT_PROG | 4800.00 |           NULL |        103 |            60 |
|         106 | Valli      | Pataballa | VPATABAL | 590.423.4560 | 1998-02-05 | IT_PROG | 4800.00 |           NULL |        103 |            60 |
|         107 | Diana      | Lorentz   | DLORENTZ | 590.423.5567 | 1999-02-07 | IT_PROG | 4200.00 |           NULL |        103 |            60 |
+-------------+------------+-----------+----------+--------------+------------+---------+---------+----------------+------------+---------------+
4 rows in set (0.00 sec)



							
								DAY 5 
								
								
TOPICS :
		
		SELECT , CREATE  , ALTER, DROP 
					INSERT , UPDATE , DELETE 
							COMMIT , ROLLBACK 
							
		OPERATORS 
				
				RATIONAL 
				LOGICAL 
				AIRTHEMETIC 
							
	
		SELECT 
			* 
				FROM 
					TABLE NAME 
						WHERE 
							CONDITION 
							AND 
							CONDITION 
									ORDER BY COLUMN NAME 
					
			
			** WHERE CLAUSE EXECUTED FIRST
			** ORDER BY ALWAYS BE THE LAST CLAUSE 
			
=======================================================================


INBUILD FUNCTIONS : 

			1) NUMERIC FUNCTION 
			2) STRING FUNCTION 
			3) DATE FUNCTION
			4) AGGREGATED FUNCTION OR GROUP FUNCTION
			
		
1) NUMERIC FUNCTION : 
			
				* ROUND() :
						WHICH RETURN THE ROUND OFF VALUE PROVIDED 
						
					>= 5 UPPER VALUE 
					< 5  LOWER VALUE 
					
				36.45  ::: ROUND(36.45)  :: 36
				36.56  ::: ROUND(36.56)  :: 37
				
				ROUND FUNCTION COMES WITH 2 PARAMENTERS 
				
				ROUND(VALUE,PLACE TILL WHICH WE NEED TO ROUND OFF)
				
				2ND PARAMTER :
					+ : SHIFT TOWARDS RIGHT OF THE DECIMAL AND THEN PERFORM ROUND OFF 
					- : SHIFT TOWARDS LEFT OF THE DECIMAL AND PERFORM ROUND OFF 
				
		ROUND(34.5676,2) : 
				* SKIP TWO PLACES FROM THE DECIMAL AND THEN PERFORM ROUND 
				
			ROUND(34.5676,2) :	34.57
		
		ROUND(345.345,-2) : 
					* SKIP 2 PLACES LEFT OF THE DECIMAL 
					
				
			ROUND(345.345,-2) :	300
				
		
		* CEIL
			RETURNS THE UPPER INTEGER VALUES BASED ON THE DECIMAL PROVIDED 			
			
			345.34  : 346
			
			34.23  : 35
			
		* FLOOR 
			RETURNS THE NEAREST LOWER VALUE 
			
				34.78  : 34 
				35.23  : 35
				
		* TRUNCATE 
			TRUNCATE FUNCTION HAS 2 PARAMETERS 
				BASED ON THE 2ND PARAMETER IT REMOVES THE VALUES AFTER THE NUMBER PROVIDED IN THE 2ND PARAMETER 
				
				
				TRUNCATE(345.567,1) : 345.5
				TRUNCATE(345.567,2) : 345.56
				TRUNCATE(345.567,0) : 345
				TRUNCATE(345.567,-2) : 300
			
			
		* / , DIV 

			SELECT 34 DIV 3; 11  : RETUNS VALUE WITHOUT DECIMALS 
			SELECT 34/3 :  11.333
			
		
		* MOD : MODULUS 
			
				5 MOD 2 
					: 	RETURNS REMINDER 
					
				MOD(5,2) : 1 AS REMINDER 

		* SQRT : 
			SQUARE ROOT OF 4 : 2
			
			SQRT(16) : 4 
			SQRT(9)  : 3
			
			
THESE VALUES EITHER PASSED MANUALLY BY THE END USER OR THEY MAY COMES FROM THE TABLE COLUMN ALSO 


2) STRING FUNCTIONS : 
	
		1) LENGTH OF THE STRING : RETUNS THE LENGTH 
		
			SELECT LENGTH('RAHUL BANSAL');

			
		2) UPPER :
				STRINGS IN TO UPPER CASE 

		3) LOWER : 
				STRING TO LOWER CASE 
				
		4) COMBINE TWO STRING 
			MOST OF THE CASES REQUIRED FOR NAMES 
			
			PRINT ON MOBILES BILL OR ELECTRICITY BILLS 
			
			RAHUL BANSAL 
			RAHUL, BANSAL 
			BANSAL, RAHUL 
			
			CONCAT(ACCEPT STRINGS WHICH NEED TO CONCAT);
			
			SELECT CONCAT('NAME OF THE PERSON IS :', 'RAHUL',', ','BANSAL');
			
		5) SUBSTRING : RETURNS THE SUBSTRING FROM THE MAIN STRING 

			3 PARAMTERS 
				1ST PARAM : ORINAL STRING 
				2ND PARAM : START OF THE STRING 
				3RD PARAM : LENGHT AFTER 2ND PARAM
				
				
			SUBSTR('RAHUL',3,2);
		
		6)TRIM : 
				HAVE SPACES STORED IN THE BASES 
					
				TRIM(STRINGS) : REMOVES THE SPACES FROM THE FRONT N BACK OF THE STRING 

					'    RAHUL  BANSAL   ' : RAHUL  BANSAL
					
		7) LPAD : 
			LEFT PADDING 

			TO MAKE THE COMPETE STRING OF THE SAME LENGTH 
			
			3 PARAM 
				1ST PARAM : VALUE  5
				2ND PARAM : LENGTH REQUIRED FOR THE COMPLETE STRING  10
				3RD PARAM : REST 5 POSITION REPLACED WITH THE 3RD PARAMETER STRING 
				
				LPAD('RAHUL',10,'*');
					*****RAHUL
			

		8) RPAD
			RIGHT PADDING 
					
				RPAD('RAHUL',10,'*');	
					
					RAHUL*****
					
					
					
		9) REPLACE 
			: TO REPLACE THE CERTAIN STRING WITH THE SPECIFIED VALUE IN THE ORIGINAL STRING 
			
			
				SELECT REPLACE('RAHUL,BANSAL',',','');	
					
3) DATE FUNCTION 
					
			1) NOW() 
				RETURNS TODAYS DATETIME
				
			2) CURDATE() 
					RETUNRS DATE WITHOUT TIME 
					
			3) CURTIME() 
					RETURNS TIME WITHOUT DATE 
					
			4) DATE_FORMAT 
					
					DATE INTO SPECIFIC FORMAT BASED ON THE REQUIREMENTS 
					
				KEYWORDS : 
				
					%d  : day of the month
					%D  : day with english sufix 
							28th
							3rd
							9th
							2nd 
					%m : month 
					
					%M : full month name 
					
					%y : 2 digit from year 
					
					%Y : full year 
					
					%h : hours in 12 
					
					%H : hours with 24 
					
					%i : minutes 
					
					%s : seconds 
					
					%b retuns three characters of the month
				
				
				
				2 parameters 
					1st parameter  : always be the date 
					2nd param : pattern needed
					
					
					
				date_format(hire_date,'%d/%m/%Y %h:%i:%s')

					string 
				select date_format(hire_date,'%D %M, %y %h:%i:%s') from employees limit 10;	
				
				+---------------------------------------------+
				| date_format(hire_date,'%D %M, %y %h:%i:%s') |
				+---------------------------------------------+
				| 17th June, 87 12:00:00                      |
				| 21st September, 89 12:00:00                 |
				| 13th January, 93 12:00:00                   |
				| 3rd January, 90 12:00:00                    |
				| 21st May, 91 12:00:00                       |
				| 25th June, 97 12:00:00                      |
				| 5th February, 98 12:00:00                   |
				| 7th February, 99 12:00:00                   |
				| 17th August, 94 12:00:00                    |
				| 16th August, 94 12:00:00                    |
				+---------------------------------------------+
			
			
	SYSTEM ALLOWS TO PERFORM AIRTHMETIC OPERATION ON THE DATES 

		AFTER ONE MONTH WHAT COULD BE MY DATE 
		
			ORACLE : 
				
					SELECT NOW() + 30;
					
			MYSQL : 
				
					SELECT NOW() + INTERVAL 30 DAY;
					
					DAYS, MONTH , YEAR , WEEK 
					HOUR
					
			5) DAY_ADD()

			6) DAY_SUB()
			
			7) YEAR, MONTH, DAY 
				EXTRACT YEAR , MONTH AND DAY FROM THE DATE 
				
			SELECT EMPLOYEE_ID,YEAR(HIRE_DATE) AS "JOINED YEAR" FROM EMPLOYEES LIMIT 10;
					
			8) STRING TO DATE 

				STR_TO_DATE(STRING,PATTERNS);
				
				Select str_to_date('30-01-1987','%d-%m-%Y')
				
			9) DATEDIFF()
					TWO DATES 
					DATEDIFF(NOW(),HIRE_DATE)
				
			mysql> SELECT TRUNCATE(DATEDIFF(NOW(),HIRE_DATE)/365,0) "EXPERIENCE" FROM EMPLOYEES LIMIT 10;
			+------------+
			| EXPERIENCE |
			+------------+
			|         34 |
			|         31 |
			|         28 |
			|         31 |
			|         30 |
			|         24 |
			|         23 |
			|         22 |
			|         26 |
			|         26 |
			+------------+
			10 rows in set (0.00 sec)				
SOME MORE FUCNTION 

	** CASE 
			
		USED FOR COMPARISON WITH MULTIPLE VALUE AND RETURN STRING BASED ON THE CONDITION SATISFIED 
		
		SYNTAX : 
		
			CASE 
			WHEN CONDITION THEN RETURN VALUE
			WHEN CONDITION THEN RETURN VALUE
			WHEN CONDITION THEN RETURN VALUE
			.
			.
			ELSE
			
			END 
					
		EXAMPLE 
			NEED TO PRESENT A REPORT 
				
				SALARY > 15000 THEN DISPLAY GRADE A 
				SALARY > 8000 AND SALARY < 15000 THEN DISPLAY GRADE B 
				SALARY < 8000 THEN DISPLAY GRADE C 
				
				
				
				SELECT EMPLOYEE_ID AS EMPID,CONCAT(FIRST_NAME,', ',LAST_NAME) AS NAME,SALARY, 	
					CASE 
						WHEN SALARY > 15000 THEN 'GRADE A'
						WHEN SALARY > 8000 AND SALARY <= 15000 THEN 'GRADE B' 
						ELSE 'GRADE C'
					END
					AS GRADE
				FROM EMPLOYEES 
					LIMIT 10;
				
	-------------------------------------------------------------			
				
		IFNULL : 
		
		
AGGREGATED FUNCTIONS : ALWAYS RETUN SINGLE VALUE 

			GROUP FUNCTIONS 
				ARE THE FUNCTIONS WORK ON THE SET OF VALUES 
				
					
			* FIND NO OF EMPLOYEES IN THE ORGANIZATION 

				COUNT(*) 
					: RETUNS TOTAL NUMBER OF ROWS PRESENT IN THE TABLE 
					
					
				COUNT(COMMISSION_PCT) 
					: RETUNRS TOTAL NUMBER ROWS EXCEPT NULL VALUE 
						SKIP NULL VALUE 
						
			* SUM(COLUMN NAME)	
				: SUBMISSION OF ALL THE INTERGER VALUES 
				
				EXACT EXPENDITURE FOR THE ORGANIZATION IN TERM OF SALARY 

					SELECT SUM(SALARY) FROM EMPLOYEES;
				
			* MAX VALUE FROM THE SET OF VALUES 
				
				
			* MIN VALUE FROM THE SET OF VALUES 
			
			
	-------------- 20 MINUTE BREAK ------------------

		TOPICS :
			GROUP BY CLAUSE 
				HAVING 
					
	------------------------------------------------------------------


	FUNCTION : AGGREGATED FUNCTION / GROUP FUNCTION 
	
	1) FIND THE CONSOLIDATE SALARY FOR ALL EMPLOYEES 
		SUM(SALARY) 
		
	
	*** 
		PROVIDE SALARIES BASED ON THE DEPARTMENTS 
		
			FIND CONSOLIDATE SALAYE GIVING TO EACH DEPARTMENT 
			
		
		DEPARTMENT ID : 20,30,40,80 
		
			SELECT SUM(SALARY) FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = 80;
				
			SELECT SUM(SALARY) FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = 40;

			SELECT SUM(SALARY) FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = 20;
		
		
				OR 
				
			HUGE DATA TO PERFORM SUCH ACTION, ITS LITTLE DIFFICULT TO DO MANUAL STUFF 
			
			SO THEY INTRODUCE 
				CLASUE : GROUP BY 
				
			GROUP BY : 
					GROUPING OF CERTAIN DATA
				
			SYNTAX : 
				
					GROUP BY COLUMN NAME 
					
						1 GROUPING 
						2 GROUP BASED ON THE COLUMN NAME PROVIDED 
						
			
		SELECT DEPARTMENT_ID,SUM(SALARY)

				FROM 
					EMPLOYEES 
						GROUP BY DEPARTMENT_ID
		
		
		mysql> SELECT EMPLOYEE_ID, FIRST_NAME,SALARY,DEPARTMENT_ID FROM EMPLOYEES WHERE DEPARTMENT_ID IN (20,60);
		+-------------+------------+----------+---------------+
		| EMPLOYEE_ID | FIRST_NAME | SALARY   | DEPARTMENT_ID |
		+-------------+------------+----------+---------------+
		|         201 | Michael    | 13000.00 |            20 |
		|         202 | Pat        |  6000.00 |            20 |
		|         103 | Alexander  |  9000.00 |            60 |
		|         104 | Bruce      |  6000.00 |            60 |
		|         105 | David      |  4800.00 |            60 |
		|         106 | Valli      |  4800.00 |            60 |
		|         107 | Diana      |  4200.00 |            60 |
		+-------------+------------+----------+---------------+
		
		
		
		GROUP BY CLASE EXECUTED IN 4 STEPS :-
		
		1) BRINGS ALL THE COLUMNS REQUIRED FOR CALCULATION OR OPERATION IN TO TEMP MEMORY 
		+-------------+------------+----------+---------------+
		| EMPLOYEE_ID | FIRST_NAME | SALARY   | DEPARTMENT_ID |
		+-------------+------------+----------+---------------+
		|         201 | Michael    | 13000.00 |            20 |
		|         202 | Pat        |  6000.00 |            20 |
		|         103 | Alexander  |  9000.00 |            60 |
		|         104 | Bruce      |  6000.00 |            60 |
		|         105 | David      |  4800.00 |            60 |
		|         106 | Valli      |  4800.00 |            60 |
		|         107 | Diana      |  4200.00 |            60 |
		+-------------+------------+----------+---------------+
				
		2) SORTING BASED ON THE COLUMN PROVIDED IN THE GROUP BY CLAUSE 
		+-------------+------------+----------+---------------+
		| EMPLOYEE_ID | FIRST_NAME | SALARY   | DEPARTMENT_ID |
		+-------------+------------+----------+---------------+
		|         201 | Michael    | 13000.00 |            20 |
		|         202 | Pat        |  6000.00 |            20 |
		|         103 | Alexander  |  9000.00 |            60 |
		|         104 | Bruce      |  6000.00 |            60 |
		|         105 | David      |  4800.00 |            60 |
		|         106 | Valli      |  4800.00 |            60 |
		|         107 | Diana      |  4200.00 |            60 |
		+-------------+------------+----------+---------------+
		
		3) CREATES GROUPS BASED ON THE COLUMN PROVIDED IN THE GROUP BY CLAUSE 
		
		G1
		+-------------+------------+----------+---------------+
		| EMPLOYEE_ID | FIRST_NAME | SALARY   | DEPARTMENT_ID |
		+-------------+------------+----------+---------------+
		|         201 | Michael    | 13000.00 |            20 |
		|         202 | Pat        |  6000.00 |            20 |
		+-------------+------------+----------+---------------+
		
		G2
		+-------------+------------+----------+---------------+
		| EMPLOYEE_ID | FIRST_NAME | SALARY   | DEPARTMENT_ID |
		+-------------+------------+----------+---------------+		
		|         103 | Alexander  |  9000.00 |            60 |
		|         104 | Bruce      |  6000.00 |            60 |
		|         105 | David      |  4800.00 |            60 |
		|         106 | Valli      |  4800.00 |            60 |
		|         107 | Diana      |  4200.00 |            60 |
		+-------------+------------+----------+---------------+
			
					
		4) EXECUTE THE GROUP OR AGGREGATE FUNCTION ON THE GROUPS 
			
			
			G1 : 19000
			
			G2 : 28800
			
		5) CREATE A TABLE WITH REQUIRED DATA FOR OUTPUT AND SENT 

			DEPARTMENT_ID 		SUM(SALARY)
			20					19000
			60					28800
			
			
		CERTAINS RULES FOR GROUP BY :-

			1) ALL THE COLUMNS INCLUDED IN THE SELECT ELSE THEN THE GROUP FUNCTION COLUMN , NEED TO BE A PART OF GROUP BY CLAUSE 
			
			SELECT JOB_ID,DEPARTMENT_ID, SUM(SALARY) 
					FROM  
						EMPLOYEES 
							GROUP BY JOB_ID,DEPARTMENT_ID
				
				
			** SMALL CATCH :
					MYSQL DOESN'T FORCE THE ABOVE RULES 
					
					
				SELECT JOB_ID,DEPARTMENT_ID, SUM(SALARY) 
					FROM  
						EMPLOYEES 
							GROUP BY DEPARTMENT_ID


					WHAT HAPPEN IN THIS CASE 
						
	
				SELECT FIRST_NAME,DEPARTMENT_ID, SUM(SALARY) 
					FROM EMPLOYEES 
						GROUP BY DEPARTMENT_ID;


			ORACLE,POSTGRESS DOESN'T ALLOW TO EXECUTE THE ABOVE QUERY ....


			2) ALL THE COLUMNS PART OF THE GROUP BY CLAUSE, MAY OR MAY NOT BE THE PART OF SELECT 
				
				SELECT SUM(SALARY) 
					FROM EMPLOYEES 
						GROUP BY DEPARTMENT_ID;	

--------------------------------------------------------------------------

SEQUEANCE OF THE SELECT STATEMENT : 


	SELECT ------MANDATORY
		* 
			FROM  ------MANDATORY
				TABLENAME 
					WHERE  ------ NOT MANDATORY
						GROUP BY CLAUSE  ------ NOT MANDATORY 
							ORDER BY   ------ NOT MANDATORY

---------------------------------------------------------------------

* IF WE WANT FILTERS ON TOP OF THE OUTPUT FROM THE SELECT QUERY 
	
				HAVING CLAUSE 
					: CLAUSE IS USED TO PROVIDE FILTER ON THE OUTPUT 
					
				
			
	** NEED ALL THOSE DEPARTMENT WHO ARE GETTING CONSOLIDATE SALARY GREATER THEN 12000.....

		* DEPARTMENT WISE SALARY 
			SUM(SALARY) BASED ON DEPARTMENT 
				GROUP BY DEPARTMENT_ID 
				
		* OUTPUT : FILTER ON SUM(SALARY) > 12000 
		
		
		
		SELECT DEPARTMENT_ID, SUM(SALARY) AS CSAL
			FROM 
				EMPLOYEES   
					GROUP BY DEPARTMENT_ID
						HAVING SUM(SALARY) > 12000;
						
--------------------------------------------------------------------------

			ALL THESE AGGREGATED / GROUP FUNCTION 
				CAN NOT BE A PART OF YOUR WHERE CLAUSE 
				
					* AS WE ALREADY SAID WHERE IS THE FIRST CLAUSE NEED TO BE EXECUTED 
						
		
FOR ME : 

		SELECT 				------------------------MANDATORY
			COLUMN SEPERATED BY COMMA 
				FROM 		------------------------MANDATORY
					TABLE NAME 
						WHERE-----------------------NOT MANDATORY
							** FILTER ON THE PHYSICAL LOCATION OF THE TABLES AND BRINGS DATA IN THE TEP MEM FOR FURTHER EXECUTION
							CONDITION 
								GROUP BY ------------NOT MANDATORY
								** CREATES GROUP FOR EXECUTION OF GROUP FUNCTIONS
									COLUMNS 
										HAVING -----NOT MANDATORY
										** FILTER ON THE OUTPUT 
											CONDITION 
												ORDER BY----NOT MANDATORY
													** SORTING OF THE DATA
													COLUMN 



	mysql> SELECT DEPARTMENT_ID, SUM(SALARY) AS CSAL
			-> FROM
				-> EMPLOYEES
					-> WHERE SALARY > 2000
						-> GROUP BY DEPARTMENT_ID
							-> HAVING CSAL > 15000
									-> ORDER BY CSAL DESC;
									
									
					+---------------+-------------+
					| DEPARTMENT_ID | SUM(SALARY) |
					+---------------+-------------+
					|            80 |   304500.00 |
					|            50 |   156400.00 |
					|            90 |    58000.00 |
					|           100 |    51600.00 |
					|            60 |    28800.00 |
					|            30 |    24900.00 |
					|           110 |    20300.00 |
					|            20 |    19000.00 |
					+---------------+-------------+
					8 rows in set (0.01 sec)


		* ORACLE : ALIAS ONLY ALLOWED IN THE ORDER BY CLAUSE 
						

====================================================================

	SELECT COUNT(*) FROM (
		SELECT DEPARTMENT_ID, SUM(SALARY) AS CSAL
		    FROM
				EMPLOYEES
				WHERE SALARY > 5000
				GROUP BY DEPARTMENT_ID
				HAVING CSAL > 15000
					)T ;
					ORDER BY CSAL DESC;




				
								DAY 6
								
TOPICS COVERED : 
		
			INBUILD FUNCTIONS 
						
			GROUP BY CLAUSE 
				HAVING CLAUSE 
				
----------------------------------------------------------------------------

SINGLE TABLE 

	FETCH THE RECORDS FROM THE MULTIPLE TABLES 
		
			JOINS: 
				USED TO COMBINE TWO OR MORE TABLES 
					AND RETURN THE COMBINATION OF ALL THE COLUMNS FROM ALL THE TABLES 
				
				
			EMP 
				EMPID 
				EMPNAME
				EMPSALARY 
				DEPTID 
				
			DEPT 
				DEPTID 
				DEPTNAME
				DEPTLOC 
		
			** EMP + DEPT  - AFTER JOINING
				
					EMPID 
					EMPNAME
					EMPSALARY 
					DEPTID
					DEPTID 
					DEPTNAME
					DEPTLOC
				
			CERTIAN SET OF RULES :
				
					1) USER MUST INCLUDE N-1 CONDITION TO JOIN N TABLES 
					IF WE HAVE 2 TABLES TO JOIN 
						THERE MUST BE A CONDITION FOR JOINING THESE TABLES 

					3 TABLE - 2 CONDITION 
					4 TABLE - 3 CONDITION 
					
					**
					
					2) USER CAN PROVIDE AN ALIAS TO THE TABLE NAME AS WELL 
						LIKE WE PROVIDE THE ALIAS TO THE COLUMNS 
							SIMILAR WAY WE CAN PROVIDE ALIAS TO THE TABLES 
							
						
					FIRST_NAME AS NAME
					
					
					SELECT * FROM EMPLOYEES E1;
					
					E1 IS ANOTHER NAME TO THE TABLE EMPLOYEES FOR THE CURRENT QUERY 

					CERTAIN COLUMN 

						SELECT E1.FIRST_NAME,E1.SALARY 
							FROM 
								EMPLOYEES E1;
								
						{
							VAR I = 34;
							STRING VAR1 = 'RAHUL'
						}
						OBJ O1 
						
						O1.I
						O1.VAR1
						
------------------------------------------------------------------- 
							
							KEY WORD : JOIN 
						
						
				TABLE1 JOIN TABLE2 
				
				
VARIOUS TYPE OF JOIN :- 

*** NEED TO FETCH ALL THE RECORDS FROM EMPLOYEES AND DEPARTMENTS BASED ON THE CONDITION DEPARTMENT_ID OF EMPLOYEE MATCHES WITH DEPARTMENT_ID OF THE DEPARTMENTS 

	** NEED TO FETCH EMPLOYEES DETAILS WITH THERE DEPARTMENT NAMES....
	
		CONDITION : DEPARTMENT_ID EMP AND DEPT 
		
INNER JOIN : 
		
			* JOIN WHICH RETURN THE ROWS MATCHES THE CONDITION 
		
		SYNTAX : 
			
	SELECT 
		* 
		FROM 
			EMPLOYEES 
			INNER JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
						
		----------------------------------------------------				
			CREATE TABLE EMPDAC1
			(
			ID INT,
			NAME VARCHAR(20),
			SALARY INT,
			DEPTID INT
			);
			
			CREATE TABLE DEPTDAC1
			(
			DEPTID INT,
			DEPTNAME VARCHAR(20)
			);
			
			INSERT INTO EMPDAC1 VALUES(101,'RAHUL',5000,10),(102,'RITESH',6000,20),(103,'SUNITA',7000,30),(104,'KUMAR',5000,40),(105,'JITESH',9000,50);
			
			
			INSERT INTO DEPTDAC1 VALUES(10,'HR'),(20,'MARKETING'),(30,'FINANCE'),(40,'DEVELOPERS'),(60,'RESOURCE POOL');
								
								
								
			SELECT 
				* 
				FROM 
					EMPDAC1 
					INNER JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;					
														
			SELECT 
				* 
				FROM 
				 EMPDAC1 
					JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;		

----------------------------------------------------------------------
	
	SELECT 
		*
		FROM 
			EMPDAC1,DEPTDAC1
			WHERE 
				EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
-----------------------------------------------------------------------


						
INNER JOIN : 
				BASED ON THE CONDITION IT RETURNS THE COMMAN RECORDS 
				
------------------------------------------------------------------------

2) OUTER JOIN 
		- LEFT JOIN  - LEFT OUTER JOIN
		- RIGHT JOIN  - RIGHT OUTER JOIN 
		
	LEFT JOIN : 
				* RETURNS COMMAN RECORDS BASED ON THE CONDITION
				* + RETURN ALL THE RECORDS LEFT IN THE LEFT SIDE TABLE 
				WITH RIGHT SIDE TABLE COLUMN AS NULL VALUE 
				
		SELECT * 
			FROM 
				EMPDAC1
					LEFT JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
		OLDER SYNTAX : 
		
		SELECT * 
			FROM 
				EMPDAC1,(+)DEPTDAC1 
					WHERE EMPDAC1.DEPTID = DEPTDAC1.DEPTID;		
				
-------------------------------------------------------------------------

	RIGHT JOIN : 

			* RETUENS ALL THE COMMAN RECORDS BASED ON THE CONDITIONS 
			* + RETURNS ALL THE LEFT DATA FROM THE RIGHT SIDE TABLE 
			
		SELECT * 
			FROM 
				EMPDAC1 
				RIGHT JOIN DEPTDAC1 ON EMPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
				
-------------------------------------------------------------------------
					
	NEED EMPLOYEE NAME, ID,SALARY , DEPARTMENT_NAME FROM THE HRDATABASE ;
	
	
		SELECT 
			CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME ,
				E1.EMPLOYEE_ID, E1.SALARY,D1.DEPARTMENT_NAME
			FROM 
				EMPLOYEES E1 
					INNER JOIN DEPARTMENTS D1 
						ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;
				
					
		SELECT 
			CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME ,
				E1.EMPLOYEE_ID, E1.SALARY,D1.DEPARTMENT_NAME
			FROM 
				EMPLOYEES E1 
					LEFT JOIN DEPARTMENTS D1 
						ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;			
					
					
	-================================================================

4) CROSS JOIN 

			* A JOIN WITHOUT ANY CONDITIONS 
			* RETURNS ME THE CARTESIAN PRODUCT OF THE TWO TABLES 
			
			
			SELECT * FROM EMPDAC1 JOIN DEPTDAC1 ORDER BY ID;
			
			JOIN - NEVER EVER USED IN THE INDUSTRY...
			
			CONCEPT IS VERY IMPORTANT 
				 
				 N TABLES AND N-1 CONDITION 
				 
					IN ANY SCENARION IF YOU MISSING  THE CONDITION 
						FOR JOINING TAWO TABLES 
							INTERNALLY IT WILL NOT THROW ERROR 
								BUT RETURN CATESIAN PRODUCT 
								
								
---------------------------------------------------------------------------

LET TAKE A BREAK FOR 20 MINUTE 
							9:30 
								
								
	-----------------------------------------------------------------

		JOIN : INNER JOIN 
				OUTER JOIN 
					LEFT OUTER JOIN 
					RIGHT OUTER JOIN 
				CROSS JOIN 
				
	** ORACLE : 
			ITS OWN JOIN NAMED A NATURAL JOIN 
			
			
			* NATURAL JOIN DOES NOT COMES WITH CONDITION 
			* IT INTERNALLY MANAGE TO HAVE A CONDITION 
				IT CHECK THE TABLE COLUMN NAME OF BOTH THE TABLES 
					AND 
					IF SOME COLUMN NAMES ARE COMMAN THEN 
						IT PICK THOSE COLUMNS AS A CONDITION FOR NATURAL JOIN 
						
	BASICALLY  : 
	
	EMP 							DEPT
	EMPID 							DEPTID 
	EMPNAME							DEPTNAME
	EMPSAL 
	DEPTID 
								
								
				SYTAX  

		SELECT 
			* FROM 
				EMPDAC1 
				NATURAL JOIN DEPTDAC1;
				
		CONVERT THE ABOVE SNTAX INTERNALLY 

		SELECT 
			* FROM 
				EMPDAC1 
				JOIN DEPTDAC1 ON ENPDAC1.DEPTID = DEPTDAC1.DEPTID;
				
				
		COLUMNS MATCHED 
			CONDITION WITH AND OPERATOR 
			
			* IF ANYCASE NONE OF THE COLUMNS NAME MATCHES
				THEN DO THE CROSS JOIN BETWEEN THE TABLES 
				
				
			* AS THIS JOIN HANDELED BY THE SYSTEM : 
				IT AUTOMATICALLY SQUEZE THE DUPLICATE COLUMN AS WELL 
				
			
			
			
			
		 SELECT * FROM EMPLOYEES E1 JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID;


		SELECT * FROM EMPLOYEES E1 NATURAL JOIN DEPARTMENTS D1	 
			
		SELECT * FROM EMPLOYEES E1 
		JOIN DEPARTMENTS D1 
		ON 
		E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
		AND 
		E1.MANAGER_ID = D1.MANAGER_ID;	
			
			
	----------------------------------------------------------------------

6) SELF JOIN 
	
			BASICALLY THIS IS USED WHEN WE HAVE A RALATION SHIP OR A LOGIC BETWEEN TWO COLUMNS OF THE SAME TABLE 
			
			SIGLE TABLE 
					THERE MUST BE TWO COLUMN WHICH ARE SOMEHOW RELATES TO EACH OTHER 
					
			EXAMPLE 
				EMPLOYEES 
					EMPLOYEE_ID 
					FIRST_NAME 
					LAST_NAME 
					SALARY 
					MANAGER_ID 
			
			TABLE : ALL THE EMPLOYEES MUST HAVE A EMPLOYEE ID 
					EITHER ITS TERTER, DEVELOPER, LEAD, MANGAER, STAFF......
					
					MANAGER > LEADING A TEAM OF MEMBERS 
					
					101 RAHUL 8000 REPORTGIN TO RITESH 
					103 RITESH 900000 REPORTING TO NIKHIL 
					104 NIKHIL 3400000 -----
					
					101 RAHUL 8000    103
					103 RITESH 900000 104
					104 NIKHIL 3400000 NULL
					
		*** 
			PROVIDES A REPORT WITH EMPLOYEES DETAILS AND THEIR MANAGER NAMES 
			STPE 1 : 
			
					101 RAHUL 8000    103
					
			STEP 2: 
					MANAGER ID 103 
					
			STEP 3 : 
						CHECK WITH EMPLOYEE TABLE EMPLOYEE_ID COLUMN 
						
						
			STEP 4 : 
					 103 RITESH 900000 104
			
			
			STEP 5 : COMBINATION OF STEP 1 AND STEP 4 
				
					
				101 RAHUL 8000    103    	103 RITESH 900000 104
				
	-------------------------------------------------------------


		SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,E1.SALARY,
					E2.FIRST_NAME AS MANAGERNAME			
				FROM 
					EMPLOYEES E1
						INNER JOIN EMPLOYEES E2 ON E1.MANAGER_ID = E2.EMPLOYEE_ID;
						
-------------------------------------------------------------------------

CONSIDERING WE MAY MULTIPLE JOIN AND THERE MAY BE MANY TABLE EXIST WHICH ARE RELATION SHIPS 

QUESTION 1) 

NEED TO FIND ALL THE RECORDS OF THE EMPLOYEES WITH THIR DEPARTMENTNAME , LOCATION AND BELONGING COUNTRY ....
	JUST MAKE SURE TO RETURN ON DEPARTMENTS 20,40,80

	1) 
	EMPLOYEES  
		>>>> DEPARTMENT_ID 
	DEPARTMETS
		>>>>  LOCATION_ID
	LOCATIONS
		>>>> COUNTRY_ID 
	COUNTRIES 
	2) CONDITION 
		20,40,80 
	
	
	
	
SELECT E1.FIRST_NAME,E1.SALARY,E1.DEPARTMENT_ID,D1.DEPARTMENT_NAME,
	L1.street_address, L1.city,C1.country_name			
	FROM 
	EMPLOYEES E1 
	INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
	INNER JOIN LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID 
	INNER JOIN COUNTRIES C1 ON L1.COUNTRY_ID = C1.COUNTRY_ID
	WHERE D1.DEPARTMENT_ID IN (20,40,80)
	ORDER BY E1.FIRST_NAME
						
						
	EXECUTION PLAN : 
			1) WHERE CLAUSE NEED TO BE EXECUTED FIRST 
			2) PULL DEPARTMENT TABLE IN TO TEMP WITH ONLY RECORDS 20,40,80 
			3) REST OF ALL THE TABLE , EMPLOYEES, COUNTRIES, LOCATIONS 
				be a part of temp memory 
			4) EMP WITH DEPT - T1 
			5) T1 JOIN LOCATION - T2 
			6) T2 JOIN COUNTRIES - T3 
			7) ORDER BY PERFORMED ON T3 
			8) RETURN T3 AS AN OUTPUT FOR CONSOLE 
			9) FREE TEMP MEMORY T1,T2,T3,EMPLOYEES, DEPARMTNET, LOCATION, COUNTRIES 
			
			
			
			
			
						
						
						
						
						
						
						
						
						
						
------------------------------------------------------------------------
OLDER SYNTAX : 

SELECT E1.FIRST_NAME,E1.SALARY,E1.DEPARTMENT_ID,D1.DEPARTMENT_NAME,
	L1.street_address, L1.city,C1.country_name			
	FROM 
	EMPLOYEES E1,DEPARTMENTS D1,LOCATIONS L1,COUNTRIES C1
	WHERE 
		E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
		AND 
		D1.LOCATION_ID = L1.LOCATION_ID
		AND 
		L1.COUNTRY_ID = C1.COUNTRY_ID
		AND 
		D1.DEPARTMENT_ID IN (20,40,80)
	ORDER BY E1.FIRST_NAME

-------------------------------------------------------------------------


*** 

	INNER JOIN 
			EQUIJOIN   ---- CONDITION WITH EQUALS OPERATORS 
			E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
			
			NON EQUIJOIN 
			JOIN PERFORMED BASED ON SOME OTHER OPERATORS THEN EQUALS 
			
			EMPLOYEES AND SALGRADE 
			
			E1.SALARY BETWEEN S1.LOWSALARY AND S1.HIGHSALARY
				
	OUTER JOIN 
			RIGHT JOIN  AND RIGHT OUTER JOIN 
			LEFT JOIN AND LEFT OUTER JOIN 
	NATURAL JOIN 
	CROSS JOIN 
	SELF JOIN 

*** FULL OUTER JOIN 
	
				WHICH IS A PART OF ORACLE 
				
		SELECT 
			* 
			FROM 
				EMPLOYEES E1
					FULL OUTER JOIN 
						DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					-
					-
					
		COMBINATION OF LEFT AND RIGHT 
		
		* RETURN ALL THE COMMAN RECORDS 
		* + RETURN ALL THE LEFT RECORDS IN THE LEFT SIDE TABLE 
		* + RETURN ALL THE LEFT RECORDS IN THE RIGHT SIDE TABLE 
		
		
		
		
		SELECT 
			* 
			FROM 
				EMPLOYEES E1
					FULL OUTER JOIN 
						DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID


		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
						
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
				
			
----- UNION AND UNION ALL 

		UNION AND UNION ALL ARE USED TO JOIN TWO OR MORE QUERIES OUTPUT 
			
			* NUMBER OF COLUMNS IN THE QUERIES MUST BE SAME 
			* STRUCTURE OF COLUMNS IN SELECT MUST BE SAME 
				-- ITS THE RESTRICTION OF STANDARIZED DATABASES...
					
			
		** 
			UNION : SQUEZE THE SIMILAR DATA 
					REMOVE THE DATA DUPLICACY 
			
			
		** 
			UNION ALL
					RETURN ALL THE ROWS 
					
					
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
		UNION		
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID;	
			
			
			
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					LEFT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID
		UNION ALL	
		
		SELECT 
			* 
			FROM 
				EMPDAC1 E1
					RIGHT JOIN 
						DEPTDAC1 D1 ON E1.DEPTID = D1.DID;		
			
			
--------------------------------------------------------------------------

	COMPLETE SYNTAX 
	
	
		
	SELECT 
		D1.DEPARTMENT_NAME,L1.STREET_ADDRESS,C1.COUNTRY_NAME,COUNT(*) EMPLOYEECOUNT,SUM(E1.SALARY) TOTALSALARY
		FROM 
			EMPLOYEES E1 
				INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
				INNER JOIN LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID 
				INNER JOIN COUNTRIES C1 ON L1.COUNTRY_ID = C1.COUNTRY_ID
					WHERE D1.DEPARTMENT_ID IN (20,40,80)
						GROUP BY D1.DEPARTMENT_NAME,L1.STREET_ADDRESS,C1.COUNTRY_NAME
							HAVING SUM(E1.SALARY) > 10000			
								ORDER BY TOTALSALARY
			
-------------------------------------------------------------------

JOINING TABLE :::


	SUBQUERIES : 
				ARE THE QUESRIES WHICH ARE THE PART OF THE MAIN QUERY 
				
				* SUB QUERY ALWAYS EXECUED FIRST 
				* RETURN THE OUTPUT IN THE BRACKET 
				* OUTER OR MAIN QUERY EXECUTED....
				
		
		*** 
			EXAMPLE : 
				NEED TO FIND ALL THE EMPLOYEES 
					BELONGS TO DEPARTMENT NAME Human Resources
					
				1) DEPARTMENT_ID OF DEPARTMENT NAMED AS Human Resources
				2) FIRE A QUERY ON EMPLOYEES TO COMPARE THE DEPARTMENT_ID 
				
			
		1) DEPARTMENT_ID OF DEPARTMENT NAMED AS Human Resources

			SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Human Resources';
			
		2) FIRE A QUERY ON EMPLOYEES TO COMPARE THE DEPARTMENT_ID 
			
			SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID = ???
			OUTPUT OF FIRST QUERY 
			
	CONCEPT OF SUBQUERY 

	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (
								SELECT DEPARTMENT_ID 
									FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Human Resources');
	
	EXECUTION l:
		
			SUBQUERY EXECUTED FIRST 
				AND REPLACE THE VALUES INLINE 
				
	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (40);		
				
				
				
	*** SUB QUERY RETURNING MORE THEN 1 VALUES 
		MAKE SURE NOT TO USE EQUALS OPERATOR 
		
			IN 
			
	SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
									FROM DEPARTMENTS WHERE DEPARTMENT_NAME IN ('Human Resources','Accounting'));		
	
			
		SELECT * FROM EMPLOYEES 
		WHERE DEPARTMENT_ID = (40,110);	
			
			
	SUBQUERIES : 
			AS A PART OF THE MAIN QUERY FOR EXECUTIONS 
			

				
			
		
								DAY 7
								
TOPICS COVERED: 
					
		TYPES OF JOIN :
				INNER 
				OUTER
				NATURAL
				SELF
				CROSS
				
				EQUIJOIN/NON EQUIJOIN 
				
	BASICALLY THESE ARE USED FOR GETTING DATA FROM DIFFERENT TABLES
	
	----------------------------------------------------------------
	
	NEED TO FIND THE EMPLOYEES WHOSE SALARY ID GREATER THEN THE SALARY OF THE AVERAGE SALARY OF DEPARTMENT 80 
	
		1) AVERAGE SALARY OF THE DEPARTMENT 80 
		
		SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80;
					80000
		2) FIND ALL THE EMPLOYEES WHOSE SALARY > SALARY RETURNED FROM STPE 1 
		
		SELECT * FROM EMPLOYEES WHERE SALARY > 80000;
		
		
	SUBQUERY : 
			IS A QUERY WHICH ENBADDED INSIDE THE OTHER QUERY 
			
			RULES : 
				1) SUBQUERY EXECUTED FIRST
				2) OUTPUT OF THE SUBQUERY REPLACED INLINE 
				3) MAIN QUERY EXECUTED
				
			** FEW THINGS 
					IF SUBQUERY RETURNS MORE THE ONE ROW 
						THEN WE CAN NOT COMPARE THOSE VALUES WITH THE HELP OF EQUALS TO OPERATOR 
					IN THIS SCENARIO WE ALWAYS USE IN OPERATOR 
					---- 
					
					IF WE ARE SURE THAT SUBQUERY WILL RETURN A SINGLE VALUE THEN WITHOUT ANY CONCERNS, WE CAN USE EQUALS OPERATOR.
					
			SELECT 
				COLUMN    ------ SUB QUERY 
					FROM 
						TABLES   ------ SUB QUERY 
							WHERE 
								CONDITION ------ SUB QUERY 
									GROUP BY 
										COLUMNS 
											HAVING 
												COLUMNS 
													ORDER BY 
														COLUMNS
															LIMIT 
				
					
	CONSIDERING A FACT OF SUBQUERY 
		WE ALWAYS USE OR ENTER SUBQUERY INSIDE THE BRACKETS 
			AS SUBQUERY NEED TO RETUN THE VALUES 
			
			**
					
		NEED TO FIND THE EMPLOYEES WHOSE SALARY ID GREATER THEN THE SALARY OF THE AVERAGE SALARY OF DEPARTMENT 80 
	
		1) AVERAGE SALARY OF THE DEPARTMENT 80 
		
		SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80;
					80000
		2) FIND ALL THE EMPLOYEES WHOSE SALARY > SALARY RETURNED FROM STPE 1 
		
		SELECT * FROM EMPLOYEES WHERE SALARY > 80000;			
					
		MERGE ABOVE QUERIES :- 

		SELECT 
			* 
			FROM 
				EMPLOYEES 
					WHERE 
						SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80);
					
			** SUBQUERY EXECUTED FIRST AND REPLACE THE QUERY WITH THE VALUE RETURNED FROM THE SUB QUERY 
	
			STEPS 1: 
			
			SELECT 
				* 
				FROM 
					EMPLOYEES 
						WHERE 
							SALARY > (8955.882353);
							
			STEP 2: 
				MAIN QUERY EXECUTED WITH THE INLINE VALUE 
				RETURNS ME THE EMPLOYEES DATA..
				
				
		** NO RESTRICTION OF HAVING HOW MANY SUB QUERIES 

			LIKE 
		NEED ALL THE EMPLOYEES 
			HAVING SALARY > AVG SALARY OF DEPARTMENT 80 
				AND BELONGS TO THE DEPARTMENTS IN LOCATION 1700 
				
		* NEED TO FIND AVG SALARY OF DEPARMTNET 80 
		
			SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80
		
		* NEED TO FIND ALL DEPARTMENT WORKING IN LOCATION 1700 
		
			SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = 1700
		
		* FIND ALL EMPLOYEES BASED ON 1, 2	
			
				
			
			SELECT * FROM 
				EMPLOYEES E1 
				INNER JOIN 
				DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
				WHERE 
				E1.SALARY > (SELECT AVG(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80)
				AND 
				D1.DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE LOCATION_ID = 1700);
					
--------------------------------------------------------------

THERE MAY BE SCENARIO WHERE I NEED TO COMPARE WITH OPERATORS LIKE > ,  <  WITH MULTIPLE VALUE 

		NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN THE SALARY OF DEPARTMENT 60
			
			* NEED TO FIND THE SALARY PROVIDED TO DEPARTMENT 60 
			
				SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60;
					MULTIPLE VALUES RETURNED 
			
			* COMPARE THE EMPLOYEES SALARY TO VALUES RETURN FROM 1 STPE 
			
			SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);
			
			EXECUTION HAPPEN: 
				
			SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > (9000,6000,4800,4200);
				
				
				
			*** 
				VARIOUS COMBINATION OPERATORS TO ACHIVE ABOVE COMPARISON 
				
				ANY / ALL 
				
				ANY : ANY ONE VALUE NEED TO BE SATISFIED 
				ALL : ALL THE VALUES NEED TO BE SATISFIED 
				
				* RULES 
					ANY AND ALL CAN BE USED IN THE COMBINATION OF OTHER OPERATORS LIKE 
						>, < , = 
				COBINATION OF ABOVE OPERATORS 

					> ANY -- IF THERE ARE MULTIPLE VALUES RETURNED FROM THE SUBQUERY THEN 
						COMPARISON WITH ANY VALUE IF TRUE THEN IT 
							RETURS THE ROW FROM THE MAIN QUERY 
							
							
					> ALL -- ALL NEED TO COMPARED AND SATISFIED 
						3000 > ALL (2000, 1000, 500, 5000) 
							- 3000 WILL NOT BE RETURNS AS 
								3000 > 5000
						3000 > ALL (2000, 1000, 500)
							IT RETUNS TRUE 
						
					< ANY 
					< ALL 
					= ANY
		
NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN THE SALARY OF DEPARTMENT 60
			
		SELECT MIN(SALARY) FROM EMPLOYEES 
				WHERE 
					SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);			
						
		EXECUTION: 
			STEP 1: 
				SELECT * FROM EMPLOYEES 
				WHERE 
					SALARY > ALL (9000,6000,4800,4200);	
					
			RAHUL 24000

				24000 > ALL (9000,6000,4800,4200);
						
						
NEED TO FIND ALL EMPLOYEES WHOSE SALARY 
			IS GREATER THEN ANY OF THE SALARY OF DEPARTMENT 60
			
		SELECT MIN(SALARY) FROM EMPLOYEES 
				WHERE 
					SALARY > ANY (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID  =60);						
						
						
-----------------------------------------------------------------------

					IN / ANY / ALL 
					
	SELECT S1 FROM T1 WHERE S1 >ANY (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 = ANY (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 IN (TABLE S2);			
	SELECT S1 FROM T1 WHERE S1 > ALL (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 < ALL (TABLE S2);
	SELECT S1 FROM T1 WHERE S1 <> ALL (TABLE S2);
	
	<> NOT EQUALS TO 
	
					SUBQUERY AS A PART OF WHERE CLAUSE 
					
------------------------------------------------------------------------
------------------------------------------------------------------------

2) SUB QUERY CAN BE A PART OF TABLE 
	
		SUBQUERIES 
			: THEY ALWAYS RETURN A TABLE AS AN OUTPUT 
				WITH ROWS AND COLUMN 
				
			* SUBQUERY NEED TO BE INCLUDED IN THE BRACKET 
			* WHEN SUBQUERY IS A PART OF TABLE 
				SYSTEM FORCE US TO NAME THAT TABLE 
				
		CONSIDERING AN EXAMPLE 
			
		NEED TO FIND ALL EMPLOYEES 
			WITH THE DEPARTMENT NAMES AND LOCATIONS 
				CONSIDERING THERE SALARY > MINIMUM SALARY OF DEPARTMENT 
					80 
					
					
		* FIND THE DETAILS OF EMPLOYEES 
			FROM EMPLOYEES , DEPARTMENTS AND LOCATIONS 
			
			SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID;
					
		----------- I AM TREATING ABOVE QUERY AS A SUBQUERY 

	SELECT * FROM 
			(SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID) T
			WHERE T.SALARY > 
			(SELECT MIN(SALARY) FROM EMPLOYEES WHERE DEPARTMENT_ID = 80);
				
-----------------------------------------------------------------------

ABOVE QUERY - SUBQUERY IS A PART OF TABLE 
		BASED ALL PREVIOUS LOGICS WE CAN ALSO JOIN OTHER TABLES 
			WITH THE SUBQUERY TREATED A TABLE 
			
	
SELECT SALARY FROM (	
SELECT T.EMPLOYEE_ID,T.NAME,T.SALARY,T.DEPARTMENT_NAME,C1.COUNTRY_NAME 	
			FROM 
			(SELECT 
				E1.EMPLOYEE_ID, CONCAT(E1.FIRST_NAME,' ',E1.LAST_NAME) AS NAME, E1.SALARY , D1.DEPARTMENT_NAME,
					L1.STREET_ADDRESS,L1.COUNTRY_ID
				FROM 
					EMPLOYEES E1 
					INNER JOIN 
					DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID
					INNER JOIN 
					LOCATIONS L1 ON D1.LOCATION_ID = L1.LOCATION_ID) T
			INNER JOIN 
			COUNTRIES C1 ON T.COUNTRY_ID = C1.COUNTRY_ID
			) TY 
			LIMIT 10;
			
		*** 
			NEVER EVER TRY TO WRITE QUERY DIRECTLY ...
			* FIRST ANALYSE QUESTION 
			* BREAK INTO SUB PARTS 
			* WRITE THE QUERIES FOR THE SUB PART 
			* MERGE THEM TO GEATHER 
			
---------------------------------------------------------------------

SUBQUERY USED AT THE PLACE OF COLUMNS 
	
		:	
		* SUBQUERY NEED TO BE IN BRACKETS 
		* IN THIS CASE
			MAIN QUERY EXECUTED FIRST AND THEN 
				FOR EVERY VALUE 
					SUB QUERY EXECUTED 
					
**** 
		NEED TO FIND EMPLOYEES AND THERE DEPARTMENT NAME 
			WITHOUT JOIN OPERATIONS 
			
				* GET ALL THE EMPLOYEES FROM EMPLOYEE TABLE 
				
				
				SELECT 
					EMPLOYEE_ID,FIRST_NAME,LAST_NAME,SALARY, 
					DEPARTMENT_ID 
					FROM 
						EMPLOYEES;
				
				* FOR EVERY EMPLOYEE I HAVE REPLACE THE DEPARTMENT ID WITH THE NAME AFTER DOING COMPARISION WITH DEPARTMNET TABLE 
				
				
				SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 WHERE D1.DEPARTMENT_ID = 
					
		MERGE ABOVE QUERIES : 

			SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPTNAME 
					FROM 
						EMPLOYEES E1;

			** OUTER QUERY EXECUTED FIRST 
				IT RETURN FIRST ROW FROM EMPLOYEE TABLE 
				101 RAHUL BANSAL 800000 80 
				
			STEP 2**
			SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = 80) 
					FROM 
						EMPLOYEES E1;	
					
			STEP3 :
				101 RAHUL BANSAL 800000 Sales
					
					
					




SELECT 
				E1.EMPLOYEE_ID,E1.FIRST_NAME,E1.LAST_NAME,SALARY, 
					(SELECT D1.DEPARTMENT_NAME FROM DEPARTMENTS D1 	
							WHERE 
							D1.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPTNAME 
					FROM 
						EMPLOYEES E1;
						
		* OUTER QUERY EXECUTED FIRST 
			* FOR EVERY ROW THE INNER QUERY EXECUTED ....
			
			
********* THESE TYPE OF QUERIES ALSO CALLED AS CORRELATED QUERIES 

	*** 
		NEED TO FIND ALL THE EMPLOYEES 
			WHOSE SALARY IS GREATED THEN AVERAGE SALARY OF IT'S DEPARTMENT 
				
		* 
			1) NEED TO FIND THE DEPARTMENT OF EACH ROW 
			2) FOR THAT DEPARTMENT - NEED TO CALCULATE AVERAGE SALARY 
			3) EMPLOYEES RETURNED FROM 1 , ITS SALARY NEED TO BE COMPARED WITH STEPS 2 SALARY 
			



			1) NEED TO FIND THE DEPARTMENT OF EACH ROW 
				
				SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							??
			
			2) FOR THAT DEPARTMENT - NEED TO CALCULATE AVERAGE SALARY 
			
			
				SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 WHERE 
					E2.DEPARTMENT_ID = ??
			
			3) EMPLOYEES RETURNED FROM 1 , ITS SALARY NEED TO BE COMPARED WITH STEPS 2 SALARY 
					
		MERGE THE STEPS 1, 2
		
			SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = E1.DEPARTMENT_ID);
								
			101 RAHUL 9000 20 ---
			102 RITESH 8000 20 
			103 NIKHIL 2000 20 
	1) PICKED FIRST ROW 
	
		101 RAHUL 9000 20 	
		SELECT * FROM 
					EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = 20);
			
	2) FIND AVERAGE SALARY OF DEPARTMENT 20 

		101 RAHUL 9000 20 	
		SELECT * FROM 
					EMPLOYEES E1
						WHERE 9000 > 
							(6333);
	
	
	3) COMPARISION 
			IF TRUE ROW RETURN TO THE OUTPUT 
			101 RAHUL 9000 20
				
	-----------
	NEED TO CHECK/VALIDATE 
	

SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
FROM 
(	
SELECT E1.EMPLOYEE_ID,E1.SALARY,
		(SELECT AVG(E3.SALARY) 
			FROM EMPLOYEES E3 
				WHERE 
					E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
			FROM 
			EMPLOYEES E1
			WHERE E1.SALARY > 
				(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
					WHERE 
					E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
) T;
	
--------------------------------------------------------------	

SUBQUERY : 
		USED IN WHERE CLAUSE 
			USED AT TABLE PLACE 
				USED AT COLUMN LEVEL - CORRELATED QUERIES 
											WHERE 2 QUERIES ARE DEPENDED ON EACH OTHER 
											

SUBQUERY CAN ALSO BE A PART OF YOUR INSERT AND CREATE COMMANDS 

	LIKE : 
			WE NEED TO CREATE A TABLE WITH SAME STRUCTURE OF SOME EXISTING TABLE 
			
			SYNTAX : 
					CREATE TABLE EMPLOYEES_NEW LIKE EMPLOYEES;

		** NEED TO CREATE A TABLE WITH STRUCTURE AND DATA TO BE COPIED 
		
			TWO WAYS TO DO IT 
				1) 	CREATE TABLE EMPLOYEES_NEW LIKE EMPLOYEES;
					INSERT ROWS 
					
	SYNTAX FOR INSERT + SUBQUERY : 
	
		INSERT INTO EMPLOYEES_NEW SELECT * FROM EMPLOYEES;

				2) CREATE + SUBQUERY TOGEATHER
						*
						* CREATE TABLE WITH THE HELP OF SELECT QUERY 
							CONSTRINTS DOESN'T COPY AS THIS IS TABLE CREATED FROM SELECT 
							
					CREATE TABLE EMPLOYEE_CREATETABLE 
						AS 
							SELECT * FROM EMPLOYEES;
							
					* 1 CREATE TABLE 
					* 2 INSERT DATA 
					
							
	INSERT INTO EMPTEMP SELECT EMPLOYEE_ID,CONCAT(FIRST_NAME,LAST_NAME) NAME, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 80 AND SALARY > 2000;						
							
	CONCEPT OF TEMPRORARY TABLES 
			* 
				* THESE TABLE ARE A PART OF YOUR SESSION 
				* 	WE CAN USE THESE TABLE DURING A TRANSACTION 
				*		THESE TABLE AUTOMATICALLY WIPES AS YOUR TRANATION OVER OF YOUR SESSION OVER....
						
	SYNTAX : 
			CREATE TEMPORARY TABLE EMP_TEMP AS SELECT * FROM EMPLOYEES;
							
----------------------------------------------------------------------

--- MOST OF THE TIME QUERIES WHICH ARE COMMANLY USED ARE WRITTEN ONCE AND USED MULTIPLE TIME 
								
		OR 
		
		METHODS WHICH ARE COMMANLY USED 
			LIKE CALCULATING HIKE SALARY BASED ON PERCENTAGE 
				METHOD 
					USED THEM WHEN EVER REQUIRED 
					
		* THIS CAN ALSO BE ACHIVED IN THE DATA BASE 
			WITH THE HELP OF VIEWS CONCEPT 
			
		VIEWS :
				1) VIEWS ARE USED TO ENCAPSULATE THE DATA
				2) VIEWS ARE USED TO STORE THE SYNTAX OF THE QUERY IN THE DATABASE ITSELF 
				3) VIEWS NEVER EVER CREATE ANOTHER TABLE IN THE DATABASE 
				
		** A DEFINCATION STORED IN THE DATABASE 
			USER CAN CALL THEM WHEN EVER REQUIRED.....
			
		SYNTAX : 

			CREATE VIEW VIEWNAME AS SELECT QUERY.....
			
			TYPE OF VIEWS 
				SIMPLE
					SIMLE MEANS : VIEWS CREATED WITH SINGLE TABLE 
					
				COMPLEX 
					VIEWS ARE CREATED WITH MULTIPLE TABLE 
					
			
CREATE VIEW EMPAVERAGESALARY_VIEW 
AS			
SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
FROM 
(	
SELECT E1.EMPLOYEE_ID,E1.SALARY,
		(SELECT AVG(E3.SALARY) 
			FROM EMPLOYEES E3 
				WHERE 
					E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
			FROM 
			EMPLOYEES E1
			WHERE E1.SALARY > 
				(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
					WHERE 
					E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
) T;
			
			
	* CREATE A VIEW WITH EMPAVERAGESALARY_VIEW
	* CAN BE CALLED AS SIMPLE AS CALLING ANOTHER TABLE
	
	
		SELECT * FROM EMPAVERAGESALARY_VIEW
			EXECUTION OF THIS :
			
			SELECT * FROM 
			(SELECT EMPLOYEE_ID,SALARY,AVERAGESALARY,CASE WHEN SALARY > AVERAGESALARY THEN 'TRUE' ELSE 'FALSE' END AS STATUS
			FROM 
			(	
			SELECT E1.EMPLOYEE_ID,E1.SALARY,
					(SELECT AVG(E3.SALARY) 
						FROM EMPLOYEES E3 
							WHERE 
								E3.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS AVERAGESALARY 
						FROM 
						EMPLOYEES E1
						WHERE E1.SALARY > 
							(SELECT AVG(E2.SALARY) FROM EMPLOYEES E2 	
								WHERE 
								E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
			) T) Y
			
		VIEW WHICH IS CREATED BY THE USER - IS COMPLETLY A PART OF THE DATABASE 
			
			
			** FLEXIBLITIES PROVIDED BY THE DATABASE ON THE VIEWS 
			
				ENCAPSULATE : 
				
				
			CREATE VIEW EMPLOYEES_VIEW1 
			AS
			SELECT EMPLOYEE_ID,FIRST_NAME,LAST_NAME,JOB_ID,DEPARTMENT_ID 
				FROM 
					EMPLOYEES;
			
			***
				ADDITIONAL FUNCTIONALITIES 
					TALKING NOT TO PROVIDE THE PERMISSION ON MAIN TABLE 
						JUST PROVIDE ACCESS ON THE VIEWS 
						
					
				** INSERT , UPDATE, DELETE PERMISSION  
				
			VIEWS PROVIDE A FETURE OF 
					RUNNINNG
						INSERT, UPDATE , DELETE ON VIEWS 
							RESTRICTED TO THE COLUMNS MENTIONED IN THE 	
								VIEW DEFINATION 
								
					
			
				
		ANY UPDATE ON VIEW 
				DIRECTLY INPACTING THE TABLE WHICH IS INVOLVED IN THE VIEW DEFINATION 
				
				IT HAS TO - AS WE ALREADY AWARE VIEWS THEM SELF DOESN'T HAVE ANY PHYSICAL TABLE LINKED.
				
		UPDATE EMPLOYEES_VIEW1 SET DEPARTMENT_ID = 50 WHERE JOB_ID = 'HR_REP' AND EMPLOYEE_ID = 203;
		
		ITS UPDATING EMPLOYEES TABLE 
		
		SELECT DEPARTMENT_ID,* FROM EMPLOYEES WHERE EMPLOYEE_ID = 203;
				
		mysql> INSERT INTO EMPLOYEES_VIEW1 VALUES(201,'NIKHIL','SARASWAT','HR_REP',50);
		ERROR 1423 (HY000): Field of view 'humanresource12.employees_view1' underlying table doesn't have a default value
		mysql> DESC EMPTEMP;
		+-------+-------------+------+-----+---------+-------+
		| Field | Type        | Null | Key | Default | Extra |
		+-------+-------------+------+-----+---------+-------+
		| ID    | int         | YES  |     | NULL    |       |
		| NAME  | varchar(20) | YES  |     | NULL    |       |
		| SAL   | int         | YES  |     | NULL    |       |
		+-------+-------------+------+-----+---------+-------+
		3 rows in set (0.00 sec)

		mysql> CREATE VIEW EMPTEMP_VIEW AS SELECT ID,NAME FROM EMPTEMP;
		Query OK, 0 rows affected (0.01 sec)

		mysql> INSERT INTO EMPTEMP_VIEW VALUES(201,'NIKHIL');
		Query OK, 1 row affected (0.02 sec)

		mysql> SELECT * FROM EMPTEMP WHERE ID = 201;
		+------+--------+------+
		| ID   | NAME   | SAL  |
		+------+--------+------+
		|  201 | NIKHIL | NULL |
		+------+--------+------+
		1 row in set (0.00 sec)		
				
	**** 

	RULES NOT TO UPDATE 
		
			* SELECT CLAUSE MAY NOT CONTAIN THE KEYWORD DISTINCT.
			* SELECT CLAUSE MAY NOT CONTAINS SUMMARY FUNCTION MEANS 
				SUM(), AVG(), MAX(), COUNT(*) 
			* SELECT CLAUSE MAY NOT CONTAINS AN ORDER BY CLAUSE 
			* SELECT CLAUSE MAY NOT CONTAIN MULTIPLE TABLE 
			* WHERE CLAUSE INSIDE THE SELECT MAY NOT CONATAIN A SUBQUERY 
			* THE QUERY MAY NOT CONTAINS THE GROUP AND HAVING CLUASE 
	
	RULES NOT TO INSERT
	
			** NOT NULL COLUMNS MUST BE THE PART OF THE SELECT QUERY.
	
	 
		
		** STRUCTURE THE DATA WHICH NEED TO PRESENT TO THE END USER 
		** RESTRICT THE ACCESS TO THE DATA
		** SUMARIZED DATA FROM DIFFERENT TABLES 
		
		
		--------------------------------------------------------
		--------------------------------------------------------
		
		select `e`.`employee_id` AS `employee_id`,`e`.`job_id` AS `job_id`,`e`.`manager_id` AS `manager_id`,`e`.`department_id` AS `department_id`,`d`.`location_id` AS `location_id`,`l`.`country_id` AS `country_id`,`e`.`first_name` AS `first_name`,`e`.`last_name` AS `last_name`,`e`.`salary` AS `salary`,`e`.`commission_pct` AS `commission_pct`,`d`.`department_name` AS `department_name`,`j`.`job_title` AS `job_title`,`l`.`city` AS `city`,`l`.`state_province` AS `state_province`,`c`.`country_name` AS `country_name`,`r`.`region_name` AS `region_name` 
		from 
		(((((`employees` `e` join `departments` `d`) join `jobs` `j`) join `locations` `l`) join `countries` `c`) join `regions` `r`) where ((`e`.`department_id` = `d`.`department_id`) and (`d`.`location_id` = `l`.`location_id`) and (`l`.`country_id` = `c`.`country_id`) and (`c`.`region_id` = `r`.`region_id`) and (`j`.`job_id` = `e`.`job_id`))
		
		
	===========================================================

SUMMARIZING : 
			VIEW CAN BE CREATED WITH SELECT QUERY 
			VIEW ARE OF 2 TYPE 
				SIMPLE - CONATAINS SINGLE TABLE  
				COMPLEX - MULTIPLE TABLE 
				
			USER CAN PERFORM 
				INSERT / UPDATE / DELETE 
					OPERATION ON VIEW WITH RESTRICTED COLUMNS WHICH ARE THE PART OF VIEW 
					
	------------------------------------------------------------------
	------------------------------------------------------------------
	------------------------------------------------------------------
	
	
		CREATE VIEW EMPDEPTLOC
			AS		
			SELECT E1.EMPLOYEE_ID,E1.FIRST_NAME,D1.DEPARTMENT_NAME,L1.STREET_ADDRESS FROM 
				EMPLOYEES E1 
				INNER JOIN DEPARTMENTS D1 ON E1.DEPARTMENT_ID = D1.DEPARTMENT_ID 
				INNER JOIN LOCATIONS L1 
				ON D1.LOCATION_ID = L1.LOCATION_ID ;
				
	=================================================================

		** PERMISSION 
		
			CREATE USERS AND PROVIDE THEM CERTAIN PERMISSION 
			
				TWO COMMANDS 
					
						GRANT AND REVOKE 
						
						GRANT COMMAND - PROVIDE PERMISISON 
						REVOKE COMMAND -  REMOVE THE PERMISSION 
							
		
		1) CREATE ONE USER 'SHWETA'
		
			SYNTAX : 
			
				create user username 
						identified by password;
			
				create user shweta@localhost 
					identified by shweta;
		
		2) login with new use 
			we only have access 
				to information_schema 
				
		3) grant some permisison 
			SYSTAX : 
				
					GRANT PERMISSIONS 
						ON DATABASE.TABLE 
							TO USERNAME;
							
					PERMISSION  : 
								ALL 
								SELECT 
								SELECT , INSERT, UPDATE 
								
					DATABASE.TABLE : 
								
						ALL DATABASES AND ALL TABLE
								*.* 
								
						SPECIFIC TO HUMANRESOURCE2 AND TABLE EMPLOYEES 

							HUMANRESOURCE.EMPLOYEES
							
						ALL TABLE OF HUMAN RESOURCE 

							HUMANRESOURCE2.*
							
		NEED TO PROVIDE ACCESS employees_view1
			TO USER SHWETA 
			
			
			
			GRANT SELECT,UPDATE 
				ON humanresource12.employees_view1
					TO shweta@localhost;
					
					
		REMOVE THE ACCESS : 
		
			REVOKE SELECT,UPDATE 
				ON humanresource12.employees_view1
					FROM shweta@localhost;
												
							
		GRANT ALL 
			ON *.*
				TO shweta@localhost;
			

DATA CONTROL LANGUAGE : 
					GRANT 
					REVOKE 
					
					
				
------------------------------------------------------------------------		
	
		LAST TOPIC FOR SQL : 
				
		INDEXES 
			WHICH IS CONCEPT OF MAKING SERCHING FASTER 
			
			
		SEARCH ENGINE 
			
			* PREFERED TO APPLY INDEXES ON 
				* COLUMNS MOSTLY USED AT THE TIME OF JOINS 
				* COLUMNS WHICH ARE THE PART OF TABLE AND GOING TO BE USED FOR SERCHING 
			
			INDEXES 
					CREATE A SEPERATE TABLE WITH THE COLUMN VALUES IN SORTER FORMAT 
					WITH LOCATION OF THAT PERTICULAR RECORD IN THE DATABASE 
					
					EMPID 
					101
				10000001
					103
				100000232
					104
				10002323
					102
				10000023
					106
				10000023223
					108
				2323332
					109
				34543534
			
					101	10000001	
					102 10000023
					103 100000232
					104 10002323
					106 10000023223
					108 2323332
					109 34543534

			SELECT * FROM EMPLOYEES WHERE ID = 106;
			
				* FIRST GOES AND CHECK FOR INDEXES 
				* COLUMN EXIST 
				* INDEXES TABLE 
				* CHECK FOR 106 
				* PICKED UP THE ADDRESS WHERE DATA LYES 
				* RETURN TO THE CONSOLE AS OUTPUT 
				

			PROFILING  : 
				STORES YOUR LAST EXECUTED STATEMENTS 
					
			SHOW PROFILES;
			
			SHOW PROFILE FOR QUERY 2;
							
							
			CREATE INDEX INDEX_NAME ON TABLE(COLUMNNAME);

			
		
							DAY 8 
							
			REVISION :- 
				
				HISTORY DATABASE
				DATA STORES IN THE DATABASE
				CODD'S RULES
				CATEGORIES
					DQL
					DML
					DDL
					DCT
					DTL
				SELECT 
					FROM 
						WHERE
							GROUP BY 
								HAVING 
									ORDER BY 
										LIMIT 
										
				FUNCTIONS :
					NUMERIC 
					STRING
					DATE 
					AGGREGATED 
					
				JOIN 
					INNER JOIN
					OUTER JOIN
					SELF JOIN
					NATURAL JOIN
					CROSS JOIN 
					
				SUB QUERIES 
				CORRELATED QUERIES 
				
				INDEX 
				
				VIEWS 
					INSERT
					UPDATE 
					DELETE 
					SELECT 
					
				EXECUTION PLAN 
				
				
=======================================================================

PROGRAMING : 
		PLSQL 
			PROGRAMMING LANGUAGE IN MYSQL 
			
			
		BLOCKS: 
			SET OF CODE WRITTEN AND STORED IN THE DATABASE 
			
			WRITTEN ONCE AND USED MULTIPLE TIME 
			
			PART OF MY DATABASE, THEY ONLY REMOVES 
					WHEN SOMEBODY PERSONALY DELETE THEM FROM THE DATABASE 
			
			BLOCKS:- 
			
				THREE KEY WORDS 
					
					BEGIN : INDICATE THE STARTING POINT OF THE BLOCK
					
					DECLARE : ALLOWS USER TO DECLARE THE VARIABLES IN THE SYSTEM 
					SCOPE OF THESE VARIABLES ARE WITH IN THE BLOCK 
					
					END : INDICATE THE END OF THE BLOCK 
					
			IN MYSQL : 
					EVERY BLOCK OR DEFINATION OF EVERY BLOCK 
					
					NAMED AS 
					EITHER 
						PROCEDURES :
							SET OF CODE WHICH DO NOT RETURN ANY VALUE 
							
							CALLING PROCEDURE 
							
							- CALL PROCEDURENAME 
						
						FUNCTIONS :
							SET OF CODE WHICH RETURN A DATATYPE 
							
							CALLING OF FUNCTIONS 
							
							SELECT FUNCTIONAME; 
							
							
			DIFFERENCE BETWEEN PROCEDURES AND FUNCTIONS 

				1) PROCEDURE ARE NOT DESIGNED TO RETURN VALUE 
					THEY ARE DESIGNED TO EXECUTE SET OF CODE 
					
				WHERE AS 
				
					FUNCTIONS ARE ALWAYS RETURN THE VALUE (DATATYPE)
					
				2) PROCEDURE CAN BE ECECUTED BY A KEYWORD CALL 
					
					USER CAN NOT USE PROCEDURE IN THE SELECT STATEMENT 
					
				WHERE AS 
				
					FUNCTION THAT THEY ALWAYS A PART OF SELECT STATEMENT 
					
					
PROCEDURES : 
					
	SYNTAX : 
				CREATE PROCEDURE PROCEDURENAME()
				BEGIN
				
				STATEMENTS ......
				
				END;
				
				IF SOME VARIABLES ARE THE PART OF PROCEDURE 
				
				CREATE PROCEDURE PROCEDURENAME()
				BEGIN
				
				DECLARE 
				VARIABLE DEFINATIONS...
				
				STATEMENTS ......
				
				END;				
					
					
				CALL PROCEDURENAME;

P1 : 
		FETCH ALL THE RECORDS OF THE EMPLOYEE TABLE 
		
			SELECT * FROM EMPLOYEES;
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT * FROM EMPLPOYEES;
			
			END;
			
			
		SYSTEM ALLOWS : 
			CHANGE THE DELIMITER OF MY CONSOLE FROM WHERE WE ARE EXECUTING THE PROCEDURE OR FUNCTIONS ......
			
			DELIMITER //
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT * FROM EMPLPOYEES;
			
			END;
			
			DELIMITER ;
			
			CALL DAC1;
			
			
			------------------
			AT ANY POINT OF TIME, IF I NEED TO CHANGE THE PROCEDURE DEFINATION 
			
			DROP PROCEDURE 
			
			CREATE IT AGAIN 
			
		- DROP A PROCEDURE 
			DROP PROCEDURE PROCEDURENAME;
			
			
			DELIMITER //
			DROP PROCEDURE DAC1 //
			
			CREATE PROCEDURE DAC1()
			BEGIN
			
			SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) AS NAME FROM EMPLOYEES;
			
			END //
			
			DELIMITER ;
			
	-----------------------------------------------------------------

		ORACLE : 
		
				CREATE OR REPLACE PROCEDURE PROCEDURENAME()
				BEGIN
				END;
				
	------------------------------------------------------------------

		NEED TO VIEW THE DEFINATION OF THE PROCEDURE OR FUNCTION OR TABLE,,,,
		
		SHOW CREATE PROCEDURE PROCEDURENAME;
		
		SHOW CREATE FUNCTION FUNCTIONNAME;
		
		SHOW CREATE TABLE TABLENAME;
		
	-------------------------------------------------------------------


** 
	HOW CAN I STORE THE VALUE IN THE VARIABLES ...
	
	BASICALY - SIGNLE OUTPUT OF THE QUERY NEED TO STORED IN THE VARIABLE 
	
		SELECT COUNT(*) FROM EMPLOYEES; 
		
		
	AS DATABASE ALLOWS TO STORE THE OUTPUT OF THE QUERY WITH SINGLE VALUE IN THE VARIABLE - 
		IT CHANGE THE SYNTAX OF SELECT ONLY FOR 
				BLOCKS 
				
		SELECT COUNT(*) INTO VARIABLENAME FROM EMPLOYEES;
		
	----------------------------------------------------------
DAC2 : 
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC2 //
		
		CREATE PROCEDURE DAC2()
		BEGIN
		
		DECLARE X INT;  -- DEFINCATION OF DECLARING A VARIABLE 
		
		SELECT COUNT(*) INTO X FROM EMPLOYEES;
		
		SELECT X;
		
		END //
		
		DELIMITER ;
		
	-----------------------------------------------------------
	
	NEED TO PUSH MULTIPLE VALUES INTO THE VARIABLES :
	
	
	SELECT COUNT(*), MAX(SALARY) FROM EMPLOYEES; 
	
	+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	
DAC3 :- 
	
	DELIMITER //
	
	CREATE PROCEDURE DAC3()
	BEGIN 
	
	DECLARE X INT;
	DECLARE Y INT;
	
	SELECT COUNT(*), MAX(SALARY) INTO X,Y FROM EMPLOYEES;
	
	SELECT X AS TEMPLOYEES,Y AS MAXSALARY;
	
	END //
	
	DELIMITER ;
	
---------------------------------------------------------------------	
	
METHODS WITH OR WITHOUT PARAMTERS 

CONCEPT OF PARAMETRIZED PROCEDURES OR FUCNTIONS...


		PARAMETERS ARE DEFINED IN THE DATABASE WITH THREE KEY WORDS 
		
		IN 
			: DEFAULT DEFINATION OF THE PARAMETER 
			: INPUT TYPE 
			THESE VARIABLE ALWAYS USED ON THE RIGHT SIDE OF EQUALS TO OPERATOR 
				
				X =20 
				
				X : TYPE OF VARIABLE WHICH ACCEPT THE VALUE 
				20 : VALUE 
			DEFAULT ALL VARIBALE ARE IN VARIBLES 
			
			
		OUT :
			
			NEED TO STORE THE VALUES INSIDE THE BLOCK
			VALUES INTO THE VARIABLE 
				THOSE VARIABLE NEED TO DEFINED AS OUT 
				** POINTERS	

					X = 40; 
					
		INOUT :
			IN AND OUT 
				THEY BEHAVE BOTH WAYS 
					THEY ACCEPT THE VALUE AND TREAT AS INPUT VARIBALE 
					
					
					X = X + 1
					
			
	--------------------------------------------------------

		SYNTAX FOR PARAMETRIZED PROCEDURE 
		
			CREATE PROCEDURE PREOCEDURENAME(PARAMETERS DATATYPE)
			BEGIN
			END;
			
DAC4 : 
		TRY TO PRINT ALL THE EMPLOYEES SALARIES BELONGS TO RANDOM DEPARTMENT  
		
		
		DELIMITER //
		
		CREATE PROCEDURE DAC4(X INT)
		BEGIN 
		
		SELECT CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, SALARY 
			FROM EMPLOYEES 
				WHERE DEPARTMENT_ID = X;
		
		END //
		
		DELIMITER ;
		
		CALL DAC4(20);
		
----------------------------------------------------------------------

RETURN VALUE FROM PROCEDURE : PARAMETER AS AN OUT 


DAC5 : 
	WHERE I NEED TO RETURN MAXIMUM SALARY OF THE DEPARTMENT 
	
		
	DELIMITER // 
	
	CREATE PROCEDURE DAC5(X INT,OUT MAXS INT)
	BEGIN 
	
	SELECT MAX(SALARY) INTO MAXS FROM EMPLOYEES
			WHERE DEPARTMENT_ID = X;
			
	END //
	
	DELIMITER ;
			
	CALL DAC5(20,@Y);
----------------------------------------------------------------	

** INOUT 

	ADDING TWO VALUES AND RETURN THE OUTPUT 
	
		DELIMITER //
		
		CREATE PROCEDURE DAC6(X INT, INOUT Z INT)
		BEGIN
		
		SET Z = Z + X;
		
		END //
		
		DELIMITER ;
		
mysql> CALL DAC6(20,30);
ERROR 1414 (42000): OUT or INOUT argument 2 for routine humanresource12.DAC6 is not a variable or NEW pseudo-variable in BEFORE trigger
mysql> SET @Y = 30;
Query OK, 0 rows affected (0.00 sec)

mysql> CALL DAC6(20,@Y);
Query OK, 0 rows affected (0.00 sec)		
		
INOUT TYPE OF VARIABLES IN THE PROGRAM :::::::::::::

IN , OUT RETURN VALUE 

-----------------------------------------------------------------------

NEXT :- 

	CONDITIONAL OPERATORS TO HANDLES THE CONDITION
	
	1) IF ELSE END ... 
	
		SYNTAX : 
				
				IF EXPRESSION THEN 
					STATEMENT;  -- EXECUTED WHEN EXPRESSION IS TRUE 
				ELSE 
					STATEMENT; -- EXECUTED WHEN EXPRESSION IS FALSE 
				END IF;
				
				
	2) MULTIPE COMPARISONS : 
		
			IF EXPRESSSION THEN 
				STATEMENT;
			ELSEIF EXPRESSION THEN 
				STATEMENT;
			ELSE 
				STATEMENT;
			END IF;
				
DAC7 : 
		NEED TO PRINT BELOW EXPECTED STATEMENTS : 
			1) PROCEDURE ACCEPT THE EMPLOYEE ID AS INPUT PARAMERTER
			2) BASED ON THE SALARY OF THE EMPLOYEE - DEFINE THE LEVEL
			
			SALARY > 15000 (HIGHLY PAID)
			SALARY < 15000 AND SALARY > 10000 (BENCHMARK EMPLOYEE)
			SALARY < 10000 (LOW PAY GRADE)
				
		
		* PROCEDURE NEED TO WORK FOR ANY EMPLOYEES (EMPLOYEE ID NEED TO DYNAMIC) 
			
			
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC7 //
		
		CREATE PROCEDURE DAC7(X INT, OUT LEVEL VARCHAR(100))
		BEGIN
		
		DECLARE SAL INT;
		
		SELECT SALARY INTO SAL FROM EMPLOYEES
			WHERE EMPLOYEE_ID = X;
		
		IF SAL > 15000 THEN 
			SET LEVEL = 'HIGHLY PAID';
		ELSEIF SAL > 10000 AND SAL < 15000 THEN 
			SET LEVEL = 'BENCHMARK EMPLOYEE';
		ELSE
			SET LEVEL = 'LOW PAY GRADE';
		END IF;
		
		END //
		
		DELIMITER ;
		
------------------------------------------------------------------

2) CASE : 

			SELECT CASE STATEMENT END FROM TABLENAME;
			
			CASE 
				WHEN CONDITION THEN STATEMENT;
				WHEN CONDITION THEN STATEMENT;
				.
				.
				.
				.
				.
				.
				ELSE STATEMENT;
			END CASE;

-----------------------------------

DAC8 : 
		NEED TO SPELL THE NUMBER ENTER TO THE PROGRAM 
			FROM 1 TO 10 
			
		
		DELIMITER //
		
		CREATE PROCEDURE DAC8(X INT)
		BEGIN 
		
			CASE X 
				WHEN 1 THEN SELECT 'ONE';
				WHEN 2 THEN SELECT 'TWO';
				WHEN 3 THEN SELECT 'THREE';
				WHEN 4 THEN SELECT 'FOUR';
				WHEN 5 THEN SELECT 'FIVE';
				WHEN 6 THEN SELECT 'SIX';
				WHEN 7 THEN SELECT 'SEVEN';
				WHEN 8 THEN SELECT 'EIGTH';
				WHEN 9 THEN SELECT 'NINE';
				WHEN 10 THEN SELECT 'TEN';
				ELSE SELECT 'OUT OF BOUNDRY';
			END CASE;
		
			END //
			
			DELIMITER ;
			


----------------------------------------------------------------
DAC9 : 

		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC9 //
		
		CREATE PROCEDURE DAC9(X INT, OUT LEVEL VARCHAR(100))
		BEGIN
		
		DECLARE SAL INT;
		
		SELECT SALARY INTO SAL FROM EMPLOYEES
			WHERE EMPLOYEE_ID = X;
		
		CASE 
		WHEN SAL > 15000 THEN SET LEVEL = 'HIGHLY PAID';
		WHEN SAL > 10000 AND SAL < 15000 THEN SET LEVEL = 'BENCHMARK EMPLOYEE';
		ELSE SET LEVEL = 'LOW PAY GRADE';
		END CASE;
		
		END //
				
		DELIMITER ;


--------------------------------------------------------------------

NOW SIMILAR TO ALL OTHER PROGRAMS : 

		* VARIABLE 
		* PARAMETRIZED PROCEDURES 
				IN, OUT 
		* HOW TO MOVE THE VALUES FROM SELECT TO THE VARIABLE 
		* DECLARE THE VARIABLE 
		* CONDITINS INSIDE THE PROGRAM 
				IF ELSE 
				CASE 
				
	LOOPS : 
			NEED TO EXCUTE THE SAME SET OF CODE MULTIPLE TIME BASED ON THE VALUES...
			
	1) WHILE LOOP : BREAK POINT OF THE LOOP 

		SYNTAX : 
			
				WHILE EXPRESSION/CONDITION DO 
						STATEMENTS.....
						
					BREAK POINT........					
				END WHILE; 
			
			
	TAKE AN EXAMPLE OF FIBONACCI SERIES 
		
			0 , 1 , 1, 2, 3, 5, 8, 13........
			
			FNUM = 0 
			SNUM = 1 
			
			THEN 
			
			TNUM = FNUM + SNUM;
			FNUM = SNUM;
			SNUM = TNUM;
			
		DELIMITER //

		DROP PROCEDURE IF EXISTS DAC10 // 
		
		CREATE PROCEDURE DAC10(X INT)
		BEGIN 
		
		DECLARE FNUM INT DEFAULT 0;
		DECLARE SNUM INT DEFAULT 1;
		DECLARE TNUM INT;
		
		DECLARE FSERIES VARCHAR(200);
		
		SET FSERIES = CONCAT(FNUM,' ,',SNUM); -- FSERIES = 0,1
		
		WHILE X > 2 DO 
		
			SET TNUM = FNUM + SNUM;
			SET FNUM = SNUM;
			SET SNUM = TNUM;
			
			SET FSERIES = CONCAT(FSERIES,' ,',TNUM);
			
			SET X = X - 1;
			
		END WHILE;
		
		SELECT FSERIES;
		
		END //
		
		DELIMITER ;
		--------------------------
		CALL DAC10(34);
			
			
==============================================================

ANOTHER : 

	LOOP 
		DEFINATION 
		
			NAME1 : LOOP 
			
				LEAVE NAME1;	BREAK POINT 		

			END LOOP NAME1 
			
	EXAMPLE - AFTER VIEWING ANOTHER CONCEPT 
	
-----------------------------------------------------------------

WE CAN WORK WITH THE SELECT STATEMENT WHICH RETURN SINGLE VALUES ...

	NOW IF I NEED TO WORK ON COMPLETE TABLE VALUES OR SET OF VALUES 
		OR SET OF ROWS ....
		
		HOW CAN WE USE THIS IN THE PROGRAMMING LANGUAGE 
		
		
		
		SELECT COLUMN INTO VARIABLE FROM TABLE ......
		
		
CURSORS : 
		HAVING A CAPABLITY TO TRAVERSE IN THE MULTIPLE ROWS OR VALUE 
		TRAVERSE IN THE SET OF VALUE 
		
		INTERNALLY : 
			CURSORS ARE THE POINTERS 
				WHICH HOLDS THE ADDRESS OF THE ROWS 
					AND TRAVERSE BASED ON THE CONCEPT 
					
			
			SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
			
			
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR ---> |         201 | 13000.00 |
			|         202 |  6000.00 |
			+-------------+----------+
			
			
			CURSORS : CAN ONLY BE DEFINED BY THE SELECT 
			
			
			CURSORS : TWO KEYWORDS 
			----- 
			CURSOR DECLARATION 
				1) OPEN 
				2) FETCH 
				
	CURSORS : ARE ALWAYS DECLARED BY THE SELECT STATEMENT ....

		SYNTAX : 
		
		DECLARE CURSORNAME CURSOR 
				FOR SELECT STATEMENT;
				
		
		DECLARE EMP_CUR	CURSOR 
				FOR SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
				
		** OPEN EMP_CUR;
				** GOES AND CHECK THE DEFINATION ATTACHED TO THE CURSOR 
				** EXECUTE THE SELECT STATEMENT  AND CREATE THE OUTPUT IN THE TEMP MEMORY 
				** EMP_CUR - START POINTING TO THE FIRST ROW OF THE OUTPUT 
				
		** FETCH : TO FETCH ONE BY ONE ALL THE ROWS OF THE CURSOR POINTING 
			
				** USED TO TRAVERSE THE SET OF THE VALUES 
					CURSOR VALUE 
				
				SYNTAX : 
				
					FETCH CURSORNAME INTO VARIBALES.....

--------------------------------------------------------------------

DAC11 : 
			FIND ALL THE EMPLOYEES NAME, EMPLOYEE ID AND THEIR SALARY AND INCREMENTED SALARY WITH 15% 
			
			NEED TO PRINT 
				EMPLOYEE_ID 
				EMPLOYEE_NAME 
				OLD SALARY 
				NEW SALARY 
		
		
		DELIMITER // 
		
		DROP PROCEDURE IF EXISTS DAC11 //
		
		CREATE PROCEDURE DAC11()
		BEGIN 
		DECLARE EID INT;
		DECLARE FNAME VARCHAR(50);
		DECLARE SAL INT;		
		DECLARE BCOUNT INT;  -- TOTAL NUMBER OF ROWS
		DECLARE EMP_CUR CURSOR
			FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			
		SELECT COUNT(*) INTO BCOUNT FROM EMPLOYEES;
		
		CREATE TEMPORARY TABLE EMPSAL(
			ID INT,NAME VARCHAR(100),OLDSAL INT,NEWSAL INT);			
		
		OPEN EMP_CUR; -- FIRST STEP TO EXECUTE THE CURSOR DEFINATION
			
		L_LEVEL : LOOP  -- NAMED THE LOOP AS L_LEVEL, THIS START POINT
		
			IF BCOUNT <=0 THEN   -- EXIT CRITERIA 
				LEAVE L_LEVEL;
			END IF;
			
			FETCH EMP_CUR INTO EID,FNAME,SAL;
			
			--  FETCH FIRST ROW
			-- FIRST ROWS REMOVES FROM THE TEMP 
			-- CURSOR START POINTING TO THE NEXT ROW...
			
			INSERT INTO EMPSAL VALUES(EID,FNAME,SAL,SAL*1.15);
			
			SET BCOUNT = BCOUNT - 1;  -- COUNTER 
		END LOOP L_LEVEL;
		
		CLOSE EMP_CUR;
		
		SELECT * FROM EMPSAL;
		
		DROP TABLE EMPSAL;
		END //
		
		DELIMITER ;
		
		
			
			
			
			
			
========================================

			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR ---> |         201 | 13000.00 |
			|         202 |  6000.00 |
			+-------------+----------+		
			
			
			FETCH CURSOR INTO X , Y 
				X = 201 AND Y = 13000 
				
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR --->	|         202 |  6000.00 |
			+-------------+----------+			
				
			FETCH CURSOR INTO X , Y 
				X = 202 AND Y = 6000 
		
			+-------------+----------+
			| EMPLOYEE_ID | SALARY   |
			+-------------+----------+
CURSOR --->	+-------------+----------+	
				
			FETCH CURSOR INTO X , Y 
			IT WILL TROW EXCEPTION 
				NULL POINTER 
				
=-================================================

CURSOR : 

			IS THE POINTER 
			WHICH ALWAYS WORK ON THE DEFINATION 
				DEFINATION : SELECT STATEMENT 
				
			FOUR STPES INVOLVED : 
				1) DEFINATION OF THE CURSOR 
					* DEFINATION OF THE CURSOR NEED TO BE DEFINED AFTER ALL OTHER VARIABLE DECLARED 
					
				DECLARE CURSORNAME CURSOR 
					FOR SELECT QUERY;
					
				2) OPEN CURSORNAME;
					* EXECUTE THE SELECT STAEMENT ATTACHED TO THE CURSOR 
					* CREATE A TEMP TABLE WITH THE OUTPUT 
					* NAME OF THE CURSOR START POINTING TO THE FIRST ROW OF THE TEMP TABLE 
					
				3) FETCH CURSORNAME INTO VARIABLES 
					* FETCH THE POINTED ROW INTO THE RESPECTIVE VARIABLES
					* REMOVE THAT RECORD FROM THE TEMP TABLE 
					* CURSORNAME START POINTING TO THE NEXT RECORD
					
					** USE THIS FETCH INSIDE THE LOOP 
					
				4) CLOSE CURSOR
					* TO WIPES USED SPACE 
					
					
----------------------------------------------------------------------

1) WHEN ALL THE ROWS FETCHED FROM THE CURSOR 
						AND AGAIN I AM FETCH ANOTER 
							WHEN CURSOR IS EMPTY 
							
				SYSTEM THROWS THE EXCEPTION 
				
				'NOT FOUND' 
				
	SYSTEM ALLOWS US TO HANDLE THE EXCEPTION THROWS IMPLICITLY OR EXPLICITY IN THE PROGRAM 
	
		TRY {
		
		
		
		} CATCH(EXCEPTION E) 
			{
			LINES OF CODE 
			}
		
		FINALIZE {
				ALWAYS EXECUTED 
			}
					
** WHEN CURSOR REACHED IN THE LAST LINE 
					IT THROWS A EXCEPTION  'NOT FOUND'
					
		HANDLE THAT EXCEPTION 
		
		SYSTEM : EXCEPTION HANDLING IN PLSQL 
		
			1) DECLARE THE EXCEPTION 
				
				SYNTAX : 
					
			DECLARE ACTION HANDLER FOR CONDITION STATEMENTS;

				DECLARE : KEYWORD TO DECLARE THE VARIABLES AND HANDLERS
				
				ACTION : EXIT , CONTINUE
				
					EXIT : WHENEVER YOU GET AN EXCEPTION IN THE PROGRAM 
							HANDLE IT AND MOVE OUT FROM THE PROGRAM 
								
					CONTINUE : WHENEVER YOU GEN AN EXCEPTION IN THE PROGRAM 
						HANDLE IT AND CONTINUE WITH THE PROGRAM 
						
				HANDLER FOR : KEY WORDS 

				CONDITIONS : 
							NOT FOUND 
							SQLEXCEPTION
							SQLWARNING
							.....
				STATEMENTS : HANDLING PART 			
							

PROGRAM TO EXIT FROM THE BLOCK AFTER HANDLING THE EXCEPTION: 

---- SAME PREVIOUS EXAMPLE 

		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC12 //
						
		CREATE PROCEDURE DAC12()
		BEGIN 
			DECLARE EID INT;
			DECLARE FNAME VARCHAR(50);
			DECLARE SAL INT;
			DECLARE V_FINISH INT DEFAULT 0;
			DECLARE EMP_CUR CURSOR 
				FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			DECLARE EXIT HANDLER FOR NOT FOUND SET V_FINISH = 1;

			CREATE TEMPORARY TABLE EMPTEMP(ID INT,NAME VARCHAR(200),OSAL INT,NSAL INT);
			
			OPEN EMP_CUR;
			
			L_LEVEL : LOOP 
				
				IF V_FINISH = 1 THEN 
					LEAVE L_LEVEL;
				END IF;
			
			FETCH EMP_CUR INTO EID,FNAME,SAL;
			
			INSERT INTO EMPTEMP VALUES(EID,FNAME,SAL,SAL*1.15);
		
			END LOOP L_LEVEL;
			
			CLOSE EMP_CUR;
			
			SELECT * FROM EMPTEMP;
			
			DROP TABLE EMPTEMP;
			
			END //
			
			DELIMITER ;
		
---------------------------------------------------------------------

PROGRAM WITH CONTINUE : 

DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC12 //
						
		CREATE PROCEDURE DAC12()
		BEGIN 
			DECLARE EID INT;
			DECLARE FNAME VARCHAR(50);
			DECLARE SAL INT;
			DECLARE V_FINISH INT DEFAULT 0;
			DECLARE EMP_CUR CURSOR 
				FOR SELECT EMPLOYEE_ID,FIRST_NAME,SALARY FROM EMPLOYEES;
			DECLARE CONTINUE HANDLER FOR NOT FOUND SET V_FINISH = 1;

			CREATE TEMPORARY TABLE EMPTEMP(ID INT,NAME VARCHAR(200),OSAL INT,NSAL INT);
			
			OPEN EMP_CUR;
			
			L_LEVEL : LOOP 
			
				FETCH EMP_CUR INTO EID,FNAME,SAL;
				
				IF V_FINISH = 1 THEN 
					LEAVE L_LEVEL;
				END IF;
			
			INSERT INTO EMPTEMP VALUES(EID,FNAME,SAL,SAL*1.15);
		
			END LOOP L_LEVEL;
			
			CLOSE EMP_CUR;
			
			SELECT * FROM EMPTEMP;
			
			DROP TABLE EMPTEMP;
			
			END //
			
			DELIMITER ;		
		
		
	==============================================================	
		
		ORACLE : 
			DDL COMMANDS NOT ALLOWED IN THE BLOCKS 
			
				BLOCKS : PRACODEURES/ FUNCTIONS 
				
				
								DAY 9
				PLSQL - PROGRAMMING LANGUAGE IN MYSQL
========================================================================

				DAY 8 - COVERED AND LERNED VARIOUS TOPIC 
				
					* BLOCK 
						BEGIN
						DECLARE 
						END
					* DBMS - ONLY UNDERSTAND THE ; AS AN TERMINATOR OPERATOR 
					* DELIMITER // 
					* WRITE THE PROCEDURES 
					* CREATE PROCEDRUE 
						ALL SQL COMMANDS 
						DECALRE VARIABLE 
						CONDITION (IF ELSE, CASE)
						USE ALL FUNCTIONS
						LOOP (WHILE , LOOP, NAMED LOOP)
						
					* WORKING WITH SINGLE LINE OF OUTPUT FROM THE SELECT QUERY 
					* NEED TO WORK WITH MULTIPLE ROWS 
						CURSOR
							POINTER 
								THREE STEPS 
									DECLARATIONOF THE CURSOR 
									OPEN CURSOR 
									FETCH THE CURSOR IN TO VARIABLES
									CLOSE THE CURSOR - IS DONE AUTOMATICALLY 
					* WHILE ENCOUNTERING CURSORS 
						WE FACE VARIOUS EXCEPTION ENCOUNTERD WHILE EXECUTING THE PROGRAMS 
							HANDLE TO THOSE EXCEPTION 
								EXCEPTION HANDLER 
						
				EXCEPTION : 
					DECLARE 
					
					DECALRE ACTION HANDLER FOR CONDITION STATEMENTS...
					
					ACTION : 
						EXIT 
						CONTINUE 
					
					CONDITION : 
							NOT FOUND (IN CASE OF CURSORS)
							SQLEXCEPTION
							SQLWARNING
							EXCEPTION NUMBER 
							
----------------------------------------------------------------------

DAC13 : 

		EXAMPLE : 
				HANDLER NOT FOUND FOR CURSOR 
				CONDITION IF AND ELSE 
					SALARY
				FUCNTION CONCAT 
				
				CURSORS : FETCHING THE DATA 
				
	*** 
		NEED A TEMPORARY REPORT OF ALL THE EMPLOYEES WITH THERE DEPARTMENT NAMES BASED ON THE SALARY BRACKET MENTIONE BELOW , MARKED THESE EMPLOYEES WITH GRADES 
		
			SALARY > 15000 THEN A AND INCREMENT THE SALARY WITH 5%
			SALARY BETWEEN 10000 AND 15000 THEN B WITH 10%
			SALARY < 10000 THEN C WITH 15%
			
		EXECUTION OF THE ABOVE QUESTION :- 

			1) NEED TO HAVE A DATA FROM EMPLOYEES AND DEPARTMENT TABLE

			SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, 
				SALARY, DEPARTMENT_NAME 
				FROM EMPLOYEES
				LEFT JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
			
			2) NEED TO HAVE THE VARIABLES WITH ALL THE COLUMNS NEED TO DISLPAY 
				
				DECALRE EMPID INT;
				DECLARE EMPNAME VARCHAR(200);
				DECLARE OLDSAL INT;
				DECLARE NEWSAL INT;
				DECLARE DEPTNAME VARCHAR(50);
				DECLARE V_F INT DEFAULT 0;
				DECLARE GRADES CHAR(2);
				
			
			3) BASED ON THE SALARY COLUMN NEED TO DEFINE THE GRADES 
			
				IF OLDSAL > 15000 THEN 
					SET GRADE = 'A';
					SET NEWSAL = OLDSAL * 1.05;
				ELSEIF OLDSAL > 10000 AND OLDSAL < 15000 THEN 
					SET GRADE = 'B';
					SET NEWSAL = OLDSAL * 1.10;
				ELSE 
					SET GRADE = 'C';
					SET NEWSAL = OLDSAL * 1.15;
				END IF;
			
			4) CREATE A TEMPORARY TABLE TO PUSH THE DATA 
				
				CREATE TEMPORARY TABLE EMPREPORT
				(
				ID INT;
				NAME VARHCAR(100);
				OLDSALARY INT;
				NEWSALARY INT;
				DEPTNAME VARHCAR(50);
				GRADE CHAR(2)
				);
			
			5) HANDLE THE EXCEPTION WHICH EVER ENCOUNTER 
			
				DECALRE CONTINUE HANDLER FOR NOT FOUND SET V_F = 1;
			
			6) PRESENT THE DATA BASED ON THE SALARY BRACKET 
			
				INSERT INTO EMPREPORT VALUES(EMPID,EMPNAME,OLDSAL,NEWSAL,DEPTNAME,GRADES);
				
				SELECT * FROM EMPREPORT;
				
				DROP TABLE EMPREPORT;
				
-------------------------------------------------------------------

				DELIMITER // 

				DROP PROCEDURE IF EXISTS DAC13 //

				CREATE PROCEDURE DAC13()
				BEGIN 
				DECLARE EMPID INT;
				DECLARE EMPNAME VARCHAR(200);
				DECLARE OLDSAL INT;
				DECLARE NEWSAL INT;
				DECLARE DEPTNAME VARCHAR(50);
				DECLARE V_F INT DEFAULT 0;
				DECLARE GRADES CHAR(2);
				DECLARE EMP_CUR1 CURSOR 
					FOR SELECT EMPLOYEE_ID, CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, 
						SALARY, DEPARTMENT_NAME 
							FROM EMPLOYEES
								LEFT JOIN DEPARTMENTS ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
				DECLARE CONTINUE HANDLER FOR NOT FOUND SET V_F = 1;

				CREATE TEMPORARY TABLE EMPREPORT
				(
				ID INT,
				NAME VARCHAR(100),
				OLDSALARY INT,
				NEWSALARY INT,
				DEPTNAME VARCHAR(50),
				GRADE CHAR(2)
				);
				
				OPEN EMP_CUR1;

				L_LEVEL : LOOP
				
					FETCH EMP_CUR1 INTO EMPID,EMPNAME,OLDSAL,DEPTNAME;
					
					IF V_F = 1 THEN 
						LEAVE L_LEVEL; -- BREAK POINT 
					END IF;
					
					IF OLDSAL > 15000 THEN 
						SET GRADES = 'A';
						SET NEWSAL = OLDSAL * 1.05;
					ELSEIF OLDSAL > 10000 AND OLDSAL < 15000 THEN 
						SET GRADES = 'B';
						SET NEWSAL = OLDSAL * 1.10;
					ELSE 
						SET GRADES = 'C';
						SET NEWSAL = OLDSAL * 1.15;
					END IF;
					
			
				INSERT INTO EMPREPORT VALUES(EMPID,EMPNAME,OLDSAL,NEWSAL,DEPTNAME,GRADES);
				
				END LOOP L_LEVEL;
				
				CLOSE EMP_CUR1;
				
				SELECT * FROM EMPREPORT;
				
				DROP TABLE EMPREPORT;
				
				END //
				
				DELIMITER ;
			
======================================================================

HANDLING THE EXCEPTION : 

			** NOT FOUND - THIS COMES ONLY IN CASE OF CURSORS 
			
PROCEDURE WHICH ACCEPT TWO VALUES AND STORE INTO THE TABLE 
	WHICH WAS ALREADY DEFIN WITH PRIMARY KEY 
	
			CREATE TABLE EMPSTANDARD
			(
			EMPID INT PRIMARY KEY,
			EMPSALARY INT,
			ADDEDDATE DATE,
			ADDEDBY VARCHAR(50)
			);
			
			
		DELIMITER // 
			
		CREATE PROCEDURE DAC14(ID INT, SAL INT)
		BEGIN
		INSERT INTO EMPSTANDARD VALUES(ID,SAL,CURDATE(),USER());
		END //
		DELIMITER ;
		
		
		CREATE TABLE EMPSTANDARD_ERROR
		(
		ID INT AUTO_INCREMENT PRIMARY KEY,
		DESCRIPTION VARCHAR(200),
		ADDEDDATE DATETIME,
		ADDEDBY VARCHAR(50),
		EVENT VARCHAR(200)
		);
		
			
			
		DELIMITER // 
			
		DROP PROCEDURE IF EXISTS DAC14 //
		
		CREATE PROCEDURE DAC14(ID INT, SAL INT)
		BEGIN
		
		DECLARE EXIT HANDLER FOR 1062 
				BEGIN
					INSERT INTO EMPSTANDARD_ERROR(DESCRIPTION,ADDEDDATE,ADDEDBY,EVENT) VALUES('DUPLICATE DATA ENTRY',NOW(),USER(),'INSERT');
					SELECT * FROM EMPSTANDARD_ERROR ORDER BY ID DESC LIMIT 1;							
				END;		
		INSERT INTO EMPSTANDARD VALUES(ID,SAL,CURDATE(),USER());
		END //
		DELIMITER ;	
			
=====================================================================

SMALLER EXAMPLE : 

		WRITE A PROCEDURE WHICH DISPLAY EMPLOYEES DATA OF THE PERTICULAR DEPARTMENT 
		
		DELIMITER //
		
		DROP PROCEDURE IF EXISTS DAC15 //
		
		CREATE PROCEDURE DAC15(DEPTID INT)
		BEGIN 
		DECLARE ID INT;
		DECLARE NAME VARCHAR(200);
		DECLARE SALARY INT;
		DECLARE V_FINISH INT DEFAULT 0;
		DECLARE EMP_CUR2 CURSOR
			FOR SELECT EMPLOYEE_ID,CONCAT(FIRST_NAME,' ',LAST_NAME) NAME, SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID = DEPTID;
		DECLARE CONTINUE HANDLER FOR SQLEXCEPTION 
								BEGIN
								SET V_FINISH = 1;
								SELECT 'SQLEXCEPTION' NAME;
								END;
		DECLARE CONTINUE HANDLER FOR NOT FOUND 
								BEGIN
								SET V_FINISH = 1;
								SELECT 'DATA NOT FOUND' NAME;
								END;		
		CREATE TEMPORARY TABLE TEMP_EMP(EMPID INT,EMPNAME VARCHAR(200),SAL INT);
		
		OPEN EMP_CUR2;
		
		L_RAHUL : LOOP 
			
				FETCH EMP_CUR2 INTO ID,NAME,SALARY;
				
				IF V_FINISH = 1 THEN 
					LEAVE L_RAHUL;
				END IF ;
				
				INSERT INTO TEMP_EMP VALUES(ID,NAME,SALARY);
				
		END LOOP L_RAHUL;
		
		CLOSE EMP_CUR2;
		
		SELECT * FROM TEMP_EMP;
		
		SELECT RAHUL;
		
		DROP TABLE TEMP_EMP;
		
		END //
		
		DELIMITER ;
			
======================================================================

THIS ALL ABOUT PROCEDURES 
				
					HANDLING WITH 
						VARIABLES
						CURSORS
						EXCEPTION HANDLING 
						BEGIN END 
						LOOPS 
						CONDITIONS 
						
SAME CODING STANDARDS CAN BE USED INSIDE THE FUNCTIONS AS WELL ....

FUNCTIONS : 
			DECLRATION OF THE VARIABLE 
			CURSORS
			HANDLERS 
			CONDITION 
			LOOP 
			IN / OUT / INOUT VARIABLE 
			
			ALL WILL BE USED HERE AS WELL 
			
			** FUNCTIONS ARE DESIGNED TO RETURN THE VALUES ..... 
			
		
		SYNTAX : 
			
				CREATE FUNCTION FUNCTIONNAME()
						RETURNS DATATYPE
				BEGIN 
				
				RETURN VALUE....
			
				END;
				
				
				
		SMALL PROGRAM :
				RETURN ME THE SUM OF TWO VALUES 
				
				VAR1 AND VAR 2
					VAR1 + VAR2 
					
			DELIMITER //
			
			CREATE FUNCTION DAC16(X INT, Y INT)
					RETURNS INT 
			BEGIN 
				
				RETURN X + Y;
			
			END //
			
			DELIMITER ;
				
			SET GLOBAL log_bin_trust_function_creators = ON;	
				
			 CALLING FUNCTION : 
			 
			 SELECT DAC16(10,20);
		
----------------------------------------------------------------

DAC17 : SPELL OUT OF DAY OF THE DATE 

			1 TO 31 
				SPELL THOSE NUMBER 
					
					9 : NINE 
					21 : TWENTY ONE 
					
					30 : THIRTY 
					
					
		0 - 10 , 11- 19, 20, 21 - 29, 30, 31 
		
		SUBSTR : 
			SUBSTR(STRING,POSITION,LENGTH)
		
		0 - 10 
		
		'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  '
		LENGHT = 5
		
		FIVE : 
		
			SUNSTR(STR,5*5,5) = FIVE 
			SUBSTR(STR,1*5,5) = ONE
		
		11 - 19 
		
		'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN '
		LENGHT = 9
		

		START WITH THE PROGRAM: 
		
			DELIMITER //
			
			DROP FUNCTION IF EXISTS DAC18 //
			
			CREATE FUNCTION DAC18(X INT)
					RETURNS VARCHAR(200)
			BEGIN 

			DECLARE STR1,STR2,STR3,SPELLSTR VARCHAR(500);
			
			IF X < 11 AND X >= 0 THEN 
			
			SET STR1 = 'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  ';
			
			SET SPELLSTR = TRIM(SUBSTR(STR1,(X * 5) + 1,5));
			
			ELSEIF X < 20 THEN 
			
			SET STR2 = 'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN ';
			
			SET SPELLSTR = TRIM(SUBSTR(STR2,(X - 11) * 9 + 1,9));
			
			ELSEIF X = 20 THEN 
			
			SET SPELLSTR = 'TWENTY';
			
			ELSEIF X < 30 THEN 
			
				SELECT DAC18(X%10) INTO STR3;
				
				SET SPELLSTR = CONCAT('TWENTY ',STR3);
				
			ELSEIF X = 30 THEN 
			
				SET SPELLSTR = 'THIRTY';
				
			ELSEIF X = 31 THEN 
			
				SET SPELLSTR = 'THIRTY ONE';
				
			ELSE 
			
				SET SPELLSTR = 'NOT A DAY, INCORRECT NUMBER';
				
			END IF;
			
			RETURN SPELLSTR;
			
			END //
			
			DELIMITER ;
			
	*************************************************************

mysql> SELECT DAC18(25);
ERROR 1424 (HY000): Recursive stored functions and triggers are not allowed.

	SYSTEM DOESNT MENTIONED ABOUT THE PROCEDURE 
	
	LETS CONVERT THIS COMPLETE FUNCTION IN THE STORE PROCEDURE
	---------------------------------------------------------
	
			DELIMITER //
			
			DROP PROCEDURE IF EXISTS DAC19 //
			
			CREATE PROCEDURE DAC19(X INT,OUT TEMPSTR VARCHAR(200))
			BEGIN 

			DECLARE STR1,STR2,STR3,SPELLSTR VARCHAR(500);
			
			IF X < 11 AND X >= 0 THEN 
			
			SET STR1 = 'ZERO ONE  TWO  THREEFOUR FIVE SIX  SEVENEIGHTNINE TEN  ';
			
			SET TEMPSTR = TRIM(SUBSTR(STR1,(X * 5) + 1,5));
			
			ELSEIF X < 20 THEN 
			
			SET STR2 = 'ELEVEN   TWELVE   THIRTEEN FOURTEEN FIFTEEN  SIXTEEN  SEVENTEENEIGHTEEN NINETEEN ';
			
			SET TEMPSTR = TRIM(SUBSTR(STR2,(X - 11) * 9 + 1,9));
			
			ELSEIF X = 20 THEN 
			
			SET TEMPSTR = 'TWENTY';
			
			ELSEIF X < 30 THEN 
			
				CALL DAC19(X%10,STR3);
				
				SET TEMPSTR = CONCAT('TWENTY ',STR3);
				
			ELSEIF X = 30 THEN 
			
				SET TEMPSTR = 'THIRTY';
				
			ELSEIF X = 31 THEN 
			
				SET TEMPSTR = 'THIRTY ONE';
				
			ELSE 
			
				SET TEMPSTR = 'NOT A DAY, INCORRECT NUMBER';
				
			END IF;
			
			END //
			
			DELIMITER ;			
					
mysql> CALL DAC19(23,@TEM);
ERROR 1456 (HY000): Recursive limit 0 (as set by the max_sp_recursion_depth variable) was exceeded for routine DAC19
mysql>
					
------------------------------

TO USE ABOVE PROCEDURE INSIDE THE SELECT ---------

						CALL THE PROCEDURE FROM THE FUNCTION 
						
				
		FUNCTION WHICH CALL OUR PROCEDURE 
		
		DELIMITER //
		
		DROP FUNCTION IF EXISTS DACSPELLFUN //
		
		CREATE FUNCTION DACSPELLFUN(X INT)
				RETURNS VARCHAR(500)
		BEGIN 
			
			DECLARE SPELL VARCHAR(500);
			
			CALL DAC19(X,SPELL);
			
			RETURN SPELL;
			
		END //
		
		DELIMITER ;
		
	
	IMPORTANT : 		
	SELECT DAY(HIRE_DATE),DACSPELLFUN(DAY(HIRE_DATE)) SPELLOUT FROM EMPLOYEES LIMIT 10;	
		
				
				
	HANDLE THE VALUES GREATER THEN 31 
					CONDITION 
				
=====================================================================


			
								DAY 10
								
								PLSQL
					PROCEDURE, FUNCTION, TRIGGERS
					
	================================================================
	
		Areas Covered : 
					PROCEDURES
					FUNCTIONS 
					
					RECURSVICE PROCEDURES
					CALLING PROCEDURES FROM FUNCTION 
					
	=================================================================
	
	TRIGGERS : 
	
			* SET OF CODE WRITTEN IN THE BLOCK 
			* BUT TRIGGERS ARE EVENT DRIVEN 
			
				* SET OF LINES NEED TO BE EXECUTED WHEN CERTAIN ACTION TAKEN 
				
				TRIGGERING EVENTS :
				
							INSERT / UPDATE / DELETE 
									AS AN TRANSACTION
									
							BASED ON THESE EVENT CERTAIN BLOCK EXECUTED AUTOMATICALLY 
							
							YOU DO NOT HAVE TO DO ANYTHING MANUAL ...
								AUTO TRIGGERED BLOCKS BASED ON EVENTS 
								
								
			----- MOST OF THE TIME 

				TRIGGERS : 
					TO MAINTAIN LOGS 
						
					N NUMBER OF USERS WHO ARE INTERACTING TO THE DATABASE 
					
					WE NEED TO KEEP A TRACT WHICH USER AT WHAT TIME DO THE MODIFICATION IN THE SYSTEM 
					OR WHAT MODIFICATION THEY DID ......
								
								
	SYSTAX : 
			
				CREATE TRIGGERS TRIGGERNAME
						BEFORE / AFTER 
							INSERT / UPDATE / DELETE 
									ON TABLENAME
										FOR EACH ROW 
				BEGIN
				
				BODY OF THE TRIGGER 
				
				END //
				
		LET EXPLORE THE SYNTAX: 
		
		 ** BEFORE / AFTER :-
						EITHER TRIGGER BODY EXECUTED BEFORE EXECUTING THE COMMAND 
						OR 
						TRIGGER BODY EXECUTED AFTER EXECUTION OF THE COMMAND 
						
						
			ACTION  : INSERT STATEMENT 
					  UPDATE STATEMENT 
					  DELETE STATEMENT
					  
	*** IF WE WRITE A TRIGGER WITH 
	
	BEFORE INSERT  : 
				EXECUTE THE TRIGGER BODY BEFORE EXECUTION OF THE INSERT COMMAND 
				
		**INSERT INTO EMPLOYEES VALUES(101,'RAKESH',30000);

		ONE TRIGGER 
		**BEGIN
		  RAHUL 
		
		  END;
		
		WHEN YOU EXECUTE LINE NO NUMBER 77 
		
				IF THE TRIGGER IS BEFORE 
				
					THEN BEFORE INSERTING THE RECORDS IN THE EMPLOYEES TABLE 
					
					SYSTEM WILL EXECUTE LINE NUMBER 80
		
		
		** FIRST TRIGGER BODY EXECUTED AND THEN ACTION COMMAND GET EXECUTED 
		** FIRST ACTION COMMAND GET EXECUTED AND THEN TRIGGER BODY GET EXECUTED 
		
		YOUR COMPLETE ACTION COMMANDS AT THE RUN TIME CONTAINS TWO SET OF VALUES 
		
			1) OLD VALUE 
			2) NEW VALUE 
			
		CONSIDER : 
			INSERT INTO EMPLOYEES VALUES(101,'RAKESH',30000);
				
					EMPID		EMPNAME		SALARY 
			OLD 	NULL		NULL		NULL
			NEW 	101			RAKESH 		30000 
			
		**
			UPDATE EMPLOYEES SET SALARY = 40000 WHERE EMPID= 101;
			
					EMPID		EMPNAME		SALARY 
			OLD		101			RAKESH		30000
			NEW		101			RAKESH		40000
			
		** 
			DELETE FROM EMPLOYEES WHERE EMPID = 101;
			
			
					EMPID		EMPNAME		SALARY 
			OLD 	101			RAKESH		40000
			NEW 	NULL		NULL		NULL
			
			TWO OBJECT :
					OLD / NEW 
						USE THEM : 
							OLD.EMPID, OLD.EMPNAME , OLD.SALARY 
							NEW.EMPID, NEW.EMPNAME, NEW.SALARY 
							
							
	***********
		FOR EACH ROW : 
					DURING UPDATE 
						THERE MAY BE A CASES WHEN IT IMPACT MULTIPLE ROWS 
						
				UPDATE EMPOYEES SET SALARY = SALARY * 1.15 
					WHERE DEPARTMENT_ID = 20;
				
				WE HAVE MULTIPLE EMPLOYEES BELONGS TO DEPARTMENT 20 
							
		** HAVE TO EXECUTE THE TRIGGER BODY FOR EACH ROW UPDATION 

			DELETE FROM EMPLOYEES WHERE DEPARTMENT_ID = 80;
							
							
	**********************************************************

DAC20 : EXAMPLE FOR WRITING A TRIGGER FOR INSERTION A VALUES IN THE EMPLOYEES TABLE AND MAINTAING THE LOGS FOR THE INSERTION 

		CREATE TABLE EMPDAC21
		(
		ID INT PRIMARY KEY AUTO_INCREMENT,
		NAME VARCHAR(200),
		SALARY INT,
		COMM_PCT FLOAT(2,1)
		);
		
		CREATE TABLE EMPDAC21LOGS
		(
		ID INT PRIMARY KEY AUTO_INCREMENT,
		SUBJECT VARCHAR(200),
		DESCRIPTION VARCHAR(200),
		ADDEDDATE DATETIME DEFAULT NOW(),
		ADDEDBY VARCHAR(100)
		);
		
		TRIGGER : 
		
		DELIMITER //
		
		CREATE TRIGGER EMPDAC21_TRIG
			AFTER 
				INSERT ON EMPDAC21
					FOR EACH ROW
		BEGIN 
		
		INSERT INTO EMPDAC21LOGS(SUBJECT,DESCRIPTION,ADDEDBY) 
				VALUES('INSERT','NEW VALUES ENTERED IN THE EMPDAC21 TABLE',USER());
			
		END //
		
		DELIMITER ;
							
							
----- UPDATE EMPLOYEE TABLE 

			
		DELIMITER //
		
		CREATE TRIGGER EMPDAC21_TRIG_UPDATE
			BEFORE 
				UPDATE ON EMPDAC21
					FOR EACH ROW
		BEGIN 
		
		DECLARE STR1 VARCHAR(200);
		
		SET STR1 = CONCAT('OLD SALARY : ',OLD.SALARY,' NEW SALARY : ',NEW.SALARY);

		INSERT INTO EMPDAC21LOGS(SUBJECT,DESCRIPTION,ADDEDBY) 
				VALUES('UPDATE',STR1,USER());
			
		END //
		
		DELIMITER ;	
			
--------------------------------------------------------------------

TAKE ONE EXAMPLE : 
		
		REQUIRENMENT : 
			WHILE A INSERTING A NEW RECORDS 
				SYSTEM CAN VALIDATE THE SALARY SLAB 
					BASED ON THE SALARY SLAB THE COMMISSION GET DECIDED BY THE SYSTEM 
			
			SALARY > 20000 THEN 
				COMMISSION 4.5
				
			SALARY <= 20000 THEN 
				COMMISSION 2.2
				
		DELIMITER //

		DROP TRIGGER IF EXISTS EMPDAC21_TRIG //
		
		CREATE TRIGGER EMPDAC21_TRIG
			AFTER 
				INSERT ON EMPDAC21
					FOR EACH ROW
		BEGIN
		
			IF NEW.SALARY > 20000 THEN 
				UPDATE EMPDAC21 SET COMM_PCT = 4.5 
						WHERE ID = NEW.ID;
			ELSE 
				UPDATE EMPDAC21 SET COMM_PCT = 2.2 
						WHERE ID = NEW.ID;
			END IF;

			INSERT INTO EMPDAC21LOGS(SUBJECT,DESCRIPTION,ADDEDBY) 
				VALUES('INSERT','NEW VALUES ENTERED IN THE EMPDAC21 TABLE',USER());
			
		END //
			
		DELIMITER ;
			
mysql> INSERT INTO EMPDAC21 VALUES(104,'KRISHAN',50600,1.1);
ERROR 1442 (HY000): Can't update table 'empdac21' in stored function/trigger because it is already used by statement which invoked this stored function/trigger.			
	
----------- MODIFY TO ACHIVE THE REQUIREMENTS ------------------

	
		DELIMITER //

		DROP TRIGGER IF EXISTS EMPDAC21_TRIG //
		
		CREATE TRIGGER EMPDAC21_TRIG
			BEFORE 
				INSERT ON EMPDAC21
					FOR EACH ROW
		BEGIN
		
			IF NEW.SALARY > 20000 THEN 
				SET NEW.COMM_PCT = 4.5;
			ELSE 
				SET NEW.COMM_PCT = 4.5;
			END IF;

			INSERT INTO EMPDAC21LOGS(SUBJECT,DESCRIPTION,ADDEDBY) 
				VALUES('INSERT','NEW VALUES ENTERED IN THE EMPDAC21 TABLE',USER());
			
		END //
			
		DELIMITER ;		
				
		EXECUTION PLAN :- 
			1) INSERT INTO EMPDAC21 VALUES(104,'KRISHAN',50600,1.1);
			
			2) SYSTEM WILL CHECK FOR ANY TRIGGERS IF YES 
			
			3) 
					ID		NAME		SALARY 	COMM_PCT
			OLD 	NULL	NULL		NULL	NULL
			NEW 	104		KRISHAN		50600	1.1 
			
			
			4) CHECK FOR AFTER AND BEFORE IF THIS IS BEFORE
				THEN TRIGGER THE TRIGGER BODY FIRST 
				
				IF NEW.SALARY > 20000 THEN 
				SET NEW.COMM_PCT = 4.5;
				ELSE 
				SET NEW.COMM_PCT = 2.2;
				END IF;

				INSERT INTO EMPDAC21LOGS(SUBJECT,DESCRIPTION,ADDEDBY) 
				VALUES('INSERT','NEW VALUES ENTERED IN THE EMPDAC21 TABLE',USER());
			
					ID		NAME		SALARY 	COMM_PCT
			OLD 	NULL	NULL		NULL	NULL
			NEW 	104		KRISHAN		50600	4.5 
			
	==============================================================			
PICK SOME EXAMPLE FOR PLSQL : 

	2) PREPARE A PROGRAM WHICH CAN PERFORM FOLLOWING OPERATION
		- LOOKOUT FOR TABLES WHICH HAS MISSING CONSTRINTS 
		- DISPLAY LIST OF THOSE TABLE  
		
		
		NOTES : 
			1) PROCEDURE 
			2) 
				2.1) ALL THE TABLES WHICH ARE THE PART OF THE DATABASE 
				2.2) ALL THE TABLES WHICH HAS THE CONSTRAINTS TO IT 
				2.3) WE HAVE TO COMPARE 2.1 WITH 2.2 TO FIND THE MISSING CONSTRINT TABLES 
				
			3) PRINT THOSE TABLES 
			
			INFORMATION_SCHEMA 
			
				TABLES : 
						CONTAINS ALL THE TABLES 
				SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'humanresource12';
						
				TABLES WITH CONSTRAINTS : 

				SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = 'humanresource12';
			
			
		DELIMITER //

		DROP PROCEDURE IF EXISTS DAC20 //
		
		CREATE PROCEDURE DAC20()
		BEGIN 
		
		DECLARE STR1,STR2,STR3 VARCHAR(200);
		DECLARE X,Y,Z INT DEFAULT 0;
		
		DECLARE HRDATABASE_TABLE CURSOR 
				FOR SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'humanresource12';
		
		DECLARE HRDATABASE_TABLE_CONST CURSOR 
				FOR SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = 'humanresource12';
		
		SELECT COUNT(*) INTO X FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'humanresource12';
		
		SELECT COUNT(*) INTO Y FROM (SELECT DISTINCT TABLE_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS WHERE TABLE_SCHEMA = 'humanresource12') T;
		
		CREATE TEMPORARY TABLE EMP_TE(NAME VARCHAR(200));
		
		OPEN HRDATABASE_TABLE;
		
		L_LEVEL : LOOP
			
				IF X <=0 THEN 
					LEAVE L_LEVEL;
				END IF;
				
				FETCH HRDATABASE_TABLE INTO STR1;
				
				OPEN HRDATABASE_TABLE_CONST;
					
				L_CONLEVEL : LOOP 
					
					IF Y <=0 THEN 
						LEAVE L_CONLEVEL;
					END IF;
					
					FETCH HRDATABASE_TABLE_CONST INTO STR2;
					
					IF STR1 = STR2 THEN 
						SET Z = 1;
					END IF; 
					
					SET Y = Y - 1;
					
				END LOOP L_CONLEVEL;
				
				IF Z = 0 THEN 
					INSERT INTO EMP_TE VALUES(STR1);
				END IF;
					
				SET Z = 0;
				SET X = X - 1;
				CLOSE HRDATABASE_TABLE_CONST;
		END LOOP L_LEVEL;
		CLOSE HRDATABASE_TABLE;
		
		SELECT * FROM EMP_TE;
		
		END //
		
		DELIMITER ;
			
	================================================================

	
								DAY 10
								
			PLSQL : 
					PROCEDURES 
					FUCNTIONS 
					TRIGGERS 
					
				THAT END FOR PLSQL 
				
---------------------------------------------------------------------

						:- NORMALIZATION -: 
				
	IS THE CONCEPT OF MAKING DATA RELEVANT AND MAIINTAINED SIGNIFICANTLY IN THE DATABASE FOLLOWING ALL THE RULES DEFINED LIKE 
	
						STRUCTURE DATABASE 
				
	
		TABLES STAGES : 
				DEFINED VARIOUS STAGES WHERE MY CURRENT TABLES IS IN 
				
					* SET OF RULES 
					* BASED ON THEM THEY DEFINIED THE TABLE STATUS 
					* TABLE STATUS  : NORMALIZATION 
					
			IF WE FOLLOW THESE 3 RULES 
						- WE CONSIDER YOUR DATABASE IS IN CERTAING NORMALIZATION FORM 
						
			NORMALIZATION : 
						1NF  - TALK ABOUT THE STAGE OF YOUR DATABASE 
						2NF
						3NF
						4NF
						5NF
						BCNF 
	
DISCUSS : 
		INF : 
			1) NO DUPLICATE DATA OR REPEATING DATA IN THE TABLES 
			2) EACH COLUMN CELL MUST HAVE SINGLE VALUE
			3) THERE MUST BE A UNIQUE KEY WHICH IDETIFY EACH ROW OF THE TABLE 
				* IF USER TRY TO ACCESS A DATA BASED ON THE UNIQUE KEY 
					HE MUST RECEIVED ONLY ONE ROW FROM THE TABLE 
					
	---------------------------------------------------------------

		MARK THAT DATABASE - 1NF 
		
EXAMPLE : 

		ITEMS		COLORS		PRICE 		TAX 
		T_SHIRT		RED,BLUE	200			20%
		POLO 		RED,YELLOW 	200			20%
		T_SHIRT		RED,BLUE 	200			20%
		SWEATSHIRT	BLUE,BLACK	500			25%
		
	ACHIVE 2:
		EACH COLUMN CELL MUST HAVE SINGLE VALUE
		
		ITEMS		COLORS		PRICE 		TAX 					
		T_SHIRT		RED			200			20%
		T_SHIRT		BLUE 		200			20%
		POLO		RED	 		200			20%
		POLO		YELLOW		200			20%
		T_SHIRT		RED			200			20%
		T_SHIRT		BLUE 		200			20%		
		SWEATSHIRT	BLUE		500			25%		
		SWEATSHIRT	BLACK		500			25%
					
	** 
		NO DUPLICATE VALUES - REPLICATED DATA 
		
		ITEMS		COLORS		PRICE 		TAX 					
		T_SHIRT		RED			200			20%
		T_SHIRT		BLUE 		200			20%
		POLO		RED	 		200			20%
		POLO		YELLOW		200			20%
		SWEATSHIRT	BLUE		500			25%		
		SWEATSHIRT	BLACK		500			25%		
			
	** 
		EACH ROW MUST BE UNIQUELY DEFINIED 
		
		ITEMS + COLOR - AS AN PRIMARY KEY 
		
		EACH AND EVERY ROW UNIQULY IDENTIFIED 
			PRIMARY KEY
		ITEMS		COLORS		PRICE 		TAX 					
		T_SHIRT		RED			200			20%
		T_SHIRT		BLUE 		200			20%
		POLO		RED	 		200			20%
		POLO		YELLOW		200			20%
		SWEATSHIRT	BLUE		500			25%		
		SWEATSHIRT	BLACK		500			25%		
					
		***** MARK THIS TABLE AS AN 1ST NORMAL FORM 
		
2NF : 
		1) YOUR DATABASE MUST BE IN THE INF 
		2) NON_KEY FIELDS MUST DEPENDS ON THE ALL COMPONENTS OF THE KEY 
		
		
	RULE 1: 
			PRIMARY KEY
		ITEMS		COLORS		PRICE 		TAX 					
		T_SHIRT		RED			200			20%
		T_SHIRT		BLUE 		200			20%
		POLO		RED	 		200			20%
		POLO		YELLOW		200			20%
		SWEATSHIRT	BLUE		500			25%		
		SWEATSHIRT	BLACK		500			25%	
						
	RULE 2: 
		NON_KEY FIELDS : 
				PRICE AND TAX 
				PRICE AND TAX MUST BE DEPENDENT ON ITEMS AND COLORS 
					
						
		**  PRICES AND TAX ARE DEPENDENT ON ITEMS 
		** 	PRICES AND TAXES ARE NOT DEPEND ON THE COLOR 
		
		- MOVE TAXES IN TO THE SEPERATE TABLE 
		
	TABLE 1 : 
	PRIMARY KEY
	ITEMS 		PRICE 		TAX
	T_SHIRT		200			20%
	POLO		200			20%
	SWEATSHIRT	500			25%		
		
	TABLE 2 : 
			PRIMARY KEY
		ITEMS 		COLOR 
		T_SHIRT		RED	
		T_SHIRT		BLUE
		POLO		RED
		POLO		YELLOW
		SWEATSHIRT	BLUE	
		SWEATSHIRT	BLACK
		
	* 1NF 
		NO DUPICATE DATA 
		NO COLUMN HAVE MULTIPLE VALUE 
		EACH ROW IS UNIQUELY IDENTIFY 
				
	* 2NF : 
		EVERY NON KEY ATRIBUTE MUST DEPEND ON THE KEY ATTRIBUTE 
		
	----------- MY TABLE TABLE 1 AND TABLE 2 ARE IN 2NF	
				
				
3) 
	3NF : 
	
		* INF 
		* 2NF 
		* NON KEY FIELDS DEPEND ON EACH ANOTHER 
		* ALL NON KEY FIELDS MUST DEPENDS ON THE PRIMARY KEY 
		
		TABLE 1 : 
		PRIMARY KEY
		ITEMS 		PRICE 		TAX
		T_SHIRT		200			20%
		POLO		200			20%
		SWEATSHIRT	500			25%		
		
		AFTER LOOKING INTO IT 
			PRICE IS DEPENDEND ON ITEMS 
			BUT TAX IS NOT DEPEND ON ITEMS 
				INSTEAD DEPENDS ON PRICE 
		
		TABLE 2 : 
			PRIMARY KEY
		ITEMS 		COLOR 
		T_SHIRT		RED	
		T_SHIRT		BLUE
		POLO		RED
		POLO		YELLOW
		SWEATSHIRT	BLUE	
		SWEATSHIRT	BLACK	
		
				
	===================================================

		TABLE 1 : 
		PRIMARY KEY
		ITEMS 		PRICE
		T_SHIRT		200
		POLO		200
		SWEATSHIRT	500	
		
		TABLE 2 :
		PRIMARY KEY 
		PRICE 		TAX 
		200			20%
		500			25%
		
		TABLE 3 : 
			PRIMARY KEY
		ITEMS 		COLOR 
		T_SHIRT		RED	
		T_SHIRT		BLUE
		POLO		RED
		POLO		YELLOW
		SWEATSHIRT	BLUE	
		SWEATSHIRT	BLACK
			
		-------------- NOW WE CAN SAY THAT MY TABLES ARE IN 3NF 

------------------MOST OF THE ORGANIZATION ONLY FOLLOW 3NF FOR THIER DATABASES ....
			NON OF THE DATABASES AS OF NOW ARE IN 4 OR 5TH NF 
				
				4
				ALL THE NON KEY KEY MUST DEPEND ON PRIMARY KEY 
				
				GOING FORWARD YOU MAY END WITH 
					EACH TABLE WITH ONLY TWO COLUMNS
						1) PRIMARY KEY COLUMN 
						2) NON KEY 
					
				RDBMS : WE NEED TO FETCH DATA FROM TABLE TO REPRESENT 
						JOIN ARE MORE EXPENSIVE IN TERMS OF EXECUTION 
						
				--------------------------------- 
					BEYOUND 3 NF 
					
=======================================================================

** BOYCE - CODD NORMAL FORM (BCNF)

-	A RELATION IS IN BCNF IF AND ONLY IF EVERY DETERMINANT IS A CANDIDATE KEY 

		DETERMINANT : POSIBLE SCENARIOS TO FETCH DATA FROM THE TABLE 
		CANDIDATE KEY  : CREATE A KEY WITH MORE THEM ONE COLUMN 
		
EXAMPLE  : 

CLIENT 	INTERVIEW_DATE	INTERVIEW_TIME 	STAFF 	ROOM_NO		
WIPRO	13TH MAY 2021	10:30			SUNIL	C101
WIPRO 	13TH MAY 2021	12:00			SUNIL	C101
CYBAGE 	13TH MAY 2021	12:30			NIKHIL	C102
TCS		1ST JULY 2021	10:30			SUNIL	C102

FD1 : 
	CLIENT + INTERVIEW DATE -- > INTERVIEW TIME + STAFF + ROOM NO (PK)
	
FD2 : 
	STAFF + INTERVIEW DATE + INTERVIEW TIME (CANDIDATE KEY) ----> CLIENT
	
FD3 : 
	ROOM NO + INTERVIEW DATE + INTERVIEW TIME ----- > CLIENT + STAFF 
													(CANDIDATE KEY) 
													
FD4 : 
	STAFF + INTERVIEW DATE ----- > ROOM NO 

	IN SOME SCENARIOS : 
			DUE XYZ RESAON 
				ROOM NUMBER CHANGE 
		
	USER HAS TO UPDATE MORE THEN RECORD
		USER HAS TO UPDATE TWO RECORDS FOR THE SAME DATA 
		
		
		DIVIDE THE TABLES IN A WAY TO REMOVE CERTAIN DEPENDESIES 
		
	1ST TABLE  : 
		INTERVIEW_DATE 		STAFF		ROOM NO 
		13TH MAY 2021		SUNIL		C101
		13TH MAY 2021		NIKHIL		C102
		1ST JULY 2021		SUNIL		C102
		
	2ND TABLE : 
		CLIENT 		INTERVIEW_DATE		INTERVIEW_TIME
		WIPRO 		13TH MAY 2021		10:30
		WIPRO 		13TH MAY 2021		12:30
		CYBAGE 		13TH MAY 2021		12:30
		TCS 		1ST JULY 2021		10:30
		
	------------------------------------------------------------

			ALL ABOUT YOUR NORMALIZATIO CONCEPT 
				
	==============================================================

**** 
2ND TOPIC WHICH WAS LEFT WAS ER DIAGRAMS :

	ER DIAGRAMS  : 

		ENTITY RELATIONSHIP DIAGRAM 
			
			ENTITY  : ALL YOUR TABLE TREATED AS AN ENTITY 
			
			
	ENTITY : 
			WILL BE DEIFINED IN THE RECTANGLE 
				
	
	2) ATTRIBUTE : 
		ATTRIBUTES ARE THE PROPERTIES OF THE ENTITY.
			BASICALLY IN OUR TERMS ALL THE COLUMNS ARE ATTRIBUTE 
		
		DEFINE THE ELLIPSES
					
			
		- COMPOSITE ATTRIBUTE   : 
			NAME  - FISRT_NAME AND LAST NAME 
		- MULTIVALUED 
			PERSON MAY HAVE MULTIPLE VALUES 
			DOUBLE ELLIPSES
			
		- DERIVED ATTRIBUTES 
			SOME OF THE COLUMNS ARE DERIVED FROM SOME OTHER COLUMN 
			
			AGE ----- > DOB
			
			AGE - DASHED ELLIPSE
				
	3) 
		RELARTIONSHIP 
			
			
			ONE TO ONE 
				
						EACH EMPLOYEE MUST HAVE A SIGNLE EMPLOYEE ID 
						
				EMPLOYEE RECORDS  ----RELATION SHIP --- EMPLOYEEID 
			
			ONE TO MANY 
					EMPLOYEE ENROLLED WITH MORE THE ONE COURSE 
					
					EMPLPOYEE  ---  
			
			MANY TO ONE 
			
	----------------------------------------------------------

				FOR MYSQL 
					
			

								DAY 11 
								MONGO DB
								
	================================================================
	
	MONGO DB : 
			
			WHICH WORKS ON DOCUMENT 
				DOCUMENT ORIENTED DATABASE
					HIGH PERFORMANCE , HIGH AVAILABLITY 
						HIGH SCALABILITY 
			
			DATABASE : 
				PHYSICAL MACHINE / CONTAINER 
				
			COLLECTION : 
				COLLECTION IS THE GROUP OF DOCUMENTS. COLLECTIONS IS EQUIVALENT TO AN RDBMS TABLES....
				
				EMPLOYEES TABLE - EMPLOYEE COLLECTION 
				DEPARTMENT TABLE - DEPARTMENT COLLECTION 
				
				----
				
					EMPLOYEE COLLECTION : 
									CONTAINS ALL INFORMATION TOGEATHER 
										EMPLOYEE DETAILS 
										DEPARTMENT DETAIL 
										COUNTRY 
										REGION
										LOCATION 
										CITY 
										
				SINGLE FILE : 
							DOCUMENT IN MONGODB 
							
						
						
				DOCUMENT  : 

						SET OF KEY VALUE 
						EVERY DOCUMENT MAY HAVE DIFFERENT SCHEMA 


				DOCUMENT 1 : 
							ID 
							NAME
							SALARY 
							
				DOCUMENT 2 : 
							ID 
							NAME 
							SALARY 
							AGE
							HIREDATE 
				DOCUEMNT 3 :
							HIREDATE 
							NAME 
							AGE 
							ADDRESS 
							
							
		COMPARION WITH RDBMS : 

		RDBMS 									MONGODB 
		
		DATABASE 								DATABASE 
		TABLES									COLLECTIONS 
		ROWS 									DOCUMENTS 
		COLUMNS 								FILEDS / KEY 
		JOIN 									ENBEDDED DOCUMENTS 
		
		
		MONGODB STORE DATA 
				IN THE DOCUMENT FORMAT 
					AND EACH DOCUMENT IS FOLLOW JSON FORMAT 
					
				JSON  :  
					WAY OR STRUCTURE WHICH STORE INFORMATION IN KEY VALUE PAIR 
					
	Empid 101	{
						_ID : ObjectId(3453453454345) -- unique, primary key 
							for faster retrival 
								index automatically on these ids ..
								
						NAME : "RAHUL BANSAL",
						AGE  : 35
						SALARY : 3454045
						ADDRESS : 
							{
							HNO : 103,
							STREET : "CHANDAN NAGAR",
							CITY : "PUNE",
							STATE : "MH",
							ZIPCODE : 11014								
							}			
					}
	--- de-normalization of the data 			
					

		facebook : 
			rahul ---- account 232323232
			ritesh ----account 345234433


		***** 
			NOSQL : 
				CASE SENSTIVE LANGUAGE 
						CASE SENSTIVE IN TERMS OF THE KEY WORDS 
						DATA ALSO 
					
				WE ARE EXECUTING QUERIES : 
						MAKE SURE WE ARE USING CORRECT CASE OF THE KEYWORDS
		*** 
			MOST OF TIME THROWS ERRORS ON THE SCREEN 
			
				EMPLOYEES 
				
				employees

=======================================================================

							MONGODB

1) UPLOADED THE MONGODB EXE 
2) INSTALLATION STEPS 

INSTALLATION : 
				
			1) DOWNLOAD THE MSI FILES BASED ON OPERATING SYSTEM 
			2) INSTALL 
			3) MONGO INSTALLATION WILL HAPPEN IN THE C DRIVE 
			
			C:\Program Files\MongoDB\Server\4.2\bin
				
	** DEFAULT INSTALLATION WILL BE IN C DRIVE 
		
			BUT IT PROVIDEDS FLEXIBILITY TO STORE DATA 
			
			
	** 
		CD C:\
		MD "\data\db"
				
	**
		START YOUR MONGDB DATABASE 
			
			C:\Program Files\MongoDB\Server\4.2\bin
			
		MONGOD.EXE (WHICH ALLOWS TO OPEN THE SERVER WITH THE DEFINE LOCATION)
		
		
	COMMAND TO SATRT SERVER AT PERTICULAR LOCATION : 
	
	1) CD C:\Program Files\MongoDB\Server\4.2\bin
	2) mongod.exe --dbpath="c:\data\db"
	
	server started 
	
	* connect to your database 
	
	cd C:\Program Files\MongoDB\Server\4.2\bin
	mongo.exe 
	
	which will connect to the server
	
	> this is as similar as sql prompt 

=================================================================

** MONGODB IN THE NOSQL DATABASE AND LAUNCH ITS OWN QUERY LANGUAGE 
			TO INTERACT WITH THE DATABASE 
		
	DATABASE  :  
		
		RDBMS : WE CREATE DATABASE AND TABLES 
		
		BY DEAFULT AFTER YOU LOGGED IN : 
			SYSTEM POINTED USED TO THE "TEST" DATABASE 
		
		CREATE YOUR OWN DATABASES : 
		
			* TYPE A COMMAND 
			
				USE DATABASENAME
				
				AS THIS IS OPEN SOURCE AND ADVANCE TECHNOLOGY 
				
				COMMANDS YOU EXECUTED :
					* FIND WEATHER THAT OBJECT EXISTS OR NOT 
					IF EXISTS 
						IT ALLOWS YOU TO MOVE IN 
					IF NOT EXISTS 
						IT AUTOMATICALLY CREATE THAT FOR YOU 
						
						
		MONGODB IS OBJECT ORIENTED / DOCUMENT ORIENTED LANGUAGE

			MAIN OBJECT IN MONGODB : 
				"db" - object which allows to perform all the operation in the mongodb 
				
			java : public static void main()
						first method get executed... 
						
			what ever commands we are going to use will be started from db only 

				object.methods.variable ....
				
			db : main object 
			
			--------------------------------------------------
			
	BASIC COMMANDS : 
				
		RDBMS 							MONGODB 
		
		SHOW DATABASES;					SHOH DBS;
		SHOW TABLES;					SHOW COLLECTIONS;
		
	***********
		SYSTEM : IT WON'T SHOW THE DATABASE WHICH DOESN'T ANY RECORD
			
		---------------------------------------------------

CREATE COLLECTIONS : 
			
			WE HAVE FOLLOW THE OBJECT 
			
			METHOD : createCollection 
			
			db.createCollection("emp");
				
			
			COMPLETE MONGODB ONLY WORKS WITH JSON OBJECT 
			
3) CREATE A DOCUMENT IN THE DATABASE IN THE COLLECTION 
				
			* insert() is the primary method to insert documents into the Mongodb collection.
			* if the collection does not exists, insert() create the collection during the 1st insert 
			
		
			trying to insert data in the collection emp 
				by mistake empp
					- system will create a collection 
						empp 
					- insert a records 
			
	-- insert a document 

			insert() -- json 
			
	Syntax : 
			db.collectionname.insert({json object});
			
			{
			name : "Rahul",
			salary : 30000,
			age : 34,
			city : "pune"
			}
				
			>
			db.emp.insert(
				{
				name : "Rahul",
				salary : 30000,
				age : 34,
				city : "pune"
				}
			);
			
			automaticaly system allocated _id 
			
			{ 
			"_id" : ObjectId("61022e32830526560f1fa157"), -- primary key  
			"name" : "Rahul", 
			"salary" : 30000, 
			"age" : 34, 
			"city" : "pune" 
			}
			
			db.empp.insert(
				{
				name : "Rahul",
				salary : 30000,
				age : 34,
				city : "pune"
				}
			);
			
			_id : default id given to all the documents 
			
			_id field to the document and generate a unique objectid for the value 
	----------------------------------------------------------

System also allows to override the value : 

		db.emp.insert(
				{
				_id : 101,
				name : "Rahul",
				salary : 30000,
				age : 34,
				city : "pune"
				}
			);
			
			{
				"_id" : 101,  -- by default primary key for your collection
				"name" : "Rahul",
				"salary" : 30000,
				"age" : 34,
				"city" : "pune"
			}	
				
		--------------
MONGODB : 

		db.emp.insert(
				{
				_id : 101,
				name : "Rahul",
				salary : 30000,
				age : 34,
				city : "pune"
				}
			);		
				
RDBMS : 
		INSERT INTO EMP VALUES(101,'RAHUL',30000,34,'PUNE');
		
---------------------------------------------------------------------

CREATE MULTIPLE DOCUMENTS 
	* YOU CAN PERFORM A BULK INSERT INTO A COLLECTION BY PASSING AN ARRAY OF DOCUMENTS TO THE INSERT() METHOD.....
	
		ARRAY : []
		
		db.emp.insert([
			{
				_id : 102,
				name : "ritesh",
				age : 23
			},
			{
				name : "sunita",
				age : 35,
				salary : 45000,
				address : 
						{
							hno : 101,
							street : "chandan nagar",
							city : "pune",
							zipcode : 411014
						}
			}
		]);
		
	RDBMS : 
		INSERT INTO TABLE VALUES (),();
		
	--------------------------------------------------------------

Retrieve data from the collection : 
			
						Read Operations

How to select 

	* find() method - selects documents in a collection and return a 	
					cursor to the selected documents 
					
		syntax : 
			db.collection.find(query,projection)
			
		parameters of the find() method : 
		
			* query : only used of your wish to specify criteria.
				
				query : is treated as a where clause of your rdbms 
				
				filter the data - first parameter of the method fin()
				
				. It can be omitted if we wish to return all the documents in the collection..
				
			* projection : is used to control which fields to be returned 
					the fields which need to be pronted can be controled by project 
					
					
			Select emp_id,name from emp;
			
			Projection example : 
				{field1:1,field2:0}
				
				1 to include : the _id field always dilpayed for the output  
				0 to exclude 
			
				_id : 0
				
		** by default mongodb return only 20 documents in the batch 
			type "it" 
				
	find() example :

		* return all the documents of the collection without specifying parameters 
		
		db.emp.find();       ----- select * from emp;
		
		* Returns randomly a document in a collection without specifying parameters 
			
		db.emp.findOne();  select * from emp limit 1;
		
		* To select documents that match selection criteria 
		eg : return all the documents from the emp collection where age = 34
		
		age = 34
		
		db.emp.find({age:34}); select * from emp where age = 34;
		
		* Select the document that match selection criteria and specific fields only.... 
		
		eg : return all documents in emp collection where age = 34 and project _id,name, salary
		
		select id,name,salary from emp where age = 34;
		
		db.emp.find(
			{age : 34},  ------- filter criteria
			{name:1,salary:1}  ------- proejction - which fields need to display 
			);
		
		db.emp.find(
			{age : 34},
			{name:1,salary:1}
			);
		
		do not want _id to be displayed 
		
		db.emp.find(
			{age : 34},
			{name:1,salary:1,_id:0}
			);
		
	---------------------------------------------------------------
	
	Comparision Opertors 
	
	* to express equals to (eg : =) in the mongodb query language , 
		use 
		json {key:value}
		
		where first_name = 'Mozhe';
		
		db.employees.find({first_name:"Mozhe"});
		
	* != is defined as 
		$ne : not equals too 
		
		syntax : 
		
			db.emps.find(
				{
				first_name : {$ne : "Mozhe"}
				},
				{
				employee_id:1,first_name:1,salary:1,_id:0
				}
			);
	
	
		select employee_id,first_name,salary from employees 
				where first_name != 'Mozhe';
		
		* operators 
			rdbms 						mongodb 
			
			>							$gt
			>=							$gte 
			<							$lt
			<=							$lte 
			
		* eg : 
			return all the document whose salary > 15000 
			
			
			
			db.emp.find(
				{salary : {$gt : 15000}
				}
				);
		* eg 
			retuns all the document whose salary > 2000 and < 4000
			
			db.emp.find(
				{salary  : 
					{$gt : 2000,$lt : 4000}  
				}
				);
				
			--- , works or treated as a and operator 
			
	========================================================

		just for lab :
		
	Need to have default database for work 
	
	Mongodb allows to inport data in csv or json format 
	
	import data in the csv format : 

	mongoimport.exe --type csv -d rahulnewdatabase -c employees --headerline --drop "path of your csv file"
	
	
	mongoimport.exe --type csv -d rahulnewdatabase -c employees --headerline --drop "C:\Users\Priyanka Goel\Desktop\No SQL\employees.csv"
			
			
			
		------------------------------------------------------

							END FOR TODAY 
			
			
			
		
					
								DAY 12
							MONGODB : NOSQL
							
	=================================================================
	
		TOPIC : 
				MONGODB 
				BASIC THEORY 
				
					NOSQL : 
						CAP 
						PRACTICALLY : CAP 
							CA / CP / AP 
						
					* NO SCHEMA 
					* NO SQL 
					
					** DE-NORMALIZED THE DATA 
						** KEPT IN A FILES CALLED AS A DOCUMENT 
							** EMBEDED DOCUMENT 
							** SO THAT END USER OR THE USER 
								DO NOT PERFORM JOINS TO RETRIVE THE DATA 
					** MONGODB : 
							DOCUMENT ORIENTED DATABASE 
							OWN QUERY LANGUAGE 
							ACCEPTS DATA OR HANDLE THE DATA IN JSON 
							
							JSON : 
							
								{
									KEY : VALUE....
									KEY : VALUE
								}
							STORE IN THE DATABASE : 
								BSON : BINARY OF THE JSON ...
								
							DOCUMENT IS BYFAULT ASSIGNED WITH ONE FIELDS NAMED AS _ID 
							WHICH IS TREATED AS A PRIMARY KEY 
							THIS BECOMES A SEARCH CRITERIA TO FIND THE DOCUMENT FROM THE SYSTEM 
							
							MAIN OBJECT OF DEALING WITH MONGODB 
								"db"
							every query need to executed with the help of main object db 
							
					----------------------------
						*insert the data insert()
						* select the data find(query, projection)
						* comparision operators 
							$gt,$gte,$lt,$lte,$ne
							
			HOW TO IMPORT THE CSV FILE INTO THE MONGODB 
					
========================================================================
							
Comparison Operators : 
					
	** returns all the employees belongs to department 10 
	** returns all the employees having salary > 2000 
	** returns all the employees having salary > 2000 and salary < 10000
	
**return all the employees belongs to department 10, 20, 30 ..
	
		select * from employees where department_id in (10,20,30);
		
	* $in : return documents that the field value equals any value in the specified array...
	
	syntax : 
		db.employees.find({department_id : {$in : [10,20,30]}});
		
	return all the employees where department_in either 10,20 or 30 
	
	** if the field holds an array then $in returns documents whose fields holds an array that contains at least one elemment that matched a value 
	
			phone : [343433,3434,3434343]
			
		db.employees.find({phone : {$in:[7620987578,7620987867]}});
	
	* $nin  : return documents where field is not in specific array or does not exist 
	
		db.employees.find({department_id : {$nin : [20,30,40,80,50,110]}});
		
		returns all the employees those are not belongs to department 20,30,40,80
		and all the document which doesn't have department key
	
		rdbms : select * from employees where department_id not in (20,30,40,50,110,80);
		
-----------------------------------------------------------------------

Element Operators : 
		
		* $mod : will select the documents where the field value divided by the divisor has a specified reminder
		
		{field : {$mod :[devisor,reminder]}}

			* it divide with the help of divisor and comapare the reminder value ... 
			
			{salary " {$mod :[20,2]}}
		
				4004 / 20  = 4 
					start 4 = 2 
						false - skip that document 
						true - retun that document 
						
			
		* $exists : return documents that contain the field if boolean is true or not if boolean value is false 
		
		
		find all the documents contains field Phone :
		
			db.employees.find({Phone : {$exists : true}});
			
		
	------------------------------------------------------------
		db.employees.find({department_id : {$nin : [20,30,40,80,50,110]}});
		
	* find all the document which doesn't belongs to department 20,30,40,80,50,110 and doesn't have that key 
	
	db.employees.find({department_id : {$exists : true,$nin : [20,30,40,80,50,110]}});
	returns all the document where department_id exists and not in 20,30,40,80,50,110
		
****Logical Operator  - $and / $or 
		
* $and and operation on an array of two or more expression
			
		Need to find all the employees whose salary = 2800 and department_id = 80
		
		syntax : 
			
			standarization : code which need to read by other people 
			
			db.employees.find({$and : 
								[
								{salary : 2800},
								{department_id : 30}
								]}); 
		
		
			db.employees.find({salary : 2800,department_id : 30});
			
			
	** find all the employees whose salary > 3000 and department_id = 80
	
	
		select * from employees where salary > 3000 and department_id = 80;
		
		
		db.employees.find({$and : 
								[
								{salary : {$gt : 3000}},
								{department_id : 40},
								{department_id : {$exists : true}}
								]});
	
	
		and operator : array of expression
		
	
* $or Performs a logical OR operation on an array of the expression and reutns the documents that satisfied at least one of the expression....


 * Find all the employees whose salary > 15000 or belongs to department_id = 20 
	
			
		db.employees.find({
						$or :
							[
							{salary : {$gt : 15000}},
							{department_id : 20}
							]
						}
						).pretty();
							
							
* 						
	Find all the employees whose salary > 15000 or belongs to department_id = 20 and first_name = Michael						
							
		combination of and and or togeather : 
		
			db.employees.find(
						{
						first_name : "Micael",
						$or :
							[
							{salary : {$gt : 15000}},
							{department_id : 20}
							]
						}
						).pretty();				
							
			select * from employees where first_name = 'Micael' and (salary > 15000 or department_id = 20);			
	
*******************************************************************

and what about order ? 

* in order to control order you query will return matching documents, 
	just need to append the sort() method to a cursor 
	
* For each field in the sort document, it treated with two values 
			positive and negative 
			
			Positive  : will return the documents in assending order 
			Negative  : will return the documents in descending order 
			
	db.employees.find({salary : {$gt : 13000}}).sort({salary : 1});
	

	db.employees.find({salary : {$gt : 13000}}).sort({first_name : -1});

---------------------------------------------------------------------

method : limit 
		is the method which squese the output based on the number passed 
			
		db.employees.find().limit(2);	

	returns the first 2 documents from the collection employees .....
	
		
		db.employees.find({salary : {$gt : 3000}}).sort({first_name: 1}).limit(2);
	
							
--------------------------------------------------------------------

embedded documents 
	
		like : 
		
			{
			name : "rahul",
			salary  : 40000,
			address : 
					{
					hno : 123,
					street : "chandan nagar",
					city : "pune",
					state : "maharastra",
					zipcode : 411014
					}
			}

			mainkey.subjey 
			
			find all the documents who belongs to city = pune 
			
		** db.employees.find({"address.city" : "pune"});
		
========================================================================

BASIC AGGREGATED OPERATIONS : 

	* count : returns the count of the documents that would match a find() query 
		just append the count() methond to a find() query to reutn the number of matching documents
		
			syntax :
				
				db.collection.find(<query>).count();
				
		
* Total number of document in the collection : employees 

			rdbms : select count(*) from employees;
			
			mongo : db.employees.find().count();
	
* Total number of documents where department_id = 80

		db.employees.find({department_id : 80}).count();


*** distinct function in sql 
	* distinct method : 
			find the distinct values for a specific field within a single collection and returns the result in array 
			
		find all the department_id which has employees 
		
			select distinct department_id from employees;
			
			syntax : 
					db.collection.distinct("key");
					
			db.employees.distinct("department_id");		

BASIC : SELECTION OF THE RECORDS FROM THE COLLECTION


----------------------------------------------------------------------
							
		* INSERT THE VALUES
		* SELECT THE VALUES FROM THE COLLECTION 
		
UPDATE OPERATION : 

			DENSE_RANK(), RANK()  -- FUNCTION 
						- PROVIDES A NUMBER TO THE ROW BASED ON THE COLUMN 
						
-----------------------------------------------------------------------]]		
					: UPDATE OPERATIONS : 
					
 * UPDATE OPERATION TO MODIFY EXISTING REPORDS OR DOCUMENTS IN A COLLECTION 
 
		SYNTAX : 
			db.collection.update(query,update,option);
			
			where 
			
			query corresponds to where statement in sql 
			update : corresponds to your set in sql statement 
			
			update tablename 
			set salary = 4000  -------   <update> parameter of update f 
			where employee_id = 101; ----<query> paramter of update f
			
		* by default update() method update a single record or document, 
		just like you update in sql with limit 1 
		
		** restriction internally - it will only update single record

		if still we required to update more then one record in mongodb , we have use third parameter <option>
		
		updating more then one result can be done with a key : multi
		
		
		Parameter : update() 
		
		query : selection criteria 
		update : modification to apply 
		option : specifies wheather to perform an update on multiple documents 
			
		* modify the existing document , we have to set the expression inside the update parameter with $set operator 

		
	* to update the value of the field like salary , use $set 

		db.employees.update(
							{employee_id : 101},
							{$set : {salary : 5000}}
							);
		
	* update more then one fields of the document then : 
		like i need to update salary = 20000 and departmentid = 90
		
		update employees set salary = 20000,department_id = 90 where 
			condition....
			
		db.employees.update(
							{employee_id : 101},
							{$set : {salary : 20000,department_id : 90}}
							);
				
		
	* update the salary to 20000 for all the employees belongs to department = 20 
	
		db.employees.update(
							{department_id : 20},
							{$set : {salary : 20000}}
							);
		* only update single records as default nature of update method 
		
	* update all the records return from the selection criteria ...
			multi 
		db.employees.update(
							{department_id : 20},
							{$set : {salary : 20000}},
							{multi:true}
							);	
		
							
	* need to update the fields which is a part of your embedded documents ...

		
		db.employees.update(
							{department_id : 20},
							{$set : {"address.hno" : 1034}},
							{multi:true}
							);						
							
		OPEN SOURCE : 
				FETURE EXISTING 
				PROVIDES STANDARIZATION 
						FUNCTION 
							INSERT() - SINGLE RECORDS , INSERT MULTIPLE RECORD 
							
							INSERTMANY() : 
								
						db.employees.insert({},{},{});
						==========
						db.employees.insertmany([{},{},{}]);
							
						
						Similarly : 
							update / updatemany
						
 REMOVE A FIELD FROM A DOCUMENT : 

	* WHILE $SET OPERATOR, ADD A FIELD OR UPDATE ITS VALUE , 
			$UNSET OPERATOR REMOVED THE FIELD FROM THE DOCUMENT 
			
			
		db.employees.update(
						{employee_id : 101},
						{$unset : {salary : 1}}
						);
						
		delete the field salary from document where employee_id = 101 
		
		
		** value of the field in the $unset statement has no impact i.e we will have the same result in the above example if we do 
			{$unset : {salary : ""}}
			
		** in case document beging updated matches the initial query 
			employee_id : 101 
			but the field specified in the $unset command does not exist

				there is no impact on thedocument ...
				
	--------------------------------------------------------------

** Upsert : 
	
	* instead of having to query for existince of a record before performing update or insert , you can use upsert
	
	* update() operation can accept <upsert> as an option 
		
			db.collection.update(query, update,{upsert:true});
			
		* if the query matches an existing document(s), the upsert performs an update 
		*if the query matched no document in the collection, the upsert insert a single document in the collection ...
		
			if(query matches document)
				update 
			else 
				insert 
			end if 
			
		db.employees.update(
							{employee_id : 2000},
							{$set : 
								{first_name : "Rahul",salary : 45678,age : 35}},
							{upsert:true});
			
		if there is no document where employee_id = 2000
		
			then it created on document with the specifies key values..
			
	==================================================================
	
	REMOVING DOCUMENT FROM A COLLECTION : 
	
	* REMOVE METHOD 
			remove() method is used to remove the document from the collection
			
			remove(<query>);
			
		delete from employees where employees_id = 101;
		
		db.employees.remove({employee_id : 101});
		
	* if you don;t specify which documents need to remove i.e <query>
	is empty, 
	then all the documents will be removed from the collection .....
	
		** truncate in sql 
		
		delete from employees;
		
		db.employees.remove();
		
----------------------------------------------------------------------

	SQL : like search operator 
	
		mongodb also provide like search in terms regular expression 
		
		* find all the employees starting with letter R 
		
			^ - check the starting point 
			$ - check the ending point 
			. - any charecters 
			* - zero or many 
		db.employees.find({first_name:/ens/});
		
	operator : regex 

	find all the employees starting with R and ending with L 
	
	regex : 
	
		'^'+'R'+'.*'+'L$'
		
		db.employees.find({first_name: {"$regex" : '^'+'R'+'.*'+'l$'}});
		
------------------------------------------------------------------------

*************** select / insert / update /delete / alter ($set,$unset)

Rename the columns  : Rename the fields 

	Alter table tablename rename oldname to newname;
	
	db.collectionname.update(
							{query},
							{$rename : {oldname : newname}}
							);
							
	db.employees.update(
						{employee_id = 102},
						{$rename : {"department_id" : "deptid"}}
					);
					
	db.employees.update(
						{},
						{$rename : {"department_id" : "deptid"}}
					);				
					
----------------------------------------------------------------------

Rename the complete collection itself 

	function : renameCollection 
	
	
	db.emplyees.renameCollection(emp);
	
	-- 
	Alter table employees rename to emp;
	
=====================================================================

Aggregate Methods :
			count / distinct
			
	This method is use to perform aggregation on the columns like :-  
			* group by clause
			-- sum
			-- avg
			-- min
			-- max 
			....
			
			..
			
	
	syntax : 
		
			db.collection.aggregate(
				[
				{$group :
				{"_id" : "$department_id", group on this department_id
				"sal" : {$sum : "$salary"}  -- aggregate in salary
					}
				}
				]
				);

			db.emp.aggregate(
				[
				{$group :
				{"_id" : "$department_id",
				"sal" : {$sum : "$salary"}
				}
				}
				]
				);

------------ now if need to have a group by on multiple columns -----

			db.emp.aggregate(
				[
				{
					$group :
						{
							"_id" :
								{
								 "dept" : "$department_id",
								 "jobid" : "$job_id"
								},
							"sal" : {$sum : "$salary"}
						}
					}
					]
					);

------------- operator which works with aggregate method 
			project 
			
		find all the employees with their emplyee id and old salary 
			and incremented salary with 15% 
			
			
MYSQL : Select employee_id,salary , salary * 1.15 from employees;

mongodb : 

			db.emp.aggregate(
				[
					{$project :
						{employee_id : 1,salary : 1,_id:0,sumsal : {$multiply : ["$salary" , 1.15]}}
					}
				]
				);

	---------------------------------------------------------------
	
						End of the Basic Mongo 
						
							1) create database 
							2) create collection
							3) insert docments
							4) modify document - data and keys 
							5) delete document 
							6) select the data from the database 
							7) drop collection 
							
		------------------- drop database  : 
						this is not the simple feture
								database  : miltiple things 
								
					drop database directly.....
		-----------------------------------------------------------
					
			facebook : 

					username / password 
						username  ------- _id 
						
						_id - indexes 
						
		document 
					: _id and its location where it store 
					_id : 3434433434
					
					sigle document : 
							{
							
							}
			
	-----------------------------------------------------------------

		Sql on top of NoSQl 
			to make it simpler 
			
					nosql --- > wraper --- > sql 
	
	
	
	
	









		
		
		
		
		
		
		
		
	
			
		
		
		
		









	
			
			
			
			
			
			
			
						
						
								
			
			
			
			
		
		
		
				
				
						

		




						
										
										
				
				
				
				
				
				
				
							
				
				
				
						
				
				
				
				
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
			

		
		
		
		
		
		
		
		
		
				
		











	
				
				
				
				
				
				
				
				
		
		
		
		
		
		
		
		
		
		
	
				
			
			
			
			
			
			
			
			
			
			
				
					
							
							
						
						
					
					
					
					
					
					
					
					
					
					
					
					
					

















					
					
					
					
					
					
				
				
				
				
				
				
				
				
				
											
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
		
		
		
		
		
		
		
		
		
		
		
		
			
						
						
						
						
						
						
				
				
				
				












	
	
	
















			

						
						
						
						
						
						
						
						
						
				
				
				
				
				










	
									
									
								
			
			
			
			
			
			
			
			
			
			
					
				
				
				
				
				
				
				
				
				
				
				
					





								





	
					
					
					
					
					
					
					
					
					
					
					
							
							
							
							
							
							
							
							
		
							
				
				
				
				
				
				
									
									
									
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
								
								
								
								
								
								
				
					
					
			
				













			
			
			
			
			
					
					
					
			
			
			
			
			
			
			
			
			
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
			
			
			
			
			
			
			
			











					
					
					
					
					
					
					
					
					
					








			
					
					
					
					
					
					










	
			












				
	
			
			
			
			
			
			






			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 
			 

				
			














			
			
			
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
						
				
				
				
				
				
				
